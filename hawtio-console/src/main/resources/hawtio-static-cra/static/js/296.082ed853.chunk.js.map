{"version":3,"file":"static/js/296.082ed853.chunk.js","mappings":"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","sources":["../node_modules/@module-federation/utilities/dist|sync","utils/config/context.tsx","plugins/spring-config/DeleteConfirmation.tsx","plugins/spring-config/ImportConfiguration.tsx","lib/utils/src/utils/isObject.ts","lib/utils/src/utils/asNumber.ts","lib/utils/src/utils/constants.ts","lib/utils/src/utils/getUiOptions.ts","lib/utils/src/utils/canExpand.ts","lib/utils/src/utils/createErrorHandler.ts","lib/utils/src/utils/deepEquals.ts","lib/utils/src/utils/findSchemaDefinition.ts","lib/utils/src/utils/getOptionMatchingSimpleDiscriminator.ts","lib/utils/src/utils/schema/getMatchingOption.ts","lib/utils/src/utils/schema/getFirstMatchingOption.ts","lib/utils/src/utils/getDiscriminatorFieldFromSchema.ts","lib/utils/src/utils/guessType.ts","lib/utils/src/utils/getSchemaType.ts","lib/utils/src/utils/mergeSchemas.ts","lib/utils/src/utils/schema/retrieveSchema.ts","lib/utils/src/utils/schema/getClosestMatchingOption.ts","lib/utils/src/utils/isFixedItems.ts","lib/utils/src/utils/mergeDefaultsWithFormData.ts","lib/utils/src/utils/mergeObjects.ts","lib/utils/src/utils/schema/isSelect.ts","lib/utils/src/utils/isConstant.ts","lib/utils/src/utils/schema/isMultiSelect.ts","lib/utils/src/utils/schema/getDefaultFormState.ts","lib/utils/src/utils/isCustomWidget.ts","lib/utils/src/utils/schema/isFilesArray.ts","lib/utils/src/utils/schema/sanitizeDataForNewSchema.ts","lib/utils/src/utils/schema/toIdSchema.ts","lib/utils/src/utils/schema/toPathSchema.ts","lib/utils/src/utils/createSchemaUtils.ts","lib/utils/src/utils/schema/getDisplayLabel.ts","lib/utils/src/utils/schema/mergeValidationData.ts","lib/utils/src/utils/pad.ts","lib/utils/src/utils/dateRangeOptions.ts","lib/utils/src/utils/englishStringTranslator.ts","lib/utils/src/utils/replaceStringParameters.ts","lib/utils/src/utils/enumOptionsValueForIndex.ts","lib/utils/src/utils/enumOptionsDeselectValue.ts","lib/utils/src/utils/enumOptionsIsSelected.ts","lib/utils/src/utils/enumOptionsIndexForValue.ts","lib/utils/src/utils/enumOptionsSelectValue.ts","lib/utils/src/utils/getDateElementProps.ts","lib/utils/src/utils/rangeSpec.ts","lib/utils/src/utils/getInputProps.ts","lib/utils/src/utils/getSubmitButtonOptions.ts","lib/utils/src/utils/getTemplate.ts","lib/utils/src/utils/getWidget.tsx","lib/utils/src/utils/idGenerators.ts","lib/utils/src/utils/labelValue.ts","lib/utils/src/utils/optionsList.ts","lib/utils/src/utils/toConstant.ts","lib/utils/src/utils/parseDateString.ts","lib/utils/src/utils/schemaRequiresTrueValue.ts","lib/utils/src/utils/toDateString.ts","lib/utils/src/utils/toErrorList.ts","lib/utils/src/utils/ErrorSchemaBuilder.ts","lib/utils/src/utils/unwrapErrorHandler.ts","lib/utils/src/utils/utcToLocal.ts","lib/utils/src/utils/validationDataMerge.ts","lib/utils/src/utils/withIdRefPrefix.ts","lib/utils/src/utils/enums.ts","lib/ajv/src/utils/createAjvInstance.ts","lib/ajv/src/utils/processRawValidationErrors.ts","lib/utils/src/utils/toErrorSchema.ts","lib/ajv/src/utils/validator.ts","lib/utils/src/utils/hashForSchema.ts","lib/ajv/src/index.ts","lib/ajv/src/utils/customizeValidator.ts","lib/core/src/components/fields/ArrayField.tsx","lib/utils/src/utils/allowAdditionalItems.ts","lib/core/src/components/fields/BooleanField.tsx","lib/core/src/components/fields/MultiSchemaField.tsx","lib/core/src/components/fields/NumberField.tsx","lib/core/src/components/fields/ObjectField.tsx","lib/utils/src/utils/orderProperties.ts","lib/core/src/components/fields/SchemaField.tsx","lib/core/src/components/fields/StringField.tsx","lib/utils/src/utils/hasWidget.ts","lib/core/src/components/fields/NullField.tsx","lib/core/src/components/fields/index.ts","lib/core/src/components/templates/ArrayFieldDescriptionTemplate.tsx","lib/core/src/components/templates/ArrayFieldItemTemplate.tsx","lib/core/src/components/templates/ArrayFieldTemplate.tsx","lib/core/src/components/templates/ArrayFieldTitleTemplate.tsx","lib/core/src/components/templates/BaseInputTemplate.tsx","lib/core/src/components/templates/ButtonTemplates/SubmitButton.tsx","lib/core/src/components/templates/ButtonTemplates/IconButton.tsx","lib/core/src/components/templates/ButtonTemplates/AddButton.tsx","lib/core/src/components/templates/ButtonTemplates/index.ts","lib/core/src/components/templates/DescriptionField.tsx","lib/core/src/components/templates/ErrorList.tsx","lib/core/src/components/templates/FieldTemplate/Label.tsx","lib/core/src/components/templates/FieldTemplate/index.ts","lib/core/src/components/templates/FieldTemplate/FieldTemplate.tsx","lib/core/src/components/templates/FieldErrorTemplate.tsx","lib/core/src/components/templates/FieldHelpTemplate.tsx","lib/core/src/components/templates/ObjectFieldTemplate.tsx","lib/core/src/components/templates/TitleField.tsx","lib/core/src/components/templates/UnsupportedField.tsx","lib/core/src/components/templates/WrapIfAdditionalTemplate.tsx","lib/core/src/components/templates/index.ts","lib/core/src/components/widgets/AltDateWidget.tsx","lib/core/src/components/widgets/AltDateTimeWidget.tsx","lib/core/src/components/widgets/CheckboxWidget.tsx","lib/core/src/components/widgets/CheckboxesWidget.tsx","lib/core/src/components/widgets/ColorWidget.tsx","lib/core/src/components/widgets/DateWidget.tsx","lib/core/src/components/widgets/DateTimeWidget.tsx","lib/utils/src/utils/localToUTC.ts","lib/core/src/components/widgets/EmailWidget.tsx","lib/core/src/components/widgets/FileWidget.tsx","lib/utils/src/utils/dataURItoBlob.ts","lib/core/src/components/widgets/HiddenWidget.tsx","lib/core/src/components/widgets/PasswordWidget.tsx","lib/core/src/components/widgets/RadioWidget.tsx","lib/core/src/components/widgets/RangeWidget.tsx","lib/core/src/components/widgets/SelectWidget.tsx","lib/core/src/components/widgets/TextareaWidget.tsx","lib/core/src/components/widgets/TextWidget.tsx","lib/core/src/components/widgets/TimeWidget.tsx","lib/core/src/components/widgets/URLWidget.tsx","lib/core/src/components/widgets/UpDownWidget.tsx","lib/core/src/components/widgets/index.ts","lib/core/src/components/Form.tsx","lib/core/src/getDefaultRegistry.ts","lib/patternfly/src/AddButton/AddButton.tsx","lib/patternfly/src/ArrayFieldItemTemplate/ArrayFieldItemTemplate.tsx","lib/patternfly/src/ArrayFieldTemplate/ArrayFieldTemplate.tsx","lib/patternfly/src/BaseInputTemplate/BaseInputTemplate.tsx","lib/patternfly/src/DescriptionField/DescriptionField.tsx","lib/patternfly/src/ErrorList/ErrorList.tsx","lib/patternfly/src/IconButton/IconButton.tsx","lib/patternfly/src/FieldErrorTemplate/FieldErrorTemplate.tsx","lib/patternfly/src/FieldHelpTemplate/FieldHelpTemplate.tsx","lib/patternfly/src/FieldTemplate/FieldTemplate.tsx","lib/patternfly/src/ObjectFieldTemplate/ObjectFieldTemplate.tsx","lib/patternfly/src/SubmitButton/SubmitButton.tsx","lib/patternfly/src/TitleField/TitleField.tsx","lib/patternfly/src/WrapIfAdditionalTemplate/WrapIfAdditionalTemplate.tsx","lib/patternfly/src/Templates/Templates.ts","lib/patternfly/src/CheckboxWidget/CheckboxWidget.tsx","lib/patternfly/src/CheckboxesWidget/CheckboxesWidget.tsx","lib/patternfly/src/RadioWidget/RadioWidget.tsx","lib/patternfly/src/RangeWidget/RangeWidget.tsx","lib/patternfly/src/SelectWidget/SelectWidget.tsx","lib/patternfly/src/TextareaWidget/TextareaWidget.tsx","lib/patternfly/src/Widgets/Widgets.ts","lib/patternfly/src/Theme/Theme.tsx","lib/patternfly/src/Form/Form.tsx","lib/core/src/withTheme.tsx","lib/patternfly/src/index.ts","plugins/spring-config/ConfigurationDataEditForm.tsx","plugins/spring-config/ConfigurationDataCreateForm.tsx","plugins/spring-config/ConfigurationAppDetails.tsx","utils/error-boundary/ErrorBoundaryContext.tsx","utils/error-boundary/ErrorBoundaryContextProvider.tsx","utils/error-boundary/useErrorBoundary.ts","utils/error-boundary/assertErrorBoundaryContext.ts","utils/error-boundary/ErrorBoundary.tsx","plugins/spring-config/spring-config.tsx","plugins/refresh-config/refresh-config.tsx","bootstrap.tsx","plugins/spring-config/index.ts","plugins/refresh-config/index.ts"],"sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 13008;\nmodule.exports = webpackEmptyContext;","import { createContext,  useContext, useEffect, useMemo, useState} from 'react';\r\nexport const MyConfigContext = createContext({config: {}});\r\n\r\nexport const useMyConfigContext = () => {\r\n  return useContext(MyConfigContext);\r\n}\r\n\r\nexport function MyConfigProvider({ children }: {children: React.ReactNode}) {\r\n  const [config, setConfig] = useState({});\r\n  useEffect(() => {\r\n    // fetch data\r\n    const dataFetch = async () => {\r\n      const data = await (\r\n        await fetch(\r\n          '/my-camel/admin/api/react-config',\r\n        )\r\n      ).json();\r\n      console.log(\"myConfig: \", data);\r\n      // set state when the data received\r\n      setConfig(data.config);\r\n    };\r\n\r\n    dataFetch();\r\n  }, []);\r\n  const value = useMemo(\r\n    () => ({\r\n      config: {\r\n        ...config\r\n      }\r\n    }),\r\n    [config],\r\n  );\r\n  return (\r\n    <MyConfigContext.Provider value = {value}>\r\n      {children}\r\n    </MyConfigContext.Provider>\r\n  );\r\n}\r\nexport default MyConfigProvider;","import { Button, Modal, ModalVariant } from \"@patternfly/react-core\";\r\nimport { DeleteModalProp } from \"./ConfigurationModel\";\r\n\r\nconst DeleteConfirmation = ({ showModal, hideModal, confirmModal, row, message }: DeleteModalProp) => {\r\n    return (\r\n      <Modal\r\n          bodyAriaLabel=\"Scrollable modal content\"\r\n          tabIndex={0}\r\n          variant={ModalVariant.medium}\r\n          title=\"Delete Confirmation\"\r\n          isOpen={showModal}\r\n          onClose={hideModal}\r\n          actions={[\r\n            <Button variant=\"danger\" onClick={() => confirmModal(row) }>\r\n              Delete\r\n            </Button>,\r\n            <Button variant=\"secondary\" onClick={hideModal}>\r\n              Cancel\r\n            </Button>\r\n        ]}\r\n      >\r\n        <div className=\"alert alert-danger\">{message}</div>\r\n      </Modal>\r\n    )\r\n}\r\n \r\nexport default DeleteConfirmation;","\r\nimport React, { useRef, useState } from \"react\";\r\nimport { Modal, ModalVariant, Button } from '@patternfly/react-core';\r\nimport { ImportModalProp } from \"./ConfigurationModel\";\r\n\r\nconst ImportConfiguration = ({ showModal, hideModal, importConfiguration }: ImportModalProp) => {\r\n  const [uploadedFile, setUploadedFile] = useState<File|null>(null);  \r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n    \r\n  const handleUpload = () => {\r\n      inputRef.current?.click();\r\n  };\r\n  const handleDisplayFileDetails = () => {\r\n      inputRef.current?.files && setUploadedFile(inputRef.current.files[0]);\r\n  };\r\n\r\n  async function  importConfigurationData() {\r\n      uploadedFile && importConfiguration(uploadedFile);\r\n  }\r\n  return (\r\n    <Modal\r\n        bodyAriaLabel=\"Scrollable modal content\"\r\n        tabIndex={0}\r\n        variant={ModalVariant.medium}\r\n        title=\"Import Spring Configurations\"\r\n        isOpen={showModal}\r\n        onClose={hideModal}\r\n        actions={[\r\n          <Button variant=\"primary\" isDisabled={!uploadedFile} onClick={(event) => {event.preventDefault(); importConfigurationData();} }>\r\n            Import\r\n          </Button>,\r\n          <Button variant=\"secondary\" onClick={hideModal}>\r\n            Cancel\r\n          </Button>\r\n      ]}\r\n    >\r\n      <label htmlFor=\"name\" className=\"mx-3\">Choose file: </label>\r\n      <input id=\"file\" ref={inputRef} onChange={handleDisplayFileDetails} className=\"d-none\" type=\"file\" />\r\n      <button onClick={handleUpload} className={`btn btn-outline-${uploadedFile ? \"success\" : \"primary\"}`}>\r\n        {uploadedFile ? uploadedFile.name : \"Upload\"}\r\n      </button>\r\n    </Modal>\r\n  )\r\n}\r\n\r\nexport default ImportConfiguration;","/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\r\nexport default function isObject(thing: any) {\r\n  if (typeof File !== 'undefined' && thing instanceof File) {\r\n    return false;\r\n  }\r\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\r\n    return false;\r\n  }\r\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\r\n}\r\n","/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\r\nexport default function asNumber(value: string | null) {\r\n  if (value === '') {\r\n    return undefined;\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (/\\.$/.test(value)) {\r\n    // '3.' can't really be considered a number even if it parses in js. The\r\n    // user is most likely entering a float.\r\n    return value;\r\n  }\r\n  if (/\\.0$/.test(value)) {\r\n    // we need to return this as a string here, to allow for input like 3.07\r\n    return value;\r\n  }\r\n\r\n  if (/\\.\\d*0$/.test(value)) {\r\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\r\n    // with the user when entering dollar amounts or other values (such as those with\r\n    // specific precision or number of significant digits)\r\n    return value;\r\n  }\r\n\r\n  const n = Number(value);\r\n  const valid = typeof n === 'number' && !Number.isNaN(n);\r\n\r\n  return valid ? n : value;\r\n}\r\n","/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITIONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\r\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\r\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\r\nexport const ALL_OF_KEY = 'allOf';\r\nexport const ANY_OF_KEY = 'anyOf';\r\nexport const CONST_KEY = 'const';\r\nexport const DEFAULT_KEY = 'default';\r\nexport const DEFINITIONS_KEY = 'definitions';\r\nexport const DEPENDENCIES_KEY = 'dependencies';\r\nexport const ENUM_KEY = 'enum';\r\nexport const ERRORS_KEY = '__errors';\r\nexport const ID_KEY = '$id';\r\nexport const IF_KEY = 'if';\r\nexport const ITEMS_KEY = 'items';\r\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\r\nexport const NAME_KEY = '$name';\r\nexport const ONE_OF_KEY = 'oneOf';\r\nexport const PROPERTIES_KEY = 'properties';\r\nexport const REQUIRED_KEY = 'required';\r\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\r\nexport const REF_KEY = '$ref';\r\n/**\r\n * @deprecated Replace with correctly spelled constant `RJSF_ADDITIONAL_PROPERTIES_FLAG`\r\n */\r\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const RJSF_ADDITIONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\r\nexport const UI_FIELD_KEY = 'ui:field';\r\nexport const UI_WIDGET_KEY = 'ui:widget';\r\nexport const UI_OPTIONS_KEY = 'ui:options';\r\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\r\n","import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\r\nimport isObject from './isObject';\r\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\r\n\r\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\r\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  globalOptions: GlobalUISchemaOptions = {}\r\n): UIOptionsType<T, S, F> {\r\n  return Object.keys(uiSchema)\r\n    .filter((key) => key.indexOf('ui:') === 0)\r\n    .reduce(\r\n      (options, key) => {\r\n        const value = uiSchema[key];\r\n        if (key === UI_WIDGET_KEY && isObject(value)) {\r\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\r\n          return options;\r\n        }\r\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\r\n          return { ...options, ...value };\r\n        }\r\n        return { ...options, [key.substring(3)]: value };\r\n      },\r\n      { ...globalOptions }\r\n    );\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\r\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  formData?: T\r\n) {\r\n  if (!schema.additionalProperties) {\r\n    return false;\r\n  }\r\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\r\n  if (expandable === false) {\r\n    return expandable;\r\n  }\r\n  // if ui:options.expandable was not explicitly set to false, we can add\r\n  // another property if we have not exceeded maxProperties yet\r\n  if (schema.maxProperties !== undefined && formData) {\r\n    return Object.keys(formData).length < schema.maxProperties;\r\n  }\r\n  return true;\r\n}\r\n","import isPlainObject from 'lodash-es/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n *\r\n * @param formData - The form data around which the error handler is created\r\n * @returns - A `FormValidation` object based on the `formData` structure\r\n */\r\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\r\n  const handler: FieldValidation = {\r\n    // We store the list of errors for this node in a property named __errors\r\n    // to avoid name collision with a possible sub schema field named\r\n    // 'errors' (see `utils.toErrorSchema`).\r\n    [ERRORS_KEY]: [],\r\n    addError(message: string) {\r\n      this[ERRORS_KEY]!.push(message);\r\n    },\r\n  };\r\n  if (Array.isArray(formData)) {\r\n    return formData.reduce((acc, value, key) => {\r\n      return { ...acc, [key]: createErrorHandler(value) };\r\n    }, handler);\r\n  }\r\n  if (isPlainObject(formData)) {\r\n    const formObject: GenericObjectType = formData as GenericObjectType;\r\n    return Object.keys(formObject).reduce((acc, key) => {\r\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\r\n    }, handler as FormValidation<T>);\r\n  }\r\n  return handler as FormValidation<T>;\r\n}\r\n","import isEqualWith from 'lodash-es/isEqualWith';\r\n\r\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\r\nexport default function deepEquals(a: any, b: any): boolean {\r\n  return isEqualWith(a, b, (obj: any, other: any) => {\r\n    if (typeof obj === 'function' && typeof other === 'function') {\r\n      // Assume all functions are equivalent\r\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\r\n      return true;\r\n    }\r\n    return undefined; // fallback to default isEquals behavior\r\n  });\r\n}\r\n","import jsonpointer from 'jsonpointer';\r\nimport omit from 'lodash-es/omit';\r\n\r\nimport { REF_KEY } from './constants';\r\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\r\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\r\n  const value = object[key];\r\n  const remaining = omit(object, [key]);\r\n  return [remaining, value];\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, recursively look up and return the\r\n * sub-schema using the path provided by that reference. If `#` is not the first character of the reference, the path\r\n * does not exist in the schema, or the reference resolves circularly back to itself, then throw an Error.\r\n * Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @param recurseList - List of $refs already resolved to prevent recursion\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference could be resolved\r\n */\r\nexport function findSchemaDefinitionRecursive<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S,\r\n  recurseList: string[] = []\r\n): S {\r\n  const ref = $ref || '';\r\n  let decodedRef;\r\n  if (ref.startsWith('#')) {\r\n    // Decode URI fragment representation.\r\n    decodedRef = decodeURIComponent(ref.substring(1));\r\n  } else {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const current: S = jsonpointer.get(rootSchema, decodedRef);\r\n  if (current === undefined) {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const nextRef = current[REF_KEY];\r\n  if (nextRef) {\r\n    // Check for circular references.\r\n    if (recurseList.includes(nextRef)) {\r\n      if (recurseList.length === 1) {\r\n        throw new Error(`Definition for ${$ref} is a circular reference`);\r\n      }\r\n      const [firstRef, ...restRefs] = recurseList;\r\n      const circularPath = [...restRefs, ref, firstRef].join(' -> ');\r\n      throw new Error(`Definition for ${firstRef} contains a circular reference through ${circularPath}`);\r\n    }\r\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\r\n    const subSchema = findSchemaDefinitionRecursive<S>(theRef, rootSchema, [...recurseList, ref]);\r\n    if (Object.keys(remaining).length > 0) {\r\n      return { ...remaining, ...subSchema };\r\n    }\r\n    return subSchema;\r\n  }\r\n  return current;\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, the path does not exist in\r\n * the schema, or the reference resolves circularly back to itself, then throw an Error. Otherwise return the\r\n * sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference could be resolved\r\n */\r\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S\r\n): S {\r\n  const recurseList: string[] = [];\r\n  return findSchemaDefinitionRecursive($ref, rootSchema, recurseList);\r\n}\r\n","import get from 'lodash-es/get';\r\nimport { PROPERTIES_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\r\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\r\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\r\n *\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or undefined if there is no match\r\n */\r\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\r\n  formData: T | undefined,\r\n  options: S[],\r\n  discriminatorField?: string\r\n): number | undefined {\r\n  if (formData && discriminatorField) {\r\n    const value = get(formData, discriminatorField);\r\n\r\n    if (value === undefined) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < options.length; i++) {\r\n      const option = options[i];\r\n      const discriminator: S = get(option, [PROPERTIES_KEY, discriminatorField], {}) as S;\r\n       \r\n      if (discriminator['type'] === 'object' || discriminator['type'] === 'array') {\r\n        continue;\r\n      }\r\n\r\n      if (discriminator['const'] === value) {\r\n        return i;\r\n      }\r\n\r\n      if (discriminator['enum']?.includes(value)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  return;\r\n}\r\n","import get from 'lodash-es/get';\r\nimport has from 'lodash-es/has';\r\nimport isNumber from 'lodash-es/isNumber';\r\n\r\nimport { PROPERTIES_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n * Deprecated, use `getFirstMatchingOption()` instead.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or 0 if none is available\r\n * @deprecated\r\n */\r\nexport default function getMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  // For performance, skip validating subschemas if formData is undefined. We just\r\n  // want to get the first option in that case.\r\n  if (formData === undefined) {\r\n    return 0;\r\n  }\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  for (let i = 0; i < options.length; i++) {\r\n    const option = options[i];\r\n\r\n    // If we have a discriminator field, then we will use this to make the determination\r\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\r\n      const value = get(formData, discriminatorField);\r\n      const discriminator: S = get(option, [PROPERTIES_KEY, discriminatorField], {}) as S;\r\n      if (validator.isValid(discriminator, value, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (option[PROPERTIES_KEY]) {\r\n      // If the schema describes an object then we need to add slightly more\r\n      // strict matching to the schema, because unless the schema uses the\r\n      // \"requires\" keyword, an object will match the schema as long as it\r\n      // doesn't have matching keys with a conflicting type. To do this we use an\r\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\r\n      // schema should match if any of the keys in the schema are present on the\r\n      // object and pass validation.\r\n      //\r\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\r\n      // \"properties\" object\r\n      const requiresAnyOf = {\r\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\r\n          required: [key],\r\n        })),\r\n      };\r\n\r\n      let augmentedSchema;\r\n\r\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\r\n      if (option.anyOf) {\r\n        // Create a shallow clone of the option\r\n        const { ...shallowClone } = option;\r\n\r\n        if (!shallowClone.allOf) {\r\n          shallowClone.allOf = [];\r\n        } else {\r\n          // If \"allOf\" already exists, shallow clone the array\r\n          shallowClone.allOf = shallowClone.allOf.slice();\r\n        }\r\n\r\n        shallowClone.allOf.push(requiresAnyOf);\r\n\r\n        augmentedSchema = shallowClone;\r\n      } else {\r\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\r\n      }\r\n\r\n      // Remove the \"required\" field as it's likely that not all fields have\r\n      // been filled in yet, which will mean that the schema is not valid\r\n      delete augmentedSchema.required;\r\n\r\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (validator.isValid(option, formData, rootSchema)) {\r\n      return i;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n","import getMatchingOption from './getMatchingOption';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\r\nexport default function getFirstMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\r\n}\r\n","import get from 'lodash-es/get';\r\nimport isString from 'lodash-es/isString';\r\n\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\r\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\r\n *\r\n * @param schema - The schema from which the discriminator is potentially obtained\r\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\r\n */\r\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  let discriminator: string | undefined;\r\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\r\n  if (isString(maybeString)) {\r\n    discriminator = maybeString;\r\n  } else if (maybeString !== undefined) {\r\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\r\n  }\r\n  return discriminator;\r\n}\r\n","/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\r\nexport default function guessType(value: any) {\r\n  if (Array.isArray(value)) {\r\n    return 'array';\r\n  }\r\n  if (typeof value === 'string') {\r\n    return 'string';\r\n  }\r\n  if (value == null) {\r\n    return 'null';\r\n  }\r\n  if (typeof value === 'boolean') {\r\n    return 'boolean';\r\n  }\r\n  if (!isNaN(value)) {\r\n    return 'number';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return 'object';\r\n  }\r\n  // Default to string if we can't figure it out\r\n  return 'string';\r\n}\r\n","import guessType from './guessType';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\r\n * other elements of the schema as follows:\r\n * - schema.const: Returns the `guessType()` of that value\r\n * - schema.enum: Returns `string`\r\n * - schema.properties: Returns `object`\r\n * - schema.additionalProperties: Returns `object`\r\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\r\n *\r\n * @param schema - The schema for which to get the type\r\n * @returns - The type of the schema\r\n */\r\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): string | string[] | undefined {\r\n  let { type } = schema;\r\n\r\n  if (!type && schema.const) {\r\n    return guessType(schema.const);\r\n  }\r\n\r\n  if (!type && schema.enum) {\r\n    return 'string';\r\n  }\r\n\r\n  if (!type && (schema.properties || schema.additionalProperties)) {\r\n    return 'object';\r\n  }\r\n\r\n  if (Array.isArray(type)) {\r\n    if (type.length === 2 && type.includes('null')) {\r\n      type = type.find((type) => type !== 'null');\r\n    } else {\r\n      type = type[0];\r\n    }\r\n  }\r\n\r\n  return type;\r\n}\r\n","import union from 'lodash-es/union';\r\n\r\nimport { REQUIRED_KEY } from './constants';\r\nimport getSchemaType from './getSchemaType';\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\r\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\r\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeSchemas(left, right);\r\n    } else if (\r\n      obj1 &&\r\n      obj2 &&\r\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\r\n      key === REQUIRED_KEY &&\r\n      Array.isArray(left) &&\r\n      Array.isArray(right)\r\n    ) {\r\n      // Don't include duplicate values when merging 'required' fields.\r\n      acc[key] = union(left, right);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, acc);\r\n}\r\n","import get from 'lodash-es/get';\r\nimport isEqual from 'lodash-es/isEqual';\r\nimport set from 'lodash-es/set';\r\nimport times from 'lodash-es/times';\r\nimport transform from 'lodash-es/transform';\r\nimport merge from 'lodash-es/merge';\r\nimport flattenDeep from 'lodash-es/flattenDeep';\r\nimport uniq from 'lodash-es/uniq';\r\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\r\n\r\nimport {\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  DEPENDENCIES_KEY,\r\n  IF_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  PROPERTIES_KEY,\r\n  ITEMS_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport guessType from '../guessType';\r\nimport isObject from '../isObject';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\n\r\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\r\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\r\n * potentially recursive resolution.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n */\r\nexport default function retrieveSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\r\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\r\n}\r\n\r\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\r\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\r\n * conditions will be returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\r\n * @param schema - The schema for which resolving a condition is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\r\n */\r\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\r\n\r\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\r\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\r\n  let schemas: S[] = [];\r\n  if (expandAllBranches) {\r\n    if (then && typeof then !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n    if (otherwise && typeof otherwise !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n  } else {\r\n    const conditionalSchema = conditionValue ? then : otherwise;\r\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(\r\n          validator,\r\n          conditionalSchema as S,\r\n          rootSchema,\r\n          formData,\r\n          expandAllBranches,\r\n          recurseList\r\n        )\r\n      );\r\n    }\r\n  }\r\n  if (schemas.length) {\r\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\r\n  }\r\n  return resolvedSchemas.flatMap((s) =>\r\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\r\n  );\r\n}\r\n\r\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\r\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\r\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\r\n *\r\n * For example:\r\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\r\n *   C schemas then:\r\n *   - The permutation for the first row is `[[A]]`\r\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\r\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\r\n *\r\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\r\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\r\n */\r\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\r\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\r\n    (permutations, list) => {\r\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\r\n      if (list.length > 1) {\r\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\r\n      }\r\n      // Otherwise just push in the single value into the current set of permutations\r\n      permutations.forEach((permutation) => permutation.push(list[0]));\r\n      return permutations;\r\n    },\r\n    [[]] as S[][] // Start with an empty list\r\n  );\r\n\r\n  return allPermutations;\r\n}\r\n\r\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\r\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\r\n */\r\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchemas = resolveReference<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    formData\r\n  );\r\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\r\n    // return the updatedSchemas array if it has either multiple schemas within it\r\n    // OR the first schema is not the same as the original schema\r\n    return updatedSchemas;\r\n  }\r\n  if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchemas = resolveDependencies<T, S, F>(\r\n      validator,\r\n      schema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    );\r\n    return resolvedSchemas.flatMap((s) => {\r\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\r\n    });\r\n  }\r\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\r\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\r\n      retrieveSchemaInternal<T, S, F>(\r\n        validator,\r\n        allOfSubschema as S,\r\n        rootSchema,\r\n        formData,\r\n        expandAllBranches,\r\n        recurseList\r\n      )\r\n    );\r\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\r\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\r\n  }\r\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\r\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\r\n * helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a reference is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list schemas retrieved after having all references resolved\r\n */\r\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\r\n  if (updatedSchema !== schema) {\r\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\r\n    return retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      updatedSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within the schema itself as well as any of its properties and array items.\r\n *\r\n * @param schema - The schema for which resolving all references is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param recurseList - List of $refs already resolved to prevent recursion\r\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\r\n */\r\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  rootSchema: S,\r\n  recurseList: string[]\r\n): S {\r\n  if (!isObject(schema)) {\r\n    return schema;\r\n  }\r\n  let resolvedSchema: S = schema;\r\n  // resolve top level ref\r\n  if (REF_KEY in resolvedSchema) {\r\n    const { $ref, ...localSchema } = resolvedSchema;\r\n    // Check for a recursive reference and stop the loop\r\n    if (recurseList.includes($ref!)) {\r\n      return resolvedSchema;\r\n    }\r\n    recurseList.push($ref!);\r\n    // Retrieve the referenced schema definition.\r\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\r\n    resolvedSchema = { ...refSchema, ...localSchema };\r\n  }\r\n\r\n  if (PROPERTIES_KEY in resolvedSchema) {\r\n    const childrenLists: string[][] = [];\r\n    const updatedProps = transform(\r\n      resolvedSchema[PROPERTIES_KEY]!,\r\n      (result, value, key: string) => {\r\n        const childList: string[] = [...recurseList];\r\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\r\n        childrenLists.push(childList);\r\n      },\r\n      {} as RJSFSchema\r\n    );\r\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\r\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\r\n  }\r\n\r\n  if (\r\n    ITEMS_KEY in resolvedSchema &&\r\n    !Array.isArray(resolvedSchema.items) &&\r\n    typeof resolvedSchema.items !== 'boolean'\r\n  ) {\r\n    resolvedSchema = {\r\n      ...resolvedSchema,\r\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\r\n    };\r\n  }\r\n\r\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\r\n}\r\n\r\n/** Creates new 'properties' items for each key in the `formData`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the existing additional properties is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\r\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The updated schema with additional properties stubbed\r\n */\r\nexport function stubExistingAdditionalProperties<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\r\n  // Clone the schema so that we don't ruin the consumer's original\r\n  const schema = {\r\n    ...theSchema,\r\n    properties: { ...theSchema.properties },\r\n  };\r\n\r\n  // make sure formData is an object\r\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\r\n  Object.keys(formData).forEach((key) => {\r\n    if (key in schema.properties) {\r\n      // No need to stub, our schema already has the property\r\n      return;\r\n    }\r\n\r\n    let additionalProperties: S['additionalProperties'] = {};\r\n    if (typeof schema.additionalProperties !== 'boolean') {\r\n      if (REF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = retrieveSchema<T, S, F>(\r\n          validator,\r\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\r\n          rootSchema,\r\n          formData as T\r\n        );\r\n      } else if ('type' in schema.additionalProperties!) {\r\n        additionalProperties = { ...schema.additionalProperties };\r\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = {\r\n          type: 'object',\r\n          ...schema.additionalProperties,\r\n        };\r\n      } else {\r\n        additionalProperties = { type: guessType(get(formData, [key])) };\r\n      }\r\n    } else {\r\n      additionalProperties = { type: guessType(get(formData, [key])) };\r\n    }\r\n\r\n    // The type of our new key should match the additionalProperties value;\r\n    schema.properties[key] = additionalProperties;\r\n    // Set our additional property flag so we know it was dynamically added\r\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\r\n  });\r\n\r\n  return schema;\r\n}\r\n\r\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\r\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\r\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\r\n * of the schema and its references, conditions and dependencies are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param [recurseList=[]] - The optional, list of recursive references already processed\r\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\r\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\r\n */\r\nexport function retrieveSchemaInternal<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  rawFormData?: T,\r\n  expandAllBranches = false,\r\n  recurseList: string[] = []\r\n): S[] {\r\n  if (!isObject(schema)) {\r\n    return [{} as S];\r\n  }\r\n  const resolvedSchemas = resolveSchema<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    rawFormData\r\n  );\r\n  return resolvedSchemas.flatMap((s: S) => {\r\n    let resolvedSchema = s;\r\n    if (IF_KEY in resolvedSchema) {\r\n      return resolveCondition<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        rawFormData as T\r\n      );\r\n    }\r\n    if (ALL_OF_KEY in resolvedSchema) {\r\n      // resolve allOf schemas\r\n      if (expandAllBranches) {\r\n        const { allOf, ...restOfSchema } = resolvedSchema;\r\n        return [...(allOf as S[]), restOfSchema as S];\r\n      }\r\n      try {\r\n        resolvedSchema = mergeAllOf(resolvedSchema, {\r\n          deep: false,\r\n        } as Options) as S;\r\n      } catch (e) {\r\n        console.warn('could not merge subschemas in allOf:\\n', e);\r\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\r\n        return resolvedSchemaWithoutAllOf as S;\r\n      }\r\n    }\r\n    const hasAdditionalProperties =\r\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\r\n    if (hasAdditionalProperties) {\r\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\r\n    }\r\n\r\n    return resolvedSchema;\r\n  });\r\n}\r\n\r\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\r\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\r\n * options are retrieved and returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function resolveAnyOrOneOfSchemas<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\r\n  let anyOrOneOf: S[] | undefined;\r\n  const { oneOf, anyOf, ...remaining } = schema;\r\n  if (Array.isArray(oneOf)) {\r\n    anyOrOneOf = oneOf as S[];\r\n  } else if (Array.isArray(anyOf)) {\r\n    anyOrOneOf = anyOf as S[];\r\n  }\r\n  if (anyOrOneOf) {\r\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\r\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    anyOrOneOf = anyOrOneOf.map((s) => {\r\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\r\n      // can resolve recursive references independently\r\n      return resolveAllReferences(s, rootSchema, []);\r\n    });\r\n    // Call this to trigger the set of isValid() calls that the schema parser will need\r\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\r\n    if (expandAllBranches) {\r\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\r\n    }\r\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\r\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependency is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas with their dependencies resolved\r\n */\r\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  // Drop the dependencies from the source schema.\r\n  const { dependencies, ...remainingSchema } = schema;\r\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\r\n    validator,\r\n    remainingSchema as S,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    formData\r\n  );\r\n  return resolvedSchemas.flatMap((resolvedSchema) =>\r\n    processDependencies<T, S, F>(\r\n      validator,\r\n      dependencies,\r\n      resolvedSchema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    )\r\n  );\r\n}\r\n\r\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\r\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param dependencies - The set of dependencies that needs to be processed\r\n * @param resolvedSchema - The schema for which processing dependencies is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema with the `dependencies` resolved into it\r\n */\r\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  dependencies: S['dependencies'],\r\n  resolvedSchema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  let schemas = [resolvedSchema];\r\n  // Process dependencies updating the local schema properties as appropriate.\r\n  for (const dependencyKey in dependencies) {\r\n    // Skip this dependency if its trigger property is not present.\r\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\r\n      continue;\r\n    }\r\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\r\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\r\n      continue;\r\n    }\r\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\r\n      dependencyKey,\r\n      dependencies as GenericObjectType\r\n    );\r\n    if (Array.isArray(dependencyValue)) {\r\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\r\n    } else if (isObject(dependencyValue)) {\r\n      schemas = withDependentSchema<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        dependencyValue as S,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      );\r\n    }\r\n    return schemas.flatMap((schema) =>\r\n      processDependencies<T, S, F>(\r\n        validator,\r\n        remainingDependencies,\r\n        schema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  }\r\n  return schemas;\r\n}\r\n\r\n/** Updates a schema with additionally required properties added\r\n *\r\n * @param schema - The schema for which resolving a dependent properties is desired\r\n * @param [additionallyRequired] - An optional array of additionally required names\r\n * @returns - The schema with the additional required values merged in\r\n */\r\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionallyRequired?: string[]\r\n) {\r\n  if (!additionallyRequired) {\r\n    return schema;\r\n  }\r\n  const required = Array.isArray(schema.required)\r\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\r\n    : additionallyRequired;\r\n  return { ...schema, required: required };\r\n}\r\n\r\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependent schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the dependency\r\n * @param dependencyValue - The potentially dependent schema\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData]- The current formData to assist retrieving a schema\r\n * @returns - The list of schemas with the dependent schema resolved into them\r\n */\r\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  dependencyValue: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\r\n    validator,\r\n    dependencyValue,\r\n    rootSchema,\r\n    formData,\r\n    expandAllBranches,\r\n    recurseList\r\n  );\r\n  return dependentSchemas.flatMap((dependent) => {\r\n    const { oneOf, ...dependentSchema } = dependent;\r\n    schema = mergeSchemas(schema, dependentSchema) as S;\r\n    // Since it does not contain oneOf, we return the original schema.\r\n    if (oneOf === undefined) {\r\n      return schema;\r\n    }\r\n    // Resolve $refs inside oneOf.\r\n    const resolvedOneOfs = oneOf.map((subschema) => {\r\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\r\n        return [subschema as S];\r\n      }\r\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\r\n    });\r\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\r\n    return allPermutations.flatMap((resolvedOneOf) =>\r\n      withExactlyOneSubschema<T, S, F>(\r\n        validator,\r\n        schema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        resolvedOneOf,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\r\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\r\n * the `retrieveSchemaInternal()` helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\r\n * @param schema - The schema for which resolving a oneOf subschema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the oneOf dependency\r\n * @param oneOf - The list of schemas representing the oneOf options\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function withExactlyOneSubschema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  oneOf: S['oneOf'],\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const validSubschemas = oneOf!.filter((subschema) => {\r\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\r\n      return false;\r\n    }\r\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\r\n    if (conditionPropertySchema) {\r\n      const conditionSchema: S = {\r\n        type: 'object',\r\n        properties: {\r\n          [dependencyKey]: conditionPropertySchema,\r\n        },\r\n      } as S;\r\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\r\n    }\r\n    return false;\r\n  });\r\n\r\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\r\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\r\n    return [schema];\r\n  }\r\n  return validSubschemas.flatMap((s) => {\r\n    const subschema: S = s as S;\r\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\r\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\r\n    const schemas = retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      dependentSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\r\n  });\r\n}\r\n","import get from 'lodash-es/get';\r\nimport has from 'lodash-es/has';\r\nimport isNumber from 'lodash-es/isNumber';\r\nimport isObject from 'lodash-es/isObject';\r\nimport isString from 'lodash-es/isString';\r\nimport reduce from 'lodash-es/reduce';\r\nimport times from 'lodash-es/times';\r\n\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\r\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\r\nimport guessType from '../guessType';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\r\n * the first item\r\n */\r\nexport const JUNK_OPTION: StrictRJSFSchema = {\r\n  type: 'object',\r\n  $id: JUNK_OPTION_ID,\r\n  properties: {\r\n    __not_really_there__: {\r\n      type: 'number',\r\n    },\r\n  },\r\n};\r\n\r\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\r\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\r\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\r\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\r\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\r\n *   the total.\r\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\r\n *   `getClosestMatchingOption()` of that oneOf.\r\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\r\n *   `value` itself as the sub-schema, and the score is added to the total.\r\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\r\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\r\n *   is incremented by another 1 otherwise it is decremented by 1.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param schema - The schema for which the score is being calculated\r\n * @param formData - The form data associated with the schema, used to calculate the score\r\n * @returns - The score a schema against the formData\r\n */\r\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  schema?: S,\r\n  formData: any = {}\r\n): number {\r\n  let totalScore = 0;\r\n  if (schema) {\r\n    if (isObject(schema.properties)) {\r\n      totalScore += reduce(\r\n        schema.properties,\r\n        (score, value, key) => {\r\n          const formValue = get(formData, key);\r\n          if (typeof value === 'boolean') {\r\n            return score;\r\n          }\r\n          if (has(value, REF_KEY)) {\r\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\r\n          }\r\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\r\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\r\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\r\n            return (\r\n              score +\r\n              getClosestMatchingOption<T, S, F>(\r\n                validator,\r\n                rootSchema,\r\n                formValue,\r\n                get(value, key) as S[],\r\n                -1,\r\n                discriminator\r\n              )\r\n            );\r\n          }\r\n          if (value.type === 'object') {\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\r\n          }\r\n          if (value.type === guessType(formValue)) {\r\n            // If the types match, then we bump the score by one\r\n            let newScore = score + 1;\r\n            if (value.default) {\r\n              // If the schema contains a readonly default value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.default ? 1 : -1;\r\n            } else if (value.const) {\r\n              // If the schema contains a const value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.const ? 1 : -1;\r\n            }\r\n            // TODO eventually, deal with enums/arrays\r\n            return newScore;\r\n          }\r\n          return score;\r\n        },\r\n        0\r\n      );\r\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\r\n      totalScore += 1;\r\n    }\r\n  }\r\n  return totalScore;\r\n}\r\n\r\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\r\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\r\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\r\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\r\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\r\n * matched.\r\n *\r\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\r\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\r\n * option with the highest score is determined by iterating over the list of valid options, calling\r\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\r\n * eventually has the best score.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param formData - The form data associated with the schema\r\n * @param options - The list of options that can be selected from\r\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n */\r\nexport default function getClosestMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  selectedOption = -1,\r\n  discriminatorField?: string\r\n): number {\r\n  // First resolve any refs in the options\r\n  const resolvedOptions = options.map((option) => {\r\n    return resolveAllReferences<S>(option, rootSchema, []);\r\n  });\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  // Reduce the array of options down to a list of the indexes that are considered matching options\r\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\r\n    const testOptions: S[] = [JUNK_OPTION as S, option];\r\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\r\n    // The match is the real option, so add its index to list of valid indexes\r\n    if (match === 1) {\r\n      validList.push(index);\r\n    }\r\n    return validList;\r\n  }, []);\r\n\r\n  // There is only one valid index, so return it!\r\n  if (allValidIndexes.length === 1) {\r\n    return allValidIndexes[0];\r\n  }\r\n  if (!allValidIndexes.length) {\r\n    // No indexes were valid, so we'll score all the options, add all the indexes\r\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\r\n  }\r\n  type BestType = { bestIndex: number; bestScore: number };\r\n  const scoreCount = new Set<number>();\r\n  // Score all the options in the list of valid indexes and return the index with the best score\r\n  const { bestIndex }: BestType = allValidIndexes.reduce(\r\n    (scoreData: BestType, index: number) => {\r\n      const { bestScore } = scoreData;\r\n      const option = resolvedOptions[index];\r\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\r\n      scoreCount.add(score);\r\n      if (score > bestScore) {\r\n        return { bestIndex: index, bestScore: score };\r\n      }\r\n      return scoreData;\r\n    },\r\n    { bestIndex: selectedOption, bestScore: 0 }\r\n  );\r\n  // if all scores are the same go with selectedOption\r\n  if (scoreCount.size === 1 && selectedOption >= 0) {\r\n    return selectedOption;\r\n  }\r\n\r\n  return bestIndex;\r\n}\r\n","import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\r\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\r\n}\r\n","import get from 'lodash-es/get';\r\n\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from '..';\r\n\r\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\r\n *     which case the extras are appended onto the end of the form data\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\r\n * @returns - The resulting merged form data with defaults\r\n */\r\nexport default function mergeDefaultsWithFormData<T = any>(\r\n  defaults?: T,\r\n  formData?: T,\r\n  mergeExtraArrayDefaults = false\r\n): T | undefined {\r\n  if (Array.isArray(formData)) {\r\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\r\n    const mapped = formData.map((value, idx) => {\r\n      if (defaultsArray[idx]) {\r\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\r\n      }\r\n      return value;\r\n    });\r\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\r\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\r\n      mapped.push(...defaultsArray.slice(mapped.length));\r\n    }\r\n    return mapped as unknown as T;\r\n  }\r\n  if (isObject(formData)) {\r\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\r\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\r\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\r\n        defaults ? get(defaults, key) : {},\r\n        get(formData, key),\r\n        mergeExtraArrayDefaults\r\n      );\r\n      return acc;\r\n    }, acc);\r\n  }\r\n  return formData;\r\n}\r\n","import isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\r\nexport default function mergeObjects(\r\n  obj1: GenericObjectType,\r\n  obj2: GenericObjectType,\r\n  concatArrays: boolean | 'preventDuplicates' = false\r\n) {\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeObjects(left, right, concatArrays);\r\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\r\n      let toMerge = right;\r\n      if (concatArrays === 'preventDuplicates') {\r\n        toMerge = right.reduce((result, value) => {\r\n          if (!left.includes(value)) {\r\n            result.push(value);\r\n          }\r\n          return result;\r\n        }, []);\r\n      }\r\n      acc[key] = left.concat(toMerge);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\r\n}\r\n","import isConstant from '../isConstant';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\r\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  rootSchema: S = {} as S\r\n) {\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  if (Array.isArray(schema.enum)) {\r\n    return true;\r\n  }\r\n  if (Array.isArray(altSchemas)) {\r\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\r\n  }\r\n  return false;\r\n}\r\n","import { CONST_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\r\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\nimport isSelect from './isSelect';\r\n\r\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\r\nexport default function isMultiSelect<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\r\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\r\n    return false;\r\n  }\r\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\r\n}\r\n","import get from 'lodash-es/get';\r\nimport isEmpty from 'lodash-es/isEmpty';\r\n\r\nimport {\r\n  ANY_OF_KEY,\r\n  DEFAULT_KEY,\r\n  DEPENDENCIES_KEY,\r\n  PROPERTIES_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  ALL_OF_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition from '../findSchemaDefinition';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getSchemaType from '../getSchemaType';\r\nimport isObject from '../isObject';\r\nimport isFixedItems from '../isFixedItems';\r\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\r\nimport mergeObjects from '../mergeObjects';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport {\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GenericObjectType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isMultiSelect from './isMultiSelect';\r\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\r\n\r\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\r\n */\r\nexport enum AdditionalItemsHandling {\r\n  Ignore,\r\n  Invert,\r\n  Fallback,\r\n}\r\n\r\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\r\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\r\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\r\n *    index and not a boolean, otherwise it falls through to 3.\r\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\r\n *    is a schema, otherwise it falls through to 3.\r\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\r\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\r\n * 4. {} is returned representing an empty schema\r\n *\r\n * @param schema - The schema from which to get the particular item\r\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\r\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\r\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\r\n */\r\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\r\n  idx = -1\r\n): S {\r\n  if (idx >= 0) {\r\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\r\n      const item = schema.items[idx];\r\n      if (typeof item !== 'boolean') {\r\n        return item as S;\r\n      }\r\n    }\r\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n    return schema.items as S;\r\n  }\r\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\r\n    return schema.additionalItems as S;\r\n  }\r\n  return {} as S;\r\n}\r\n\r\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\r\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\r\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\r\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\r\n * values will be added based on certain conditions.\r\n *\r\n * @param obj - The object into which the computed default may be added\r\n * @param key - The key into the object at which the computed default may be added\r\n * @param computedDefault - The computed default value that maybe should be added to the obj\r\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\r\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\r\n * @param requiredFields - The list of fields that are required\r\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\r\n *        default form state behavior\r\n */\r\nfunction maybeAddDefaultToObject<T = any>(\r\n  obj: GenericObjectType,\r\n  key: string,\r\n  computedDefault: T | T[] | undefined,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\r\n  isParentRequired?: boolean,\r\n  requiredFields: string[] = [],\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\r\n) {\r\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\r\n  if (includeUndefinedValues) {\r\n    obj[key] = computedDefault;\r\n  } else if (emptyObjectFields !== 'skipDefaults') {\r\n    if (isObject(computedDefault)) {\r\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\r\n      // the field key itself in the `requiredField` list\r\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\r\n\r\n      // If emptyObjectFields 'skipEmptyDefaults' store computedDefault if it's a non-empty object(e.g. not {})\r\n      if (emptyObjectFields === 'skipEmptyDefaults') {\r\n        if (!isEmpty(computedDefault)) {\r\n          obj[key] = computedDefault;\r\n        }\r\n      }\r\n      // Else store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\r\n      // Condition 1: If computedDefault is not empty or if the key is a required field\r\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\r\n      else if (\r\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\r\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\r\n      ) {\r\n        obj[key] = computedDefault;\r\n      }\r\n    } else if (\r\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\r\n      // Condition 1: computedDefault is not undefined\r\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults) or if the key is a required field\r\n      computedDefault !== undefined &&\r\n      (emptyObjectFields === 'populateAllDefaults' ||\r\n        emptyObjectFields === 'skipEmptyDefaults' ||\r\n        requiredFields.includes(key))\r\n    ) {\r\n      obj[key] = computedDefault;\r\n    }\r\n  }\r\n}\r\n\r\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\r\n  parentDefaults?: T;\r\n  rootSchema?: S;\r\n  rawFormData?: T;\r\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\r\n  _recurseList?: string[];\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\r\n  required?: boolean;\r\n}\r\n\r\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\r\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rawSchema - The schema for which the default state is desired\r\n * @param [props] - Optional props for this function\r\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\r\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\r\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\r\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rawSchema: S,\r\n  {\r\n    parentDefaults,\r\n    rawFormData,\r\n    rootSchema = {} as S,\r\n    includeUndefinedValues = false,\r\n    _recurseList = [],\r\n    experimental_defaultFormStateBehavior = undefined,\r\n    required,\r\n  }: ComputeDefaultsProps<T, S> = {}\r\n): T | T[] | undefined {\r\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\r\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\r\n  // Compute the defaults recursively: give highest priority to deepest nodes.\r\n  let defaults: T | T[] | undefined = parentDefaults;\r\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\r\n  let schemaToCompute: S | null = null;\r\n  let updatedRecurseList = _recurseList;\r\n\r\n  if (isObject(defaults) && isObject(schema.default)) {\r\n    // For object defaults, only override parent defaults that are defined in\r\n    // schema.default.\r\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\r\n  } else if (DEFAULT_KEY in schema) {\r\n    defaults = schema.default as unknown as T;\r\n  } else if (REF_KEY in schema) {\r\n    const refName = schema[REF_KEY];\r\n    // Use referenced schema defaults for this node.\r\n    if (!_recurseList.includes(refName!)) {\r\n      updatedRecurseList = _recurseList.concat(refName!);\r\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\r\n    }\r\n  } else if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\r\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\r\n  } else if (isFixedItems(schema)) {\r\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\r\n      computeDefaults<T, S>(validator, itemSchema, {\r\n        rootSchema,\r\n        includeUndefinedValues,\r\n        _recurseList,\r\n        experimental_defaultFormStateBehavior,\r\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\r\n        rawFormData: formData as T,\r\n        required,\r\n      })\r\n    ) as T[];\r\n  } else if (ONE_OF_KEY in schema) {\r\n    const { oneOf, ...remaining } = schema;\r\n    if (oneOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = oneOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        oneOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  } else if (ANY_OF_KEY in schema) {\r\n    const { anyOf, ...remaining } = schema;\r\n    if (anyOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = anyOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        anyOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  }\r\n\r\n  if (schemaToCompute) {\r\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\r\n      rootSchema,\r\n      includeUndefinedValues,\r\n      _recurseList: updatedRecurseList,\r\n      experimental_defaultFormStateBehavior,\r\n      parentDefaults: defaults as T | undefined,\r\n      rawFormData: formData as T,\r\n      required,\r\n    });\r\n  }\r\n\r\n  // No defaults defined for this node, fallback to generic typed ones.\r\n  if (defaults === undefined) {\r\n    defaults = schema.default as unknown as T;\r\n  }\r\n\r\n  switch (getSchemaType<S>(schema)) {\r\n    // We need to recurse for object schema inner default values.\r\n    case 'object': {\r\n      // This is a custom addition that fixes this issue:\r\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\r\n      const retrievedSchema: S =\r\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\r\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\r\n          : schema;\r\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\r\n        (acc: GenericObjectType, key: string) => {\r\n          // Compute the defaults for this node, with the parent defaults we might\r\n          // have from a previous run: defaults[key].\r\n          const field = get(retrievedSchema, [PROPERTIES_KEY, key]);\r\n          const computedDefault = computeDefaults<T, S, F>(validator, \r\n            (isObject(field) ? field : {}) as S, \r\n            {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          maybeAddDefaultToObject<T>(\r\n            acc,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            retrievedSchema.required,\r\n            experimental_defaultFormStateBehavior\r\n          );\r\n          return acc;\r\n        },\r\n        {}\r\n      ) as T;\r\n      if (retrievedSchema.additionalProperties) {\r\n        // as per spec additionalProperties may be either schema or boolean\r\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\r\n          ? retrievedSchema.additionalProperties\r\n          : {};\r\n\r\n        const keys = new Set<string>();\r\n        if (isObject(defaults)) {\r\n          Object.keys(defaults as GenericObjectType)\r\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n            .forEach((key) => keys.add(key));\r\n        }\r\n        const formDataRequired: string[] = [];\r\n        Object.keys(formData as GenericObjectType)\r\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n          .forEach((key) => {\r\n            keys.add(key);\r\n            formDataRequired.push(key);\r\n          });\r\n        keys.forEach((key) => {\r\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\r\n          maybeAddDefaultToObject<T>(\r\n            objectDefaults as GenericObjectType,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            formDataRequired\r\n          );\r\n        });\r\n      }\r\n      return objectDefaults;\r\n    }\r\n    case 'array': {\r\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\r\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\r\n      const isSkipEmptyDefaults = experimental_defaultFormStateBehavior?.emptyObjectFields === 'skipEmptyDefaults';\r\n      const computeSkipPopulate =\r\n        experimental_defaultFormStateBehavior?.arrayMinItems?.computeSkipPopulate ?? (() => false);\r\n\r\n      const emptyDefault = isSkipEmptyDefaults ? undefined : [];\r\n\r\n      // Inject defaults into existing array defaults\r\n      if (Array.isArray(defaults)) {\r\n        defaults = defaults.map((item, idx) => {\r\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\r\n          return computeDefaults<T, S, F>(validator, schemaItem, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            parentDefaults: item,\r\n            required,\r\n          });\r\n        }) as T[];\r\n      }\r\n\r\n      // Deeply inject defaults into already existing form data\r\n      if (Array.isArray(rawFormData)) {\r\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\r\n        if (neverPopulate) {\r\n          defaults = rawFormData;\r\n        } else {\r\n          defaults = rawFormData.map((item: T, idx: number) => {\r\n            return computeDefaults<T, S, F>(validator, schemaItem, {\r\n              rootSchema,\r\n              _recurseList,\r\n              experimental_defaultFormStateBehavior,\r\n              rawFormData: item,\r\n              parentDefaults: get(defaults, [idx]),\r\n              required,\r\n            });\r\n          }) as T[];\r\n        }\r\n      }\r\n\r\n      if (neverPopulate) {\r\n        return defaults ?? emptyDefault;\r\n      }\r\n      if (ignoreMinItemsFlagSet && !required) {\r\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\r\n        // return form data/defaults\r\n        return defaults ? defaults : undefined;\r\n      }\r\n\r\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\r\n      if (\r\n        !schema.minItems ||\r\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n        computeSkipPopulate<T, S, F>(validator, schema, rootSchema) ||\r\n        schema.minItems <= defaultsLength\r\n      ) {\r\n        return defaults ? defaults : emptyDefault;\r\n      }\r\n\r\n      const defaultEntries: T[] = (defaults || []) as T[];\r\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\r\n      const fillerDefault = fillerSchema.default;\r\n\r\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\r\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\r\n        computeDefaults<any, S, F>(validator, fillerSchema, {\r\n          parentDefaults: fillerDefault,\r\n          rootSchema,\r\n          _recurseList,\r\n          experimental_defaultFormStateBehavior,\r\n          required,\r\n        })\r\n      ) as T[];\r\n      // then fill up the rest with either the item default or empty, up to minItems\r\n      return defaultEntries.concat(fillerEntries);\r\n    }\r\n  }\r\n\r\n  return defaults;\r\n}\r\n\r\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n * computed to have defaults provided in the `schema`.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the default state is desired\r\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport default function getDefaultFormState<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  formData?: T,\r\n  rootSchema?: S,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\r\n) {\r\n  if (!isObject(theSchema)) {\r\n    throw new Error('Invalid schema: ' + theSchema);\r\n  }\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\r\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\r\n    rootSchema,\r\n    includeUndefinedValues,\r\n    experimental_defaultFormStateBehavior,\r\n    rawFormData: formData,\r\n  });\r\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\r\n    // No form data? Use schema defaults.\r\n    return defaults;\r\n  }\r\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\r\n  if (isObject(formData)) {\r\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\r\n  }\r\n  if (Array.isArray(formData)) {\r\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\r\n  }\r\n  return formData;\r\n}\r\n","import getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\n\r\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\r\nexport default function isCustomWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}) {\r\n  return (\r\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\r\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\r\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\r\n  );\r\n}\r\n","import { UI_WIDGET_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\r\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S\r\n) {\r\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\r\n    return true;\r\n  }\r\n  if (schema.items) {\r\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\r\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\r\n  }\r\n  return false;\r\n}\r\n","import get from 'lodash-es/get';\r\nimport has from 'lodash-es/has';\r\n\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\nconst NO_VALUE = Symbol('no Value');\r\n\r\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\r\nexport default function sanitizeDataForNewSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\r\n  // By default, we will clear the form data\r\n  let newFormData;\r\n  // If the new schema is of type object and that object contains a list of properties\r\n  if (has(newSchema, PROPERTIES_KEY)) {\r\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\r\n    const removeOldSchemaData: GenericObjectType = {};\r\n    if (has(oldSchema, PROPERTIES_KEY)) {\r\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\r\n      Object.keys(properties).forEach((key) => {\r\n        if (has(data, key)) {\r\n          removeOldSchemaData[key] = undefined;\r\n        }\r\n      });\r\n    }\r\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\r\n    // Create a place to store nested data that will be a side-effect of the filter\r\n    const nestedData: GenericObjectType = {};\r\n    keys.forEach((key) => {\r\n      const formValue = get(data, key);\r\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {}) as S;\r\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {}) as S;\r\n      // Resolve the refs if they exist\r\n      if (has(oldKeyedSchema, REF_KEY)) {\r\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\r\n      }\r\n      if (has(newKeyedSchema, REF_KEY)) {\r\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\r\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\r\n        if (has(removeOldSchemaData, key)) {\r\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\r\n          delete removeOldSchemaData[key];\r\n        }\r\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\r\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\r\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\r\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\r\n            validator,\r\n            rootSchema,\r\n            newKeyedSchema,\r\n            oldKeyedSchema,\r\n            formValue\r\n          );\r\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\r\n            // only put undefined values for the array type and not the object type\r\n            nestedData[key] = itemData;\r\n          }\r\n        } else {\r\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\r\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\r\n          // value to be properly selected\r\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\r\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\r\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\r\n            if (oldOptionDefault === formValue) {\r\n              // If the old default matches the formValue, we'll update the new value to match the new default\r\n              removeOldSchemaData[key] = newOptionDefault;\r\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\r\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\r\n              removeOldSchemaData[key] = undefined;\r\n            }\r\n          }\r\n\r\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\r\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\r\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\r\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\r\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    newFormData = {\r\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\r\n      ...removeOldSchemaData,\r\n      ...nestedData,\r\n    };\r\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\r\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\r\n    let oldSchemaItems = get(oldSchema, 'items');\r\n    let newSchemaItems = get(newSchema, 'items');\r\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\r\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\r\n    if (\r\n      typeof oldSchemaItems === 'object' &&\r\n      typeof newSchemaItems === 'object' &&\r\n      !Array.isArray(oldSchemaItems) &&\r\n      !Array.isArray(newSchemaItems)\r\n    ) {\r\n      if (has(oldSchemaItems, REF_KEY)) {\r\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      if (has(newSchemaItems, REF_KEY)) {\r\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaType = get(oldSchemaItems, 'type');\r\n      const newSchemaType = get(newSchemaItems, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\r\n        const maxItems = get(newSchema, 'maxItems', -1);\r\n        if (newSchemaType === 'object') {\r\n          newFormData = data.reduce((newValue, aValue) => {\r\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\r\n              validator,\r\n              rootSchema,\r\n              newSchemaItems as S,\r\n              oldSchemaItems as S,\r\n              aValue\r\n            );\r\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\r\n              newValue.push(itemValue);\r\n            }\r\n            return newValue;\r\n          }, []);\r\n        } else {\r\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\r\n        }\r\n      }\r\n    } else if (\r\n      typeof oldSchemaItems === 'boolean' &&\r\n      typeof newSchemaItems === 'boolean' &&\r\n      oldSchemaItems === newSchemaItems\r\n    ) {\r\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\r\n      newFormData = data;\r\n    }\r\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\r\n  }\r\n  return newFormData as T;\r\n}\r\n","import get from 'lodash-es/get';\r\nimport isEqual from 'lodash-es/isEqual';\r\n\r\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport isObject from '../isObject';\r\nimport { FormContextType, GenericObjectType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport getSchemaType from '../getSchemaType';\r\n\r\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param idPrefix - The prefix to use for the id\r\n * @param idSeparator - The separator to use for the path segments in the id\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  idPrefix: string,\r\n  idSeparator: string,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): IdSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        idPrefix,\r\n        idSeparator,\r\n        id,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\r\n    return toIdSchemaInternal<T, S, F>(\r\n      validator,\r\n      get(schema, ITEMS_KEY) as S,\r\n      idPrefix,\r\n      idSeparator,\r\n      id,\r\n      rootSchema,\r\n      formData,\r\n      _recurseList\r\n    );\r\n  }\r\n  const $id = id || idPrefix;\r\n  const idSchema: IdSchema<T> = { $id } as IdSchema<T>;\r\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\r\n    for (const name in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, name]);\r\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\r\n      (idSchema as IdSchema<GenericObjectType>)[name] = toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        (isObject(field) ? field : {}) as S,\r\n        idPrefix,\r\n        idSeparator,\r\n        fieldId,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [name]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return idSchema;\r\n}\r\n\r\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  idPrefix = 'root',\r\n  idSeparator = '_'\r\n): IdSchema<T> {\r\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\r\n}\r\n","import get from 'lodash-es/get';\r\nimport isEqual from 'lodash-es/isEqual';\r\nimport set from 'lodash-es/set';\r\n\r\nimport {\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  DEPENDENCIES_KEY,\r\n  ITEMS_KEY,\r\n  NAME_KEY,\r\n  ONE_OF_KEY,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  RJSF_ADDITIONAL_PROPERTIES_FLAG,\r\n} from '../constants';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport { FormContextType, GenericObjectType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport isObject from '../isObject';\r\n\r\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name: string,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): PathSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        name,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n\r\n  let pathSchema: PathSchema<T> = {\r\n    [NAME_KEY]: name.replace(/^\\./, ''),\r\n  } as PathSchema<T>;\r\n\r\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\r\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\r\n    const _schema: S = xxxOf![index] as S;\r\n    pathSchema = {\r\n      ...pathSchema,\r\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\r\n    };\r\n  }\r\n\r\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\r\n    set(pathSchema, RJSF_ADDITIONAL_PROPERTIES_FLAG, true);\r\n  }\r\n\r\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\r\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\r\n\r\n    if (Array.isArray(schemaItems)) {\r\n      formData.forEach((element, i: number) => {\r\n        if (schemaItems[i]) {\r\n          (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaItems[i] as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else if (schemaAdditionalItems) {\r\n          (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaAdditionalItems as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else {\r\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\r\n        }\r\n      });\r\n    } else {\r\n      formData.forEach((element, i: number) => {\r\n        (pathSchema as PathSchema<T[]>)[i] = toPathSchemaInternal<T, S, F>(\r\n          validator,\r\n          schemaItems as S,\r\n          `${name}.${i}`,\r\n          rootSchema,\r\n          element,\r\n          _recurseList\r\n        );\r\n      });\r\n    }\r\n  } else if (PROPERTIES_KEY in schema) {\r\n    for (const property in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, property]);\r\n      (pathSchema as PathSchema<GenericObjectType>)[property] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        (isObject(field) ? field : {}) as S,\r\n        `${name}.${property}`,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [property]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return pathSchema;\r\n}\r\n\r\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name = '',\r\n  rootSchema?: S,\r\n  formData?: T\r\n): PathSchema<T> {\r\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\r\n}\r\n","import deepEquals from './deepEquals';\r\nimport {\r\n  ErrorSchema,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  IdSchema,\r\n  PathSchema,\r\n  RJSFSchema,\r\n  SchemaUtilsType,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from './types';\r\nimport {\r\n  getDefaultFormState,\r\n  getDisplayLabel,\r\n  getClosestMatchingOption,\r\n  getFirstMatchingOption,\r\n  getMatchingOption,\r\n  isFilesArray,\r\n  isMultiSelect,\r\n  isSelect,\r\n  mergeValidationData,\r\n  retrieveSchema,\r\n  sanitizeDataForNewSchema,\r\n  toIdSchema,\r\n  toPathSchema,\r\n} from './schema';\r\n\r\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\r\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@react-jsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\r\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements SchemaUtilsType<T, S, F>\r\n{\r\n  rootSchema: S;\r\n  validator: ValidatorType<T, S, F>;\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\r\n\r\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\r\n   */\r\n  constructor(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\r\n  ) {\r\n    this.rootSchema = rootSchema;\r\n    this.validator = validator;\r\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\r\n  }\r\n\r\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\r\n  getValidator() {\r\n    return this.validator;\r\n  }\r\n\r\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\r\n  doesSchemaUtilsDiffer(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior = {}\r\n  ): boolean {\r\n    if (!validator || !rootSchema) {\r\n      return false;\r\n    }\r\n    return (\r\n      this.validator !== validator ||\r\n      !deepEquals(this.rootSchema, rootSchema) ||\r\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\r\n    );\r\n  }\r\n\r\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\r\n  getDefaultFormState(\r\n    schema: S,\r\n    formData?: T,\r\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\r\n  ): T | T[] | undefined {\r\n    return getDefaultFormState<T, S, F>(\r\n      this.validator,\r\n      schema,\r\n      formData,\r\n      this.rootSchema,\r\n      includeUndefinedValues,\r\n      this.experimental_defaultFormStateBehavior\r\n    );\r\n  }\r\n\r\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\r\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\r\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\r\n  }\r\n\r\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\r\n  getClosestMatchingOption(\r\n    formData: T | undefined,\r\n    options: S[],\r\n    selectedOption?: number,\r\n    discriminatorField?: string\r\n  ): number {\r\n    return getClosestMatchingOption<T, S, F>(\r\n      this.validator,\r\n      this.rootSchema,\r\n      formData,\r\n      options,\r\n      selectedOption,\r\n      discriminatorField\r\n    );\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\r\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\r\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\r\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\r\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\r\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\r\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\r\n  isMultiSelect(schema: S) {\r\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\r\n  isSelect(schema: S) {\r\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   * @deprecated - Use the `validationDataMerge()` function exported from `@react-jsf/utils` instead. This function will be\r\n   *        removed in the next major release.\r\n   */\r\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\r\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\r\n  }\r\n\r\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\r\n  retrieveSchema(schema: S, rawFormData?: T) {\r\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\r\n  }\r\n\r\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\r\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\r\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\r\n  }\r\n\r\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\r\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\r\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\r\n  }\r\n\r\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\r\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\r\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\r\n  }\r\n}\r\n\r\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\r\nexport default function createSchemaUtils<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  experimental_defaultFormStateBehavior = {}\r\n): SchemaUtilsType<T, S, F> {\r\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\r\n}\r\n","import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\r\nimport getSchemaType from '../getSchemaType';\r\nimport getUiOptions from '../getUiOptions';\r\nimport isCustomWidget from '../isCustomWidget';\r\nimport {\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isFilesArray from './isFilesArray';\r\nimport isMultiSelect from './isMultiSelect';\r\n\r\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\r\nexport default function getDisplayLabel<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S,\r\n  globalOptions?: GlobalUISchemaOptions\r\n): boolean {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\r\n  const { label = true } = uiOptions;\r\n  let displayLabel = !!label;\r\n  const schemaType = getSchemaType<S>(schema);\r\n\r\n  if (schemaType === 'array') {\r\n    displayLabel =\r\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\r\n      isCustomWidget(uiSchema);\r\n  }\r\n\r\n  if (schemaType === 'object') {\r\n    displayLabel = false;\r\n  }\r\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  if (uiSchema[UI_FIELD_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  return displayLabel;\r\n}\r\n","import isEmpty from 'lodash-es/isEmpty';\r\n\r\nimport mergeObjects from '../mergeObjects';\r\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n * @deprecated - Use the `validationDataMerge()` function exported from `@react-jsf/utils` instead. This function will be\r\n *        removed in the next major release.\r\n */\r\nexport default function mergeValidationData<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = validator.toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n","/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\r\nexport default function pad(num: number, width: number) {\r\n  let s = String(num);\r\n  while (s.length < width) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n}\r\n","import pad from './pad';\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns a list of options for a date range between `start` and `stop`. If the start date is greater than the end\r\n * date, then the date range is reversed. If `start` and `stop` are negative numbers (or zero), then they will be\r\n * treated as relative to the current year.\r\n *\r\n * @param start - The starting point of the date range\r\n * @param stop - The ending point of the date range\r\n * @returns - The list of EnumOptionsType for the date range between `start` and `stop`\r\n * @throws - Error when `start` and `stop` aren't both <= 0 or > 0\r\n */\r\nexport default function dateRangeOptions<S extends StrictRJSFSchema = RJSFSchema>(\r\n  start: number,\r\n  stop: number\r\n): EnumOptionsType<S>[] {\r\n  if (start <= 0 && stop <= 0) {\r\n    start = new Date().getFullYear() + start;\r\n    stop = new Date().getFullYear() + stop;\r\n  } else if (start < 0 || stop < 0) {\r\n    throw new Error(`Both start (${start}) and stop (${stop}) must both be <= 0 or > 0, got one of each`);\r\n  }\r\n  if (start > stop) {\r\n    return dateRangeOptions<S>(stop, start).reverse();\r\n  }\r\n  const options: EnumOptionsType<S>[] = [];\r\n  for (let i = start; i <= stop; i++) {\r\n    options.push({ value: i, label: pad(i, 2) });\r\n  }\r\n  return options;\r\n}\r\n","import { TranslatableString } from './enums';\r\nimport replaceStringParameters from './replaceStringParameters';\r\n\r\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\r\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\r\n  return replaceStringParameters(stringToTranslate, params);\r\n}\r\n","/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\r\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\r\n  let output = inputString;\r\n  if (Array.isArray(params)) {\r\n    const parts = output.split(/(%\\d)/);\r\n    params.forEach((param, index) => {\r\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\r\n      if (partIndex >= 0) {\r\n        parts[partIndex] = param;\r\n      }\r\n    });\r\n    output = parts.join('');\r\n  }\r\n  return output;\r\n}\r\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\r\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number | Array<string | number>,\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  emptyValue?: EnumOptionsType<S>['value']\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  if (Array.isArray(valueIndex)) {\r\n    return (\r\n      valueIndex\r\n        .map((index) => enumOptionsValueForIndex(index, allEnumOptions))\r\n        // Since the recursive call returns `emptyValue` when we get a bad option, only filter those out\r\n        .filter((val) => val !== emptyValue)\r\n    );\r\n  }\r\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\r\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\r\n  const option = allEnumOptions[index];\r\n  return option ? option.value : emptyValue;\r\n}\r\n","import isEqual from 'lodash-es/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\n\r\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\r\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (Array.isArray(selected)) {\r\n    return selected.filter((v) => !isEqual(v, value));\r\n  }\r\n  return isEqual(value, selected) ? undefined : selected;\r\n}\r\n","import isEqual from 'lodash-es/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\r\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'],\r\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\r\n) {\r\n  if (Array.isArray(selected)) {\r\n    return selected.some((sel) => isEqual(sel, value));\r\n  }\r\n  return isEqual(selected, value);\r\n}\r\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\n\r\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\r\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  multiple = false\r\n): string | string[] | undefined {\r\n  const selectedIndexes: string[] = allEnumOptions\r\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\r\n    .filter((opt) => typeof opt !== 'undefined') as string[];\r\n  if (!multiple) {\r\n    return selectedIndexes[0];\r\n  }\r\n  return selectedIndexes;\r\n}\r\n","import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport isNil from 'lodash-es/isNil';\r\n\r\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\r\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected: EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n) {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (!isNil(value)) {\r\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\r\n    const all = allEnumOptions.map(({ value: val }) => val);\r\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\r\n    // As inserting values at predefined index positions doesn't work with empty\r\n    // arrays, we need to reorder the updated selection to match the initial order\r\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\r\n  }\r\n  return selected;\r\n}\r\n","import { type DateObject } from './types';\r\n\r\n/** Available options for re-ordering date input element */\r\nexport type DateElementFormat = 'DMY' | 'MDY' | 'YMD';\r\n\r\n/** Type describing format of DateElement prop */\r\ntype DateElementProp = {\r\n  type: string;\r\n  range: [number, number];\r\n  value: number | undefined;\r\n};\r\n\r\n/** Given date & time information with optional yearRange & format, returns props for DateElement\r\n *\r\n * @param date - Object containing date with optional time information\r\n * @param time - Determines whether to include time or not\r\n * @param [yearRange=[1900, new Date().getFullYear() + 2]] - Controls the list of years to be displayed\r\n * @param [format='YMD'] - Controls the order in which day, month and year input element will be displayed\r\n * @returns Array of props for DateElement\r\n */\r\n\r\nexport default function getDateElementProps(\r\n  date: DateObject,\r\n  time: boolean,\r\n  yearRange: [number, number] = [1900, new Date().getFullYear() + 2],\r\n  format: DateElementFormat = 'YMD'\r\n) {\r\n  const { day, month, year, hour, minute, second } = date;\r\n\r\n  const dayObj: DateElementProp = { type: 'day', range: [1, 31], value: day };\r\n  const monthObj: DateElementProp = { type: 'month', range: [1, 12], value: month };\r\n  const yearObj: DateElementProp = { type: 'year', range: yearRange, value: year };\r\n\r\n  const dateElementProp: DateElementProp[] = [];\r\n  switch (format) {\r\n    case 'MDY':\r\n      dateElementProp.push(monthObj, dayObj, yearObj);\r\n      break;\r\n    case 'DMY':\r\n      dateElementProp.push(dayObj, monthObj, yearObj);\r\n      break;\r\n    case 'YMD':\r\n    default:\r\n      dateElementProp.push(yearObj, monthObj, dayObj);\r\n  }\r\n\r\n  if (time) {\r\n    dateElementProp.push(\r\n      { type: 'hour', range: [0, 23], value: hour },\r\n      { type: 'minute', range: [0, 59], value: minute },\r\n      { type: 'second', range: [0, 59], value: second }\r\n    );\r\n  }\r\n\r\n  return dateElementProp;\r\n}\r\n","import { RangeSpecType, StrictRJSFSchema } from './types';\r\nimport { RJSFSchema } from './types';\r\n\r\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\r\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const spec: RangeSpecType = {};\r\n  if (schema.multipleOf) {\r\n    spec.step = schema.multipleOf;\r\n  }\r\n  if (schema.minimum || schema.minimum === 0) {\r\n    spec.min = schema.minimum;\r\n  }\r\n  if (schema.maximum || schema.maximum === 0) {\r\n    spec.max = schema.maximum;\r\n  }\r\n  return spec;\r\n}\r\n","import rangeSpec from './rangeSpec';\r\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\r\n\r\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\r\nexport default function getInputProps<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  schema: RJSFSchema,\r\n  defaultType?: string,\r\n  options: UIOptionsType<T, S, F> = {},\r\n  autoDefaultStepAny = true\r\n): InputPropsType {\r\n  const inputProps: InputPropsType = {\r\n    type: defaultType || 'text',\r\n    ...rangeSpec(schema),\r\n  };\r\n\r\n  // If options.inputType is set use that as the input type\r\n  if (options.inputType) {\r\n    inputProps.type = options.inputType;\r\n  } else if (!defaultType) {\r\n    // If the schema is of type number or integer, set the input type to number\r\n    if (schema.type === 'number') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\r\n      if (autoDefaultStepAny && inputProps.step === undefined) {\r\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\r\n        // allowed in number inputs\r\n        inputProps.step = 'any';\r\n      }\r\n    } else if (schema.type === 'integer') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined\r\n      if (inputProps.step === undefined) {\r\n        // Since this is integer, you always want to step up or down in multiples of 1\r\n        inputProps.step = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.autocomplete) {\r\n    inputProps.autoComplete = options.autocomplete;\r\n  }\r\n\r\n  return inputProps;\r\n}\r\n","import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\r\nimport getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\r\n\r\n/** The default submit button options, exported for testing purposes\r\n */\r\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\r\n  props: {\r\n    disabled: false,\r\n  },\r\n  submitText: 'Submit',\r\n  norender: false,\r\n};\r\n\r\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\r\nexport default function getSubmitButtonOptions<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\r\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\r\n    return { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  return DEFAULT_OPTIONS;\r\n}\r\n","import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\r\n\r\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\r\nexport default function getTemplate<\r\n  Name extends keyof TemplatesType<T, S, F>,\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\r\n  const { templates } = registry;\r\n  if (name === 'ButtonTemplates') {\r\n    return templates[name];\r\n  }\r\n  return (\r\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\r\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\r\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\r\n  );\r\n}\r\n","import { createElement } from 'react';\r\nimport ReactIs from 'react-is';\r\nimport get from 'lodash-es/get';\r\nimport set from 'lodash-es/set';\r\n\r\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\r\nimport getSchemaType from './getSchemaType';\r\n\r\n/** The map of schema types to widget type to widget name\r\n */\r\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\r\n  boolean: {\r\n    checkbox: 'CheckboxWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  string: {\r\n    text: 'TextWidget',\r\n    password: 'PasswordWidget',\r\n    email: 'EmailWidget',\r\n    hostname: 'TextWidget',\r\n    ipv4: 'TextWidget',\r\n    ipv6: 'TextWidget',\r\n    uri: 'URLWidget',\r\n    'data-url': 'FileWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    textarea: 'TextareaWidget',\r\n    hidden: 'HiddenWidget',\r\n    date: 'DateWidget',\r\n    datetime: 'DateTimeWidget',\r\n    'date-time': 'DateTimeWidget',\r\n    'alt-date': 'AltDateWidget',\r\n    'alt-datetime': 'AltDateTimeWidget',\r\n    time: 'TimeWidget',\r\n    color: 'ColorWidget',\r\n    file: 'FileWidget',\r\n  },\r\n  number: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  integer: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  array: {\r\n    select: 'SelectWidget',\r\n    checkboxes: 'CheckboxesWidget',\r\n    files: 'FileWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n};\r\n\r\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\r\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  AWidget: Widget<T, S, F>\r\n) {\r\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\r\n  // cache return value as property of widget for proper react reconciliation\r\n  if (!MergedWidget) {\r\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\r\n    MergedWidget = ({ options, ...props }) => {\r\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\r\n    };\r\n    set(AWidget, 'MergedWidget', MergedWidget);\r\n  }\r\n  return MergedWidget;\r\n}\r\n\r\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\r\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget?: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n): Widget<T, S, F> {\r\n  const type = getSchemaType(schema);\r\n\r\n  if (\r\n    typeof widget === 'function' ||\r\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\r\n    ReactIs.isMemo(widget)\r\n  ) {\r\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\r\n  }\r\n\r\n  if (typeof widget !== 'string') {\r\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\r\n  }\r\n\r\n  if (widget in registeredWidgets) {\r\n    const registeredWidget = registeredWidgets[widget];\r\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    if (!(type in widgetMap)) {\r\n      throw new Error(`No widget for type '${type}'`);\r\n    }\r\n\r\n    if (widget in widgetMap[type]) {\r\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\r\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n    }\r\n  }\r\n\r\n  throw new Error(`No widget '${widget}' for type '${type}'`);\r\n}\r\n","import isString from 'lodash-es/isString';\r\n\r\nimport { IdSchema } from './types';\r\nimport { ID_KEY } from './constants';\r\n\r\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\r\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\r\n  const theId = isString(id) ? id : id[ID_KEY];\r\n  return `${theId}__${suffix}`;\r\n}\r\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\r\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'description');\r\n}\r\n\r\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\r\nexport function errorId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'error');\r\n}\r\n\r\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\r\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'examples');\r\n}\r\n\r\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\r\nexport function helpId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'help');\r\n}\r\n\r\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\r\nexport function titleId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'title');\r\n}\r\n\r\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\r\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\r\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\r\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\r\n}\r\n\r\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\r\nexport function optionId(id: string, optionIndex: number) {\r\n  return `${id}-${optionIndex}`;\r\n}\r\n","import { ReactElement } from 'react';\r\n\r\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\r\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\r\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\r\n * themes require may `false` and others may require an empty string.\r\n *\r\n * @param [label] - The label string or component to render when not hidden\r\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\r\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\r\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\r\n */\r\n\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\r\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\r\nexport default function labelValue(\r\n  label?: ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false\r\n): undefined | false | ReactElement;\r\nexport default function labelValue(\r\n  label?: string | ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false | ''\r\n): undefined | false | string | ReactElement {\r\n  return hideLabel ? fallback : label;\r\n}\r\n","import toConstant from './toConstant';\r\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema, FormContextType, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Gets the list of options from the `schema`. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value. If a `uiSchema` is provided\r\n * and it has the `ui:enumNames` matched with `enum` or it has an associated `oneOf` or `anyOf` with a list of objects\r\n * containing `ui:title` then the UI schema values will replace the values from the schema.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @param [uiSchema] - The optional uiSchema from which to get alternate labels for the options\r\n * @returns - The list of options from the schema\r\n */\r\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema, T = any, F extends FormContextType = any>(\r\n  schema: S,\r\n  uiSchema?: UiSchema<T, S, F>\r\n): EnumOptionsType<S>[] | undefined {\r\n  // TODO flip generics to move T first in v6\r\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n  if (schema.enum) {\r\n    let enumNames: string[] | undefined;\r\n    if (uiSchema) {\r\n      const { enumNames: uiEnumNames } = getUiOptions<T, S, F>(uiSchema);\r\n      enumNames = uiEnumNames;\r\n    }\r\n    if (!enumNames && schemaWithEnumNames.enumNames) {\r\n      // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\r\n      // Cast the type to include enumNames so the feature still works.\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        console.warn(\r\n          'The \"enumNames\" property in the schema is deprecated and will be removed in a future major release. Use the \"ui:enumNames\" property in the uiSchema instead.'\r\n        );\r\n      }\r\n      enumNames = schemaWithEnumNames.enumNames;\r\n    }\r\n    return schema.enum.map((value, i) => {\r\n      const label = enumNames?.[i] || String(value);\r\n      return { label, value };\r\n    });\r\n  }\r\n  let altSchemas: S['anyOf'] | S['oneOf'] = undefined;\r\n  let altUiSchemas: UiSchema<T, S, F> | undefined = undefined;\r\n  if (schema.anyOf) {\r\n    altSchemas = schema.anyOf;\r\n    altUiSchemas = uiSchema?.anyOf;\r\n  } else if (schema.oneOf) {\r\n    altSchemas = schema.oneOf;\r\n    altUiSchemas = uiSchema?.oneOf;\r\n  }\r\n  return (\r\n    altSchemas &&\r\n    altSchemas.map((aSchemaDef, index) => {\r\n      const { title } = getUiOptions<T, S, F>(altUiSchemas?.[index]);\r\n      const aSchema = aSchemaDef as S;\r\n      const value = toConstant(aSchema);\r\n      const label = title || aSchema.title || String(value);\r\n      return {\r\n        schema: aSchema,\r\n        label,\r\n        value,\r\n      };\r\n    })\r\n  );\r\n}\r\n","import { CONST_KEY, ENUM_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\r\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\r\n    return schema.enum[0];\r\n  }\r\n  if (CONST_KEY in schema) {\r\n    return schema.const;\r\n  }\r\n  throw new Error('schema cannot be inferred as a constant');\r\n}\r\n","import { DateObject } from './types';\r\n\r\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\r\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\r\n  if (!dateString) {\r\n    return {\r\n      year: -1,\r\n      month: -1,\r\n      day: -1,\r\n      hour: includeTime ? -1 : 0,\r\n      minute: includeTime ? -1 : 0,\r\n      second: includeTime ? -1 : 0,\r\n    };\r\n  }\r\n  const date = new Date(dateString);\r\n  if (Number.isNaN(date.getTime())) {\r\n    throw new Error('Unable to parse date ' + dateString);\r\n  }\r\n  return {\r\n    year: date.getUTCFullYear(),\r\n    month: date.getUTCMonth() + 1, // oh you, javascript.\r\n    day: date.getUTCDate(),\r\n    hour: includeTime ? date.getUTCHours() : 0,\r\n    minute: includeTime ? date.getUTCMinutes() : 0,\r\n    second: includeTime ? date.getUTCSeconds() : 0,\r\n  };\r\n}\r\n","import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\r\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\r\n  // Check if const is a truthy value\r\n  if (schema.const) {\r\n    return true;\r\n  }\r\n\r\n  // Check if an enum has a single value of true\r\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\r\n    return true;\r\n  }\r\n\r\n  // If anyOf has a single value, evaluate the subschema\r\n  if (schema.anyOf && schema.anyOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\r\n  }\r\n\r\n  // If oneOf has a single value, evaluate the subschema\r\n  if (schema.oneOf && schema.oneOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\r\n  }\r\n\r\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\r\n  if (schema.allOf) {\r\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\r\n    return schema.allOf.some(schemaSome);\r\n  }\r\n\r\n  return false;\r\n}\r\n","import { DateObject } from './types';\r\n\r\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\r\nexport default function toDateString(dateObject: DateObject, time = true) {\r\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\r\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\r\n  const datetime = new Date(utcTime).toJSON();\r\n  return time ? datetime : datetime.slice(0, 10);\r\n}\r\n","import isPlainObject from 'lodash-es/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\r\n\r\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n *\r\n * @param errorSchema - The `ErrorSchema` instance to convert\r\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\r\n */\r\nexport default function toErrorList<T = any>(\r\n  errorSchema?: ErrorSchema<T>,\r\n  fieldPath: string[] = []\r\n): RJSFValidationError[] {\r\n  if (!errorSchema) {\r\n    return [];\r\n  }\r\n  let errorList: RJSFValidationError[] = [];\r\n  if (ERRORS_KEY in errorSchema) {\r\n    errorList = errorList.concat(\r\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\r\n        const property = `.${fieldPath.join('.')}`;\r\n        return {\r\n          property,\r\n          message,\r\n          stack: `${property} ${message}`,\r\n        };\r\n      })\r\n    );\r\n  }\r\n  return Object.keys(errorSchema).reduce((acc, key) => {\r\n    if (key !== ERRORS_KEY) {\r\n      const childSchema = (errorSchema as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\r\n      }\r\n    }\r\n    return acc;\r\n  }, errorList);\r\n}\r\n","import cloneDeep from 'lodash-es/cloneDeep';\r\nimport { get, set } from 'lodash-es';\r\n\r\nimport { ErrorSchema } from './types';\r\nimport { ERRORS_KEY } from './constants';\r\n\r\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\r\nexport default class ErrorSchemaBuilder<T = any> {\r\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\r\n  private errorSchema: ErrorSchema<T> = {};\r\n\r\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\r\n  constructor(initialSchema?: ErrorSchema<T>) {\r\n    this.resetAllErrors(initialSchema);\r\n  }\r\n\r\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\r\n  get ErrorSchema() {\r\n    return this.errorSchema;\r\n  }\r\n\r\n  /** \r\n   * Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\r\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\r\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\r\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema as any, pathOfError!) : this.errorSchema;\r\n    if (!errorBlock && pathOfError) {\r\n      errorBlock = {};\r\n      set(this.errorSchema, pathOfError, errorBlock);\r\n    }\r\n    return errorBlock;\r\n  }\r\n\r\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\r\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\r\n    return this;\r\n  }\r\n\r\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    let errorsList = get(errorBlock, ERRORS_KEY);\r\n    if (!Array.isArray(errorsList)) {\r\n      errorsList = [];\r\n      errorBlock[ERRORS_KEY] = errorsList;\r\n    }\r\n\r\n    if (Array.isArray(errorOrList)) {\r\n      errorsList.push(...errorOrList);\r\n    } else {\r\n      errorsList.push(errorOrList);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\r\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\r\n    set(errorBlock, ERRORS_KEY, listToAdd);\r\n    return this;\r\n  }\r\n\r\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  clearErrors(pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    set(errorBlock, ERRORS_KEY, []);\r\n    return this;\r\n  }\r\n}\r\n","import isPlainObject from 'lodash-es/isPlainObject';\r\n\r\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\r\n *\r\n * @param errorHandler - The `FormValidation` error handling structure\r\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\r\n */\r\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\r\n  return Object.keys(errorHandler).reduce((acc, key) => {\r\n    if (key === 'addError') {\r\n      return acc;\r\n    } else {\r\n      const childSchema = (errorHandler as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        return {\r\n          ...acc,\r\n          [key]: unwrapErrorHandler(childSchema),\r\n        };\r\n      }\r\n      return { ...acc, [key]: childSchema };\r\n    }\r\n  }, {} as ErrorSchema<T>);\r\n}\r\n","import pad from './pad';\r\n\r\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\r\nexport default function utcToLocal(jsonDate: string) {\r\n  if (!jsonDate) {\r\n    return '';\r\n  }\r\n\r\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\r\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\r\n  // > should be a _valid local date and time string_ (not GMT)\r\n\r\n  // Note - date constructor passed local ISO-8601 does not correctly\r\n  // change time to UTC in node pre-8\r\n  const date = new Date(jsonDate);\r\n\r\n  const yyyy = pad(date.getFullYear(), 4);\r\n  const MM = pad(date.getMonth() + 1, 2);\r\n  const dd = pad(date.getDate(), 2);\r\n  const hh = pad(date.getHours(), 2);\r\n  const mm = pad(date.getMinutes(), 2);\r\n  const ss = pad(date.getSeconds(), 2);\r\n  const SSS = pad(date.getMilliseconds(), 3);\r\n\r\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\r\n}\r\n","import isEmpty from 'lodash-es/isEmpty';\r\n\r\nimport mergeObjects from './mergeObjects';\r\nimport toErrorList from './toErrorList';\r\nimport { ErrorSchema, ValidationData } from './types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\r\nexport default function validationDataMerge<T = any>(\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n","import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\nimport isObject from 'lodash-es/isObject';\r\n\r\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\r\n  for (const key in node) {\r\n    const realObj: { [k: string]: any } = node;\r\n    const value = realObj[key];\r\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\r\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\r\n    } else {\r\n      realObj[key] = withIdRefPrefix<S>(value);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\r\n  for (let i = 0; i < node.length; i++) {\r\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\r\n * This is used in isValid to make references to the rootSchema\r\n *\r\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n * @returns - A copy of the `schemaNode` with updated `$ref`s\r\n */\r\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schemaNode: S | S[] | S[keyof S]\r\n): S | S[] | S[keyof S] {\r\n  if (Array.isArray(schemaNode)) {\r\n    return withIdRefPrefixArray<S>([...schemaNode]);\r\n  }\r\n  if (isObject(schemaNode)) {\r\n    return withIdRefPrefixObject<S>({ ...schemaNode });\r\n  }\r\n  return schemaNode;\r\n}\r\n","/** An enumeration of all the translatable strings used by `@react-jsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\r\nexport enum TranslatableString {\r\n  /** Fallback title of an array item, used by ArrayField */\r\n  ArrayItemTitle = 'Item',\r\n  /** Missing items reason, used by ArrayField */\r\n  MissingItems = 'Missing items definition',\r\n  /** Yes label, used by BooleanField */\r\n  YesLabel = 'Yes',\r\n  /** No label, used by BooleanField */\r\n  NoLabel = 'No',\r\n  /** Close label, used by ErrorList */\r\n  CloseLabel = 'Close',\r\n  /** Errors label, used by ErrorList */\r\n  ErrorsLabel = 'Errors',\r\n  /** New additionalProperties string default value, used by ObjectField */\r\n  NewStringDefault = 'New Value',\r\n  /** Add button title, used by AddButton */\r\n  AddButton = 'Add',\r\n  /** Add button title, used by AddButton */\r\n  AddItemButton = 'Add Item',\r\n  /** Copy button title, used by IconButton */\r\n  CopyButton = 'Copy',\r\n  /** Move down button title, used by IconButton */\r\n  MoveDownButton = 'Move down',\r\n  /** Move up button title, used by IconButton */\r\n  MoveUpButton = 'Move up',\r\n  /** Remove button title, used by IconButton */\r\n  RemoveButton = 'Remove',\r\n  /** Now label, used by AltDateWidget */\r\n  NowLabel = 'Now',\r\n  /** Clear label, used by AltDateWidget */\r\n  ClearLabel = 'Clear',\r\n  /** Aria date label, used by DateWidget */\r\n  AriaDateLabel = 'Select a date',\r\n  /** File preview label, used by FileWidget */\r\n  PreviewLabel = 'Preview',\r\n  /** Decrement button aria label, used by UpDownWidget */\r\n  DecrementAriaLabel = 'Decrease value by 1',\r\n  /** Increment button aria label, used by UpDownWidget */\r\n  IncrementAriaLabel = 'Increase value by 1',\r\n  // Strings with replaceable parameters\r\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\r\n  UnknownFieldType = 'Unknown field type %1',\r\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\r\n  OptionPrefix = 'Option %1',\r\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\r\n  TitleOptionPrefix = '%1 option %2',\r\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\r\n  KeyLabel = '%1 Key',\r\n  // Strings with replaceable parameters AND/OR that support markdown and html\r\n  /** Invalid object field configuration as provided by the ObjectField.\r\n   * NOTE: Use markdown notation rather than html tags.\r\n   */\r\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: _%2_.',\r\n  /** Unsupported field schema, used by UnsupportedField */\r\n  UnsupportedField = 'Unsupported field schema.',\r\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField.\r\n   * NOTE: Use markdown notation rather than html tags.\r\n   */\r\n  UnsupportedFieldWithId = 'Unsupported field schema for field `%1`.',\r\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField.\r\n   * NOTE: Use markdown notation rather than html tags.\r\n   */\r\n  UnsupportedFieldWithReason = 'Unsupported field schema: _%1_.',\r\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField.\r\n   * NOTE: Use markdown notation rather than html tags.\r\n   */\r\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field `%1`: _%2_.',\r\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\r\n  FilesInfo = '**%1** (%2, %3 bytes)',\r\n}\r\n","import Ajv, { Options } from 'ajv';\r\nimport addFormats, { FormatsPluginOptions } from 'ajv-formats';\r\nimport isObject from 'lodash-es/isObject';\r\n\r\nimport { CustomValidatorOptionsType } from './types';\r\nimport { ADDITIONAL_PROPERTY_FLAG, RJSF_ADDITIONAL_PROPERTIES_FLAG } from '@react-jsf/utils';\r\n\r\nexport const AJV_CONFIG: Options = {\r\n  allErrors: true,\r\n  multipleOfPrecision: 8,\r\n  strict: false,\r\n  verbose: true,\r\n  discriminator: false, // TODO enable this in V6\r\n} as const;\r\nexport const COLOR_FORMAT_REGEX =\r\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\r\nexport const DATA_URL_FORMAT_REGEX = /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\r\n\r\n/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.\r\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\r\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\r\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\r\n * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By\r\n * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`\r\n * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of\r\n * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.\r\n *\r\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\r\n * @param [customFormats] - The set of additional custom formats that the validator will support\r\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\r\n * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it\r\n * @param [AjvClass] - The `Ajv` class to use when creating the validator instance\r\n */\r\nexport default function createAjvInstance(\r\n  additionalMetaSchemas?: CustomValidatorOptionsType['additionalMetaSchemas'],\r\n  customFormats?: CustomValidatorOptionsType['customFormats'],\r\n  ajvOptionsOverrides: CustomValidatorOptionsType['ajvOptionsOverrides'] = {},\r\n  ajvFormatOptions?: FormatsPluginOptions | false,\r\n  AjvClass: typeof Ajv = Ajv\r\n) {\r\n  const ajv = new AjvClass({ ...AJV_CONFIG, ...ajvOptionsOverrides });\r\n  if (ajvFormatOptions) {\r\n    addFormats(ajv, ajvFormatOptions);\r\n  } else if (ajvFormatOptions !== false) {\r\n    addFormats(ajv);\r\n  }\r\n\r\n  // add custom formats\r\n  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);\r\n  ajv.addFormat('color', COLOR_FORMAT_REGEX);\r\n\r\n  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.\r\n  ajv.addKeyword(ADDITIONAL_PROPERTY_FLAG);\r\n  ajv.addKeyword(RJSF_ADDITIONAL_PROPERTIES_FLAG);\r\n\r\n  // add more schemas to validate against\r\n  if (Array.isArray(additionalMetaSchemas)) {\r\n    ajv.addMetaSchema(additionalMetaSchemas);\r\n  }\r\n\r\n  // add more custom formats to validate against\r\n  if (isObject(customFormats)) {\r\n    Object.keys(customFormats).forEach((formatName) => {\r\n      ajv.addFormat(formatName, customFormats[formatName]);\r\n    });\r\n  }\r\n\r\n  return ajv;\r\n}\r\n","import { ErrorObject } from 'ajv';\r\nimport get from 'lodash-es/get';\r\nimport {\r\n  createErrorHandler,\r\n  CustomValidator,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  getDefaultFormState,\r\n  getUiOptions,\r\n  PROPERTIES_KEY,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  StrictRJSFSchema,\r\n  toErrorSchema,\r\n  UiSchema,\r\n  unwrapErrorHandler,\r\n  validationDataMerge,\r\n  ValidatorType,\r\n} from '@react-jsf/utils';\r\n\r\nexport type RawValidationErrorsType<Result = any> = { errors?: Result[]; validationError?: Error };\r\n\r\n/** Transforming the error output from ajv to format used by @react-jsf/utils.\r\n * At some point, components should be updated to support ajv.\r\n *\r\n * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\r\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\r\n */\r\nexport function transformRJSFValidationErrors<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(errors: ErrorObject[] = [], uiSchema?: UiSchema<T, S, F>): RJSFValidationError[] {\r\n  return errors.map((e: ErrorObject) => {\r\n    const { instancePath, keyword, params, schemaPath, parentSchema, ...rest } = e;\r\n    let { message = '' } = rest;\r\n    let property = instancePath.replace(/\\//g, '.');\r\n    let stack = `${property} ${message}`.trim();\r\n\r\n    if ('missingProperty' in params) {\r\n      property = property ? `${property}.${params.missingProperty}` : params.missingProperty;\r\n      const currentProperty: string = params.missingProperty;\r\n      const uiSchemaTitle = getUiOptions(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\r\n\r\n      if (uiSchemaTitle) {\r\n        message = message.replace(currentProperty, uiSchemaTitle);\r\n      } else {\r\n        const parentSchemaTitle = get(parentSchema, [PROPERTIES_KEY, currentProperty, 'title']);\r\n\r\n        if (parentSchemaTitle) {\r\n          message = message.replace(currentProperty, parentSchemaTitle);\r\n        }\r\n      }\r\n\r\n      stack = message;\r\n    } else {\r\n      const uiSchemaTitle = getUiOptions<T, S, F>(get(uiSchema, `${property.replace(/^\\./, '')}`)).title;\r\n\r\n      if (uiSchemaTitle) {\r\n        stack = `'${uiSchemaTitle}' ${message}`.trim();\r\n      } else {\r\n        const parentSchemaTitle = parentSchema?.title;\r\n\r\n        if (parentSchemaTitle) {\r\n          stack = `'${parentSchemaTitle}' ${message}`.trim();\r\n        }\r\n      }\r\n    }\r\n\r\n    // put data in expected format\r\n    return {\r\n      name: keyword,\r\n      property,\r\n      message,\r\n      params, // specific to ajv\r\n      stack,\r\n      schemaPath,\r\n    };\r\n  });\r\n}\r\n\r\n/** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\r\n * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\r\n * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\r\n * transform them in what ever way it chooses.\r\n *\r\n * @param validator - The `ValidatorType` implementation used for the `getDefaultFormState()` call\r\n * @param rawErrors - The list of raw `ErrorObject`s to process\r\n * @param formData - The form data to validate\r\n * @param schema - The schema against which to validate the form data\r\n * @param [customValidate] - An optional function that is used to perform custom validation\r\n * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\r\n * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\r\n */\r\nexport default function processRawValidationErrors<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rawErrors: RawValidationErrorsType<ErrorObject>,\r\n  formData: T | undefined,\r\n  schema: S,\r\n  customValidate?: CustomValidator<T, S, F>,\r\n  transformErrors?: ErrorTransformer<T, S, F>,\r\n  uiSchema?: UiSchema<T, S, F>\r\n) {\r\n  const { validationError: invalidSchemaError } = rawErrors;\r\n  let errors = transformRJSFValidationErrors<T, S, F>(rawErrors.errors, uiSchema);\r\n\r\n  if (invalidSchemaError) {\r\n    errors = [...errors, { stack: invalidSchemaError!.message }];\r\n  }\r\n  if (typeof transformErrors === 'function') {\r\n    errors = transformErrors(errors, uiSchema);\r\n  }\r\n\r\n  let errorSchema: ErrorSchema<T> = toErrorSchema<T>(errors);\r\n\r\n  if (invalidSchemaError) {\r\n    errorSchema = {\r\n      ...errorSchema,\r\n      $schema: {\r\n        __errors: [invalidSchemaError!.message],\r\n      },\r\n    };\r\n  }\r\n\r\n  if (typeof customValidate !== 'function') {\r\n    return { errors, errorSchema };\r\n  }\r\n\r\n  // Include form data with undefined values, which is required for custom validation.\r\n  const newFormData = getDefaultFormState<T, S, F>(validator, schema, formData, schema, true) as T;\r\n\r\n  const errorHandler = customValidate(newFormData, createErrorHandler<T>(newFormData), uiSchema);\r\n  const userErrorSchema = unwrapErrorHandler<T>(errorHandler);\r\n  return validationDataMerge<T>({ errors, errorSchema }, userErrorSchema);\r\n}\r\n","import toPath from 'lodash-es/toPath';\r\n\r\nimport { ErrorSchema, RJSFValidationError } from './types';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\n\r\n/** Transforms a rjsf validation errors list:\r\n * [\r\n *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n * ]\r\n * Into an error tree:\r\n * {\r\n *   level1: {\r\n *     level2: {\r\n *       2: {level3: {errors: ['err a', 'err b']}},\r\n *       4: {level3: {errors: ['err b']}},\r\n *     }\r\n *   }\r\n * };\r\n *\r\n * @param errors - The list of RJSFValidationError objects\r\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\r\n */\r\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\r\n  const builder = new ErrorSchemaBuilder<T>();\r\n  if (errors.length) {\r\n    errors.forEach((error) => {\r\n      const { property, message } = error;\r\n      // When the property is the root element, just use an empty array for the path\r\n      const path = property === '.' ? [] : toPath(property);\r\n      // If the property is at the root (.level1) then toPath creates\r\n      // an empty array element at the first index. Remove it.\r\n      if (path.length > 0 && path[0] === '') {\r\n        path.splice(0, 1);\r\n      }\r\n      if (message) {\r\n        builder.addErrors(message, path);\r\n      }\r\n    });\r\n  }\r\n  return builder.ErrorSchema;\r\n}\r\n","import Ajv, { ErrorObject, ValidateFunction } from 'ajv';\r\nimport {\r\n  CustomValidator,\r\n  deepEquals,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  ID_KEY,\r\n  RJSFSchema,\r\n  ROOT_SCHEMA_PREFIX,\r\n  StrictRJSFSchema,\r\n  toErrorList,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n  withIdRefPrefix,\r\n  hashForSchema,\r\n} from '@react-jsf/utils';\r\n\r\nimport { CustomValidatorOptionsType, Localizer } from './types';\r\nimport createAjvInstance from './createAjvInstance';\r\nimport processRawValidationErrors, { RawValidationErrorsType } from './processRawValidationErrors';\r\n\r\n/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.\r\n */\r\nexport default class AJV8Validator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements ValidatorType<T, S, F>\r\n{\r\n  /** The AJV instance to use for all validations\r\n   *\r\n   * @private\r\n   */\r\n  ajv: Ajv;\r\n\r\n  /** The Localizer function to use for localizing Ajv errors\r\n   *\r\n   * @private\r\n   */\r\n  readonly localizer?: Localizer;\r\n\r\n  /** Constructs an `AJV8Validator` instance using the `options`\r\n   *\r\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\r\n   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\r\n   */\r\n  constructor(options: CustomValidatorOptionsType, localizer?: Localizer) {\r\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass } = options;\r\n    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);\r\n    this.localizer = localizer;\r\n  }\r\n\r\n  /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.\r\n   */\r\n  reset() {\r\n    this.ajv.removeSchema();\r\n  }\r\n\r\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n   *\r\n   * @param errorSchema - The `ErrorSchema` instance to convert\r\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n   * @deprecated - Use the `toErrorList()` function provided by `@react-jsf/utils` instead. This function will be removed in\r\n   *        the next major release.\r\n   */\r\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\r\n    return toErrorList(errorSchema, fieldPath);\r\n  }\r\n\r\n  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use\r\n   * by the playground. Returns the `errors` from the validation\r\n   *\r\n   * @param schema - The schema against which to validate the form data   * @param schema\r\n   * @param formData - The form data to validate\r\n   */\r\n  rawValidation<Result = any>(schema: S, formData?: T): RawValidationErrorsType<Result> {\r\n    let compilationError: Error | undefined = undefined;\r\n    let compiledValidator: ValidateFunction | undefined;\r\n    if (schema[ID_KEY]) {\r\n      compiledValidator = this.ajv.getSchema(schema[ID_KEY]);\r\n    }\r\n    try {\r\n      if (compiledValidator === undefined) {\r\n        compiledValidator = this.ajv.compile(schema);\r\n      }\r\n      compiledValidator(formData);\r\n    } catch (err) {\r\n      compilationError = err as Error;\r\n    }\r\n\r\n    let errors;\r\n    if (compiledValidator) {\r\n      if (typeof this.localizer === 'function') {\r\n        this.localizer(compiledValidator.errors);\r\n      }\r\n      errors = compiledValidator.errors || undefined;\r\n\r\n      // Clear errors to prevent persistent errors, see #1104\r\n      compiledValidator.errors = null;\r\n    }\r\n\r\n    return {\r\n      errors: errors as unknown as Result[],\r\n      validationError: compilationError,\r\n    };\r\n  }\r\n\r\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\r\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\r\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\r\n   * transform them in what ever way it chooses.\r\n   *\r\n   * @param formData - The form data to validate\r\n   * @param schema - The schema against which to validate the form data\r\n   * @param [customValidate] - An optional function that is used to perform custom validation\r\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\r\n   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`\r\n   */\r\n  validateFormData(\r\n    formData: T | undefined,\r\n    schema: S,\r\n    customValidate?: CustomValidator<T, S, F>,\r\n    transformErrors?: ErrorTransformer<T, S, F>,\r\n    uiSchema?: UiSchema<T, S, F>\r\n  ): ValidationData<T> {\r\n    const rawErrors = this.rawValidation<ErrorObject>(schema, formData);\r\n    return processRawValidationErrors(this, rawErrors, formData, schema, customValidate, transformErrors, uiSchema);\r\n  }\r\n\r\n  /**\r\n   * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.\r\n   * @param rootSchema - The root schema used to provide $ref resolutions\r\n   */\r\n  handleSchemaUpdate(rootSchema: S): void {\r\n    const rootSchemaId = rootSchema[ID_KEY] ?? ROOT_SCHEMA_PREFIX;\r\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\r\n    // if schema validator instance doesn't exist, add it.\r\n    // else if the root schemas don't match, we should remove and add the root schema so we don't have to remove and recompile the schema every run.\r\n    if (this.ajv.getSchema(rootSchemaId) === undefined) {\r\n      this.ajv.addSchema(rootSchema, rootSchemaId);\r\n    } else if (!deepEquals(rootSchema, this.ajv.getSchema(rootSchemaId)?.schema)) {\r\n      this.ajv.removeSchema(rootSchemaId);\r\n      this.ajv.addSchema(rootSchema, rootSchemaId);\r\n    }\r\n  }\r\n\r\n  /** Validates data against a schema, returning true if the data is valid, or\r\n   * false otherwise. If the schema is invalid, then this function will return\r\n   * false.\r\n   *\r\n   * @param schema - The schema against which to validate the form data\r\n   * @param formData - The form data to validate\r\n   * @param rootSchema - The root schema used to provide $ref resolutions\r\n   */\r\n  isValid(schema: S, formData: T | undefined, rootSchema: S) {\r\n    try {\r\n      this.handleSchemaUpdate(rootSchema);\r\n      // then rewrite the schema ref's to point to the rootSchema\r\n      // this accounts for the case where schema have references to models\r\n      // that lives in the rootSchema but not in the schema in question.\r\n      const schemaWithIdRefPrefix = withIdRefPrefix<S>(schema) as S;\r\n      const schemaId = schemaWithIdRefPrefix[ID_KEY] ?? hashForSchema(schemaWithIdRefPrefix);\r\n      let compiledValidator: ValidateFunction | undefined;\r\n      compiledValidator = this.ajv.getSchema(schemaId);\r\n      if (compiledValidator === undefined) {\r\n        // Add schema by an explicit ID so it can be fetched later\r\n        // Fall back to using compile if necessary\r\n        // https://ajv.js.org/guide/managing-schemas.html#pre-adding-all-schemas-vs-adding-on-demand\r\n        compiledValidator =\r\n          this.ajv.addSchema(schemaWithIdRefPrefix, schemaId).getSchema(schemaId) ||\r\n          this.ajv.compile(schemaWithIdRefPrefix);\r\n      }\r\n      const result = compiledValidator(formData);\r\n      return result as boolean;\r\n    } catch (e) {\r\n      console.warn('Error encountered compiling schema:', e);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n","import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** JS has no built-in hashing function, so rolling our own\r\n *  based on Java's hashing fn:\r\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\r\n *\r\n * @param string - The string for which to get the hash\r\n * @returns - The resulting hash of the string in hex format\r\n */\r\nfunction hashString(string: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    const chr = string.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n}\r\n\r\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\r\n * in consistent order before stringify to prevent different hash ids for the same schema.\r\n *\r\n * @param schema - The schema for which the hash is desired\r\n * @returns - The string obtained from the hash of the stringified schema\r\n */\r\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const allKeys = new Set<string>();\r\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\r\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\r\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\r\n}\r\n","import customizeValidator from './utils/customizeValidator';\r\nimport createPrecompiledValidator from './utils/createPrecompiledValidator';\r\n\r\nexport { customizeValidator, createPrecompiledValidator };\r\nexport * from './utils/types';\r\n\r\nexport default customizeValidator();\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nimport { CustomValidatorOptionsType, Localizer } from './types';\r\nimport AJV8Validator from './validator';\r\n\r\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\r\n * provided. If a `localizer` is provided, it is used to translate the messages generated by the underlying AJV\r\n * validation.\r\n *\r\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\r\n * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s\r\n * @returns - The custom validator implementation resulting from the set of parameters provided\r\n */\r\nexport default function customizeValidator<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(options: CustomValidatorOptionsType = {}, localizer?: Localizer) {\r\n  return new AJV8Validator<T, S, F>(options, localizer);\r\n}\r\n","import { MouseEvent, useState } from 'react';\r\nimport {\r\n  getTemplate,\r\n  getWidget,\r\n  getUiOptions,\r\n  isFixedItems,\r\n  allowAdditionalItems,\r\n  isCustomWidget,\r\n  optionsList,\r\n  ArrayFieldTemplateProps,\r\n  ErrorSchema,\r\n  FieldProps,\r\n  FormContextType,\r\n  IdSchema,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  UiSchema,\r\n  ITEMS_KEY,\r\n} from '@react-jsf/utils';\r\nimport cloneDeep from 'lodash-es/cloneDeep';\r\nimport get from 'lodash-es/get';\r\nimport isObject from 'lodash-es/isObject';\r\nimport set from 'lodash-es/set';\r\nimport { nanoid } from 'nanoid';\r\n\r\n/** Type used to represent the keyed form data used in the state */\r\ntype KeyedFormDataType<T> = { key: string; item: T };\r\n\r\n/** Type used for the state of the `ArrayField` component */\r\ntype ArrayFieldState<T> = {\r\n  /** The keyed form data elements */\r\n  keyedFormData: KeyedFormDataType<T>[];\r\n  /** Flag indicating whether any of the keyed form data has been updated */\r\n  updatedKeyedFormData: boolean;\r\n  index: number | undefined;\r\n  newIndex: number | undefined;\r\n  operation: 'add' | 'drop' | 'copy' | 'reorder'| 'initial' |undefined;\r\n  // prevState: ArrayFieldState<T> | undefined;\r\n};\r\n\r\n/** Used to generate a unique ID for an element in a row */\r\nfunction generateRowId() {\r\n  return nanoid();\r\n}\r\n\r\n/** Converts the `formData` into `KeyedFormDataType` data, using the `generateRowId()` function to create the key\r\n *\r\n * @param formData - The data for the form\r\n * @returns - The `formData` converted into a `KeyedFormDataType` element\r\n */\r\nfunction generateKeyedFormData<T>(formData: T[]): KeyedFormDataType<T>[] {\r\n  return !Array.isArray(formData)\r\n    ? []\r\n    : formData.map((item) => {\r\n        return {\r\n          key: generateRowId(),\r\n          item,\r\n        };\r\n      });\r\n}\r\n\r\n/** Converts `KeyedFormDataType` data into the inner `formData`\r\n *\r\n * @param keyedFormData - The `KeyedFormDataType` to be converted\r\n * @returns - The inner `formData` item(s) in the `keyedFormData`\r\n */\r\nfunction keyedToPlainFormData<T>(keyedFormData: KeyedFormDataType<T> | KeyedFormDataType<T>[]): T[] {\r\n  if (Array.isArray(keyedFormData)) {\r\n    return keyedFormData.map((keyedItem) => keyedItem.item);\r\n  }\r\n  return [];\r\n}\r\n\r\nfunction ArrayField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T[], S, F>\r\n) {\r\n  \r\n  /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements\r\n   */  \r\n  const { formData = [], onChange, errorSchema, schema, uiSchema, idSchema, registry, disabled, hideError, idPrefix, idSeparator, readonly, formContext } = props;\r\n  const { schemaUtils, translateString } = registry;\r\n\r\n  const [state, setState] = useState<ArrayFieldState<T>>({\r\n    keyedFormData: generateKeyedFormData(formData),\r\n    updatedKeyedFormData: false,\r\n    index: undefined,\r\n    newIndex: undefined,\r\n    operation: undefined\r\n    // prevState: undefined\r\n  });\r\n  resetErrorSchema();\r\n  getDerivedStateFromProps();\r\n\r\n  function resetErrorSchema() {\r\n    // getDerivedStateFromProps();\r\n    // refs #195: revalidate to ensure properly reindexing errors\r\n    let newErrorSchema: ErrorSchema<T[]> = {} as ErrorSchema<T[]>;\r\n    if (errorSchema) {\r\n      for (const idx in errorSchema) {\r\n        const i = parseInt(idx);\r\n        if ('add' === state.operation) {\r\n          if (state.index === undefined || i < state.index) {\r\n            set(newErrorSchema, [i], get(errorSchema, [idx]));\r\n          } else if (i >= state.index) {\r\n            set(newErrorSchema, [i + 1], get(errorSchema, [idx]));\r\n          }\r\n        } else if ('drop' === state.operation) {\r\n          for (const idx in errorSchema) {\r\n            const i = parseInt(idx);\r\n            if (i < (state.index as number)) {\r\n              set(newErrorSchema, [i],  get(errorSchema, [idx]));\r\n            } else if (i > (state.index as number)) {\r\n              set(newErrorSchema, [i - 1],  get(errorSchema, [idx]));\r\n            }\r\n          }\r\n        } else if ('copy' === state.operation) {\r\n          for (const idx in errorSchema) {\r\n            const i = parseInt(idx);\r\n            if (i <= (state.index as number)) {\r\n              set(newErrorSchema, [i], get(errorSchema, [idx]));\r\n            } else if (i > (state.index as number)) {\r\n              set(newErrorSchema, [i + 1], get(errorSchema, [idx]));\r\n            }\r\n          }\r\n          \r\n        } else if ('reorder' === state.operation) {\r\n          if (i === state.index) {\r\n            set(newErrorSchema, [state.newIndex as number], get(errorSchema, [state.index as number]));\r\n          } else if (i === state.newIndex) {\r\n            set(newErrorSchema, [state.index as number], get(errorSchema, [state.newIndex as number]));\r\n          } else {\r\n            set(newErrorSchema, [idx], get(errorSchema, [i]));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (onChange && state.operation !== 'initial' && state.index !== undefined) {\r\n      onChange(keyedToPlainFormData(state.keyedFormData), newErrorSchema)\r\n    }\r\n  };\r\n\r\n  /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It\r\n   * regenerates the keyed form data and returns it\r\n   *\r\n   * @param nextProps - The next set of props data\r\n   * @param prevState - The previous set of state data\r\n   */\r\n  function getDerivedStateFromProps() {\r\n    if (state.updatedKeyedFormData) {\r\n      setState(() =>  { return {\r\n        ...state,\r\n        updatedKeyedFormData: false,\r\n      }});\r\n    } \r\n  }\r\n  ////\r\n  /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to\r\n   * the description from the schema.items, and finally the string \"Item\"\r\n   */\r\n  // function getitemTitle() {\r\n  //   return get(\r\n  //     schema,\r\n  //     [ITEMS_KEY, 'title'],\r\n  //     get(schema, [ITEMS_KEY, 'description'], translateString(TranslatableString.ArrayItemTitle))\r\n  //   );\r\n  // }\r\n\r\n  /** Determines whether the item described in the schema is always required, which is determined by whether any item\r\n   * may be null.\r\n   *\r\n   * @param itemSchema - The schema for the item\r\n   * @return - True if the item schema type does not contain the \"null\" type\r\n   */\r\n  function isItemRequired(itemSchema: S) {\r\n    if (Array.isArray(itemSchema.type)) {\r\n      // While we don't yet support composite/nullable jsonschema types, it's\r\n      // future-proof to check for requirement against these.\r\n      return !itemSchema.type.includes('null');\r\n    }\r\n    // All non-null array item types are inherently required by design\r\n    return itemSchema.type !== 'null';\r\n  }\r\n\r\n  /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding\r\n   * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the\r\n   * `formData` matches that value, then false is returned, otherwise true is returned.\r\n   *\r\n   * @param formItems - The list of items in the form\r\n   * @returns - True if the item is addable otherwise false\r\n   */\r\n  function canAddItem(formItems: any[]) {\r\n    let { addable } = getUiOptions<T[], S, F>(uiSchema, registry.globalUiOptions);\r\n    if (addable !== false) {\r\n      // if ui:options.addable was not explicitly set to false, we can add\r\n      // another item if we have not exceeded maxItems yet\r\n      if (schema.maxItems !== undefined) {\r\n        addable = formItems.length < schema.maxItems;\r\n      } else {\r\n        addable = true;\r\n      }\r\n    }\r\n    return addable;\r\n  }\r\n\r\n  /** Returns the default form information for an item based on the schema for that item. Deals with the possibility\r\n   * that the schema is fixed and allows additional items.\r\n   */\r\n  const _getNewFormDataRow = (): T => {\r\n    let itemSchema = schema.items as S;\r\n    if (isFixedItems(schema) && allowAdditionalItems(schema)) {\r\n      itemSchema = schema.additionalItems as S;\r\n    }\r\n    // Cast this as a T to work around schema utils being for T[] caused by the FieldProps<T[], S, F> call on the class\r\n    return schemaUtils.getDefaultFormState(itemSchema) as unknown as T;\r\n  };\r\n\r\n  /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data\r\n   * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into\r\n   * the state, and then returning `onChange()` with the plain form data converted from the keyed data\r\n   *\r\n   * @param event - The event for the click\r\n   * @param [index] - The optional index at which to add the new data\r\n   */\r\n  function _handleAddClick(event: MouseEvent, index?: number) {\r\n    if (event) {\r\n      event.preventDefault();\r\n    }\r\n    \r\n    const newKeyedFormDataRow: KeyedFormDataType<T> = {\r\n      key: generateRowId(),\r\n      item: _getNewFormDataRow(),\r\n    };\r\n    const newKeyedFormData = [...state.keyedFormData];\r\n    if (index !== undefined) {\r\n      newKeyedFormData.splice(index, 0, newKeyedFormDataRow);\r\n    } else {\r\n      newKeyedFormData.push(newKeyedFormDataRow);\r\n    }\r\n    setState(() => { return {\r\n      keyedFormData: newKeyedFormData,\r\n      updatedKeyedFormData: true,\r\n      index: index,\r\n      newIndex: undefined,\r\n      operation: 'add'\r\n      // prevState: state\r\n    }});\r\n  }\r\n\r\n  /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of\r\n   * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the\r\n   * keyed data\r\n   *\r\n   * @param event - The event for the click\r\n   */\r\n  const onAddClick = (event: MouseEvent) => {\r\n    _handleAddClick(event);\r\n  };\r\n\r\n  /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of\r\n   * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain\r\n   * form data converted from the keyed data\r\n   *\r\n   * @param index - The index at which the add button is clicked\r\n   */\r\n  const onAddIndexClick = (index: number) => {\r\n    return (event: MouseEvent) => {\r\n      _handleAddClick(event, index);\r\n    };\r\n  };\r\n\r\n  /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of\r\n   * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain\r\n   * form data converted from the keyed data\r\n   *\r\n   * @param index - The index at which the copy button is clicked\r\n   */\r\n  const onCopyIndexClick = (index: number) => {\r\n    return (event: MouseEvent) => {\r\n      if (event) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      const newKeyedFormDataRow: KeyedFormDataType<T> = {\r\n        key: generateRowId(),\r\n        item: cloneDeep(state.keyedFormData[index].item),\r\n      };\r\n      const newKeyedFormData = [...state.keyedFormData];\r\n      if (index !== undefined) {\r\n        newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);\r\n      } else {\r\n        newKeyedFormData.push(newKeyedFormDataRow);\r\n      }\r\n      setState(() => { return {\r\n        keyedFormData: newKeyedFormData,\r\n        updatedKeyedFormData: true,\r\n        index: index,\r\n        newIndex: undefined,\r\n        operation: 'copy'\r\n        // prevState: state\r\n      }});\r\n    };\r\n  }\r\n\r\n  /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of\r\n   * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted\r\n   * from the keyed data\r\n   *\r\n   * @param index - The index at which the remove button is clicked\r\n   */\r\n  const onDropIndexClick = (index: number) => {\r\n    return (event: MouseEvent) => {\r\n      if (event) {\r\n        event.preventDefault();\r\n      }\r\n\r\n      const newKeyedFormData = state.keyedFormData.filter((_, i) => i !== index);\r\n      setState(() => { return {\r\n        keyedFormData: newKeyedFormData,\r\n        updatedKeyedFormData: true,\r\n        index: index,\r\n        newIndex: undefined,\r\n        operation: 'drop'\r\n        // prevState: state\r\n      }});\r\n    };\r\n  }\r\n\r\n  /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the\r\n   * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the\r\n   * plain form data converted from the keyed data\r\n   *\r\n   * @param index - The index of the item to move\r\n   * @param newIndex - The index to where the item is to be moved\r\n   */\r\n  const onReorderClick = (index: number, newIndex: number) => {\r\n    return (event: MouseEvent<HTMLButtonElement>) => {\r\n      if (event) {\r\n        event.preventDefault();\r\n        event.currentTarget.blur();\r\n      }\r\n\r\n      const { keyedFormData } = state;\r\n      function reOrderArray() {\r\n        // Copy item\r\n        const _newKeyedFormData = keyedFormData.slice();\r\n\r\n        // Moves item from index to newIndex\r\n        _newKeyedFormData.splice(index, 1);\r\n        _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);\r\n\r\n        return _newKeyedFormData;\r\n      }\r\n      const newKeyedFormData = reOrderArray();\r\n      setState(() => {return {\r\n        ...state,\r\n        keyedFormData: newKeyedFormData,\r\n        operation: 'reorder',\r\n        index: index,\r\n        newIndex: newIndex\r\n        // prevState: state\r\n      }})\r\n    };\r\n  }\r\n\r\n  /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the\r\n   * `onChange` callback with the updated form data\r\n   *\r\n   * @param index - The index of the item being changed\r\n   */\r\n  const onChangeForIndex = (index: number) => {\r\n    return (value: any, newErrorSchema?: ErrorSchema<T>, id?: string) => {\r\n      //const { formData, onChange, errorSchema } = this.props;\r\n      const arrayData = Array.isArray(formData) ? formData : [];\r\n      const newFormData = arrayData.map((item: T, i: number) => {\r\n        // We need to treat undefined items as nulls to have validation.\r\n        // See https://github.com/tdegrunt/jsonschema/issues/206\r\n        const jsonValue = typeof value === 'undefined' ? null : value;\r\n        return index === i ? jsonValue : item;\r\n      });\r\n      onChange(\r\n        newFormData,\r\n        errorSchema &&\r\n          errorSchema && {\r\n            ...errorSchema,\r\n            [index]: newErrorSchema,\r\n          },\r\n        id\r\n      );\r\n    };\r\n  }\r\n\r\n  /** Callback handler used to change the value for a checkbox */\r\n  const onSelectChange = (value: any) => {\r\n    onChange(value, undefined, idSchema && idSchema.$id);\r\n  }\r\n  //////\r\n  /** Renders a normal array without any limitations of length\r\n     */\r\n  function renderNormalArray() {\r\n    const {\r\n      schema,\r\n      uiSchema = {},\r\n      errorSchema,\r\n      idSchema,\r\n      name,\r\n      title,\r\n      disabled = false,\r\n      readonly = false,\r\n      autofocus = false,\r\n      required = false,\r\n      registry,\r\n      onBlur,\r\n      onFocus,\r\n      idPrefix,\r\n      idSeparator = '_',\r\n      rawErrors,\r\n    } = props;\r\n    const { keyedFormData } = state;\r\n    const fieldTitle = schema.title || title || name;\r\n    const { schemaUtils, formContext } = registry;\r\n    const uiOptions = getUiOptions<T[], S, F>(uiSchema);\r\n    const _schemaItems: S = isObject(schema.items) ? (schema.items as S) : ({} as S);\r\n    const itemsSchema: S = schemaUtils.retrieveSchema(_schemaItems);\r\n    const formData = keyedToPlainFormData(state.keyedFormData);\r\n    const canAdd = canAddItem(formData);\r\n    const arrayProps: ArrayFieldTemplateProps<T[], S, F> = {\r\n      canAdd,\r\n      items: keyedFormData.map((keyedItem, index) => {\r\n        const { key, item } = keyedItem;\r\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\r\n        const itemCast = item as unknown as T[];\r\n        const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);\r\n        const itemErrorSchema = errorSchema ? (errorSchema[index] as ErrorSchema<T[]>) : undefined;\r\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\r\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\r\n        return renderArrayFieldItem({\r\n          key,\r\n          index,\r\n          name: name && `${name}-${index}`,\r\n          title: fieldTitle ? `${fieldTitle}-${index + 1}` : undefined,\r\n          canAdd,\r\n          canMoveUp: index > 0,\r\n          canMoveDown: index < formData.length - 1,\r\n          itemSchema,\r\n          itemIdSchema,\r\n          itemErrorSchema,\r\n          itemData: itemCast,\r\n          itemUiSchema: uiSchema.items,\r\n          autofocus: autofocus && index === 0,\r\n          onBlur,\r\n          onFocus,\r\n          rawErrors,\r\n          totalItems: keyedFormData.length,\r\n        });\r\n      }),\r\n      className: `field field-array field-array-of-${itemsSchema.type}`,\r\n      disabled,\r\n      idSchema,\r\n      uiSchema,\r\n      onAddClick: onAddClick,\r\n      readonly,\r\n      required,\r\n      schema,\r\n      title: fieldTitle,\r\n      formContext,\r\n      formData,\r\n      rawErrors,\r\n      registry,\r\n    };\r\n\r\n    const Template = getTemplate<'ArrayFieldTemplate', T[], S, F>('ArrayFieldTemplate', registry, uiOptions);\r\n    return <Template {...arrayProps} />;\r\n  }\r\n\r\n  /** Renders an array using the custom widget provided by the user in the `uiSchema`\r\n   */\r\n  function renderCustomWidget() {\r\n    const {\r\n      schema,\r\n      idSchema,\r\n      uiSchema,\r\n      disabled = false,\r\n      readonly = false,\r\n      autofocus = false,\r\n      required = false,\r\n      hideError,\r\n      placeholder,\r\n      onBlur,\r\n      onFocus,\r\n      formData: items = [],\r\n      registry,\r\n      rawErrors,\r\n      name,\r\n    } = props;\r\n    const { widgets, formContext, globalUiOptions, schemaUtils } = registry;\r\n    const { widget, title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\r\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\r\n    const label = uiTitle ?? schema.title ?? name;\r\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n    return (\r\n      <Widget\r\n        id={idSchema.$id}\r\n        name={name}\r\n        multiple\r\n        onChange={onSelectChange}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        options={options}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n        value={items}\r\n        disabled={disabled}\r\n        readonly={readonly}\r\n        hideError={hideError}\r\n        required={required}\r\n        label={label}\r\n        hideLabel={!displayLabel}\r\n        placeholder={placeholder}\r\n        formContext={formContext}\r\n        autofocus={autofocus}\r\n        rawErrors={rawErrors}\r\n      />\r\n    );\r\n  }\r\n\r\n  /** Renders an array as a set of checkboxes\r\n   */\r\n  function renderMultiSelect() {\r\n    const {\r\n      schema,\r\n      idSchema,\r\n      uiSchema,\r\n      formData: items = [],\r\n      disabled = false,\r\n      readonly = false,\r\n      autofocus = false,\r\n      required = false,\r\n      placeholder,\r\n      onBlur,\r\n      onFocus,\r\n      registry,\r\n      rawErrors,\r\n      name,\r\n    } = props;\r\n    const { widgets, schemaUtils, formContext, globalUiOptions } = registry;\r\n    const itemsSchema = schemaUtils.retrieveSchema(schema.items as S, items);\r\n    const enumOptions = optionsList<S, T[], F>(itemsSchema, uiSchema);\r\n    const { widget = 'select', title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\r\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\r\n    const label = uiTitle ?? schema.title ?? name;\r\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n    return (\r\n      <Widget\r\n        id={idSchema.$id}\r\n        name={name}\r\n        multiple\r\n        onChange={onSelectChange}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        options={{ ...options, enumOptions }}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n        value={items}\r\n        disabled={disabled}\r\n        readonly={readonly}\r\n        required={required}\r\n        label={label}\r\n        hideLabel={!displayLabel}\r\n        placeholder={placeholder}\r\n        formContext={formContext}\r\n        autofocus={autofocus}\r\n        rawErrors={rawErrors}\r\n      />\r\n    );\r\n  }\r\n\r\n  /** Renders an array of files using the `FileWidget`\r\n   */\r\n  function renderFiles() {\r\n    const {\r\n      schema,\r\n      uiSchema,\r\n      idSchema,\r\n      name,\r\n      disabled = false,\r\n      readonly = false,\r\n      autofocus = false,\r\n      required = false,\r\n      onBlur,\r\n      onFocus,\r\n      registry,\r\n      formData: items = [],\r\n      rawErrors,\r\n    } = props;\r\n    const { widgets, formContext, globalUiOptions, schemaUtils } = registry;\r\n    const { widget = 'files', title: uiTitle, ...options } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\r\n    const Widget = getWidget<T[], S, F>(schema, widget, widgets);\r\n    const label = uiTitle ?? schema.title ?? name;\r\n    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n    return (\r\n      <Widget\r\n        options={options}\r\n        id={idSchema.$id}\r\n        name={name}\r\n        multiple\r\n        onChange={onSelectChange}\r\n        onBlur={onBlur}\r\n        onFocus={onFocus}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        value={items}\r\n        disabled={disabled}\r\n        readonly={readonly}\r\n        required={required}\r\n        registry={registry}\r\n        formContext={formContext}\r\n        autofocus={autofocus}\r\n        rawErrors={rawErrors}\r\n        label={label}\r\n        hideLabel={!displayLabel}\r\n      />\r\n    );\r\n  }\r\n\r\n  /** Renders an array that has a maximum limit of items\r\n   */\r\n  function renderFixedArray() {\r\n    const {\r\n      schema,\r\n      uiSchema = {},\r\n      formData = [],\r\n      errorSchema,\r\n      idPrefix,\r\n      idSeparator = '_',\r\n      idSchema,\r\n      name,\r\n      title,\r\n      disabled = false,\r\n      readonly = false,\r\n      autofocus = false,\r\n      required = false,\r\n      registry,\r\n      onBlur,\r\n      onFocus,\r\n      rawErrors,\r\n    } = props;\r\n    const { keyedFormData } = state;\r\n    let { formData: items = [] } = props;\r\n    const fieldTitle = schema.title || title || name;\r\n    const uiOptions = getUiOptions<T[], S, F>(uiSchema);\r\n    const { schemaUtils, formContext } = registry;\r\n    const _schemaItems: S[] = isObject(schema.items) ? (schema.items as S[]) : ([] as S[]);\r\n    const itemSchemas = _schemaItems.map((item: S, index: number) =>\r\n      schemaUtils.retrieveSchema(item, formData[index] as unknown as T[])\r\n    );\r\n    const additionalSchema = isObject(schema.additionalItems)\r\n      ? schemaUtils.retrieveSchema(schema.additionalItems as S, formData)\r\n      : null;\r\n\r\n    if (!items || items.length < itemSchemas.length) {\r\n      // to make sure at least all fixed items are generated\r\n      items = items || [];\r\n      items = items.concat(new Array(itemSchemas.length - items.length));\r\n    }\r\n\r\n    // These are the props passed into the render function\r\n    const canAdd = canAddItem(items) && !!additionalSchema;\r\n    const arrayProps: ArrayFieldTemplateProps<T[], S, F> = {\r\n      canAdd,\r\n      className: 'field field-array field-array-fixed-items',\r\n      disabled,\r\n      idSchema,\r\n      formData,\r\n      items: keyedFormData.map((keyedItem, index) => {\r\n        const { key, item } = keyedItem;\r\n        // While we are actually dealing with a single item of type T, the types require a T[], so cast\r\n        const itemCast = item as unknown as T[];\r\n        const additional = index >= itemSchemas.length;\r\n        const itemSchema =\r\n          (additional && isObject(schema.additionalItems)\r\n            ? schemaUtils.retrieveSchema(schema.additionalItems as S, itemCast)\r\n            : itemSchemas[index]) || {};\r\n        const itemIdPrefix = idSchema.$id + idSeparator + index;\r\n        const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);\r\n        const itemUiSchema = additional\r\n          ? uiSchema.additionalItems || {}\r\n          : Array.isArray(uiSchema.items)\r\n          ? uiSchema.items[index]\r\n          : uiSchema.items || {};\r\n        const itemErrorSchema = errorSchema ? (errorSchema[index] as ErrorSchema<T[]>) : undefined;\r\n\r\n        return renderArrayFieldItem({\r\n          key,\r\n          index,\r\n          name: name && `${name}-${index}`,\r\n          title: fieldTitle ? `${fieldTitle}-${index + 1}` : undefined,\r\n          canAdd,\r\n          canRemove: additional,\r\n          canMoveUp: index >= itemSchemas.length + 1,\r\n          canMoveDown: additional && index < items.length - 1,\r\n          itemSchema,\r\n          itemData: itemCast,\r\n          itemUiSchema,\r\n          itemIdSchema,\r\n          itemErrorSchema,\r\n          autofocus: autofocus && index === 0,\r\n          onBlur,\r\n          onFocus,\r\n          rawErrors,\r\n          totalItems: keyedFormData.length,\r\n        });\r\n      }),\r\n      onAddClick: onAddClick,\r\n      readonly,\r\n      required,\r\n      registry,\r\n      schema,\r\n      uiSchema,\r\n      title: fieldTitle,\r\n      formContext,\r\n      errorSchema,\r\n      rawErrors,\r\n    };\r\n\r\n    const Template = getTemplate<'ArrayFieldTemplate', T[], S, F>('ArrayFieldTemplate', registry, uiOptions);\r\n    return <Template {...arrayProps} />;\r\n  }\r\n\r\n  /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send\r\n   * back to the `ArrayFieldItemTemplate`.\r\n   *\r\n   * @param props - The props for the individual array item to be rendered\r\n   */\r\n  function renderArrayFieldItem(props: {\r\n    key: string;\r\n    index: number;\r\n    name: string;\r\n    title: string | undefined;\r\n    canAdd: boolean;\r\n    canRemove?: boolean;\r\n    canMoveUp: boolean;\r\n    canMoveDown: boolean;\r\n    itemSchema: S;\r\n    itemData: T[];\r\n    itemUiSchema: UiSchema<T[], S, F>;\r\n    itemIdSchema: IdSchema<T[]>;\r\n    itemErrorSchema?: ErrorSchema<T[]>;\r\n    autofocus?: boolean;\r\n    onBlur: FieldProps<T[], S, F>['onBlur'];\r\n    onFocus: FieldProps<T[], S, F>['onFocus'];\r\n    rawErrors?: string[];\r\n    totalItems: number;\r\n  }) {\r\n    const {\r\n      key,\r\n      index,\r\n      name,\r\n      canAdd,\r\n      canRemove = true,\r\n      canMoveUp,\r\n      canMoveDown,\r\n      itemSchema,\r\n      itemData,\r\n      itemUiSchema,\r\n      itemIdSchema,\r\n      itemErrorSchema,\r\n      autofocus,\r\n      onBlur,\r\n      onFocus,\r\n      rawErrors,\r\n      totalItems,\r\n      title,\r\n    } = props;\r\n    // const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = props;\r\n    const {\r\n      fields: { ArraySchemaField, SchemaField },\r\n      globalUiOptions,\r\n    } = registry;\r\n    const ItemSchemaField = ArraySchemaField || SchemaField;\r\n    const { orderable = true, removable = true, copyable = false } = getUiOptions<T[], S, F>(uiSchema, globalUiOptions);\r\n    const has: { [key: string]: boolean } = {\r\n      moveUp: orderable && canMoveUp,\r\n      moveDown: orderable && canMoveDown,\r\n      copy: copyable && canAdd,\r\n      remove: removable && canRemove,\r\n      toolbar: false,\r\n    };\r\n    has.toolbar = Object.keys(has).some((key: keyof typeof has) => has[key]);\r\n\r\n    return {\r\n      children: (\r\n        <ItemSchemaField\r\n          name={name}\r\n          title={title}\r\n          index={index}\r\n          schema={itemSchema}\r\n          uiSchema={itemUiSchema}\r\n          formData={itemData}\r\n          formContext={formContext}\r\n          errorSchema={itemErrorSchema}\r\n          idPrefix={idPrefix}\r\n          idSeparator={idSeparator}\r\n          idSchema={itemIdSchema}\r\n          required={isItemRequired(itemSchema)}\r\n          onChange={onChangeForIndex(index)}\r\n          onBlur={onBlur}\r\n          onFocus={onFocus}\r\n          registry={registry}\r\n          disabled={disabled}\r\n          readonly={readonly}\r\n          hideError={hideError}\r\n          autofocus={autofocus}\r\n          rawErrors={rawErrors}\r\n        />\r\n      ),\r\n      className: 'array-item',\r\n      disabled,\r\n      canAdd,\r\n      hasCopy: has.copy,\r\n      hasToolbar: has.toolbar,\r\n      hasMoveUp: has.moveUp,\r\n      hasMoveDown: has.moveDown,\r\n      hasRemove: has.remove,\r\n      index,\r\n      totalItems,\r\n      key,\r\n      onAddIndexClick: onAddIndexClick,\r\n      onCopyIndexClick: onCopyIndexClick,\r\n      onDropIndexClick: onDropIndexClick,\r\n      onReorderClick: onReorderClick,\r\n      readonly,\r\n      registry,\r\n      schema: itemSchema,\r\n      uiSchema: itemUiSchema,\r\n    };\r\n  }\r\n\r\n  if (!(ITEMS_KEY in schema)) {\r\n    const uiOptions = getUiOptions<T[], S, F>(uiSchema);\r\n    const UnsupportedFieldTemplate = getTemplate<'UnsupportedFieldTemplate', T[], S, F>(\r\n      'UnsupportedFieldTemplate',\r\n      registry,\r\n      uiOptions\r\n    );\r\n    return (\r\n      <UnsupportedFieldTemplate\r\n        schema={schema}\r\n        idSchema={idSchema}\r\n        reason={translateString(TranslatableString.MissingItems)}\r\n        registry={registry}\r\n      />\r\n    );\r\n  }\r\n  if (schemaUtils.isMultiSelect(schema)) {\r\n    // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.\r\n    return renderMultiSelect();\r\n  }\r\n  if (isCustomWidget<T[], S, F>(uiSchema)) {\r\n    return renderCustomWidget();\r\n  }\r\n  if (isFixedItems(schema)) {\r\n    return renderFixedArray();\r\n  }\r\n  if (schemaUtils.isFilesArray(schema, uiSchema)) {\r\n    return renderFiles();\r\n  }\r\n  return renderNormalArray();\r\n  \r\n}\r\n\r\n/** `ArrayField` is `React.ComponentType<FieldProps<T[], S, F>>` (necessarily) but the `registry` requires things to be a\r\n * `Field` which is defined as `React.ComponentType<FieldProps<T, S, F>>`, so cast it to make `registry` happy.\r\n */\r\nexport default ArrayField;","import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\r\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (schema.additionalItems === true) {\r\n    console.warn('additionalItems=true is currently not supported');\r\n  }\r\n  return isObject(schema.additionalItems);\r\n}\r\n","import {\r\n  getWidget,\r\n  getUiOptions,\r\n  optionsList,\r\n  FieldProps,\r\n  FormContextType,\r\n  EnumOptionsType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n} from '@react-jsf/utils';\r\nimport isObject from 'lodash-es/isObject';\r\n\r\n/** The `BooleanField` component is used to render a field in the schema is boolean. It constructs `enumOptions` for the\r\n * two boolean values based on the various alternatives in the schema.\r\n *\r\n * @param props - The `FieldProps` for this template\r\n */\r\nfunction BooleanField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const {\r\n    schema,\r\n    name,\r\n    uiSchema,\r\n    idSchema,\r\n    formData,\r\n    registry,\r\n    required,\r\n    disabled,\r\n    readonly,\r\n    hideError,\r\n    autofocus,\r\n    title,\r\n    onChange,\r\n    onFocus,\r\n    onBlur,\r\n    rawErrors,\r\n  } = props;\r\n  const { title: schemaTitle } = schema;\r\n  const { widgets, formContext, translateString, globalUiOptions } = registry;\r\n  const {\r\n    widget = 'checkbox',\r\n    title: uiTitle,\r\n    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type\r\n    label: displayLabel = true,\r\n    ...options\r\n  } = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\r\n  const Widget = getWidget(schema, widget, widgets);\r\n  const yes = translateString(TranslatableString.YesLabel);\r\n  const no = translateString(TranslatableString.NoLabel);\r\n  let enumOptions: EnumOptionsType<S>[] | undefined;\r\n  const label = uiTitle ?? schemaTitle ?? title ?? name;\r\n  if (Array.isArray(schema.oneOf)) {\r\n    enumOptions = optionsList<S, T, F>(\r\n      {\r\n        oneOf: schema.oneOf\r\n          .map((option) => {\r\n            if (isObject(option)) {\r\n              return {\r\n                ...option,\r\n                title: option.title || (option.const === true ? yes : no),\r\n              };\r\n            }\r\n            return undefined;\r\n          })\r\n          .filter((o: any) => o) as S[], // cast away the error that typescript can't grok is fixed\r\n      } as unknown as S,\r\n      uiSchema\r\n    );\r\n  } else {\r\n    // We deprecated enumNames in v5. It's intentionally omitted from RSJFSchema type, so we need to cast here.\r\n    const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n    const enums = schema.enum ?? [true, false];\r\n    if (!schemaWithEnumNames.enumNames && enums.length === 2 && enums.every((v: any) => typeof v === 'boolean')) {\r\n      enumOptions = [\r\n        {\r\n          value: enums[0],\r\n          label: enums[0] ? yes : no,\r\n        },\r\n        {\r\n          value: enums[1],\r\n          label: enums[1] ? yes : no,\r\n        },\r\n      ];\r\n    } else {\r\n      enumOptions = optionsList<S, T, F>(\r\n        {\r\n          enum: enums,\r\n          // NOTE: enumNames is deprecated, but still supported for now.\r\n          enumNames: schemaWithEnumNames.enumNames,\r\n        } as unknown as S,\r\n        uiSchema\r\n      );\r\n    }\r\n  }\r\n\r\n  return (\r\n    <Widget\r\n      options={{ ...options, enumOptions }}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      id={idSchema.$id}\r\n      name={name}\r\n      onChange={onChange}\r\n      onFocus={onFocus}\r\n      onBlur={onBlur}\r\n      label={label}\r\n      hideLabel={!displayLabel}\r\n      value={formData}\r\n      required={required}\r\n      disabled={disabled}\r\n      readonly={readonly}\r\n      hideError={hideError}\r\n      registry={registry}\r\n      formContext={formContext}\r\n      autofocus={autofocus}\r\n      rawErrors={rawErrors}\r\n    />\r\n  );\r\n}\r\n\r\nexport default BooleanField;\r\n","import { useState } from 'react';\r\nimport get from 'lodash-es/get';\r\nimport isEmpty from 'lodash-es/isEmpty';\r\nimport omit from 'lodash-es/omit';\r\nimport {\r\n  ANY_OF_KEY,\r\n  ERRORS_KEY,\r\n  FieldProps,\r\n  FormContextType,\r\n  getDiscriminatorFieldFromSchema,\r\n  getUiOptions,\r\n  getWidget,\r\n  mergeSchemas,\r\n  ONE_OF_KEY,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  UiSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** Type used for the state of the `AnyOfField` component */\r\ntype AnyOfFieldState<S extends StrictRJSFSchema = RJSFSchema> = {\r\n  /** The currently selected option */\r\n  selectedOption: number;\r\n  /** The option schemas after retrieving all $refs */\r\n  retrievedOptions: S[];\r\n};\r\n\r\n/** The `AnyOfField` component is used to render a field in the schema that is an `anyOf`, `allOf` or `oneOf`. It tracks\r\n * the currently selected option and cleans up any irrelevant data in `formData`.\r\n *\r\n * @param props - The `FieldProps` for this template\r\n */\r\nfunction AnyOfField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {  \r\n \r\n  const {\r\n    formData,\r\n    options,\r\n    name,\r\n    disabled = false,\r\n    errorSchema = {},\r\n    formContext,\r\n    onBlur,\r\n    onFocus,\r\n    registry,\r\n    idSchema,\r\n    schema,\r\n    uiSchema,\r\n    onChange\r\n  } = props;\r\n\r\n  const { widgets, fields, translateString, globalUiOptions, schemaUtils } = registry;\r\n  const { SchemaField: _SchemaField } = fields;\r\n  \r\n  const [state, setState] = useState<AnyOfFieldState<S>>(getInitialState());\r\n  const { selectedOption, retrievedOptions } = state;\r\n\r\n  function getInitialState(): AnyOfFieldState<S> {\r\n    const retrievedOptions = options.map((opt: S) => schemaUtils.retrieveSchema(opt, formData as T));\r\n    return {\r\n      retrievedOptions,\r\n      selectedOption: getMatchingOption(0, formData, retrievedOptions),\r\n    };\r\n  }\r\n  \r\n  /** Determines the best matching option for the given `formData` and `options`.\r\n   *\r\n   * @param formData - The new formData\r\n   * @param options - The list of options to choose from\r\n   * @return - The index of the `option` that best matches the `formData`\r\n   */\r\n  function getMatchingOption(selectedOption: number, formData: T | undefined, options: S[]) {\r\n    const {\r\n      schema,\r\n      registry: { schemaUtils },\r\n    } = props;\r\n\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);\r\n    return option;\r\n  }\r\n\r\n  /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated\r\n   * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to\r\n   * the `onChange` handler.\r\n   *\r\n   * @param option - The new option value being selected\r\n   */\r\n  const onOptionChange = (option?: string) => {\r\n    const intOption = option !== undefined ? parseInt(option, 10) : -1;\r\n    if (intOption === selectedOption) {\r\n      return;\r\n    }\r\n    const newOption = intOption >= 0 ? retrievedOptions[intOption] : undefined;\r\n    const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : undefined;\r\n\r\n    let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);\r\n    if (newFormData && newOption) {\r\n      // Call getDefaultFormState to make sure defaults are populated on change. Pass \"excludeObjectChildren\"\r\n      // so that only the root objects themselves are created without adding undefined children properties\r\n      newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, 'excludeObjectChildren') as T;\r\n    }\r\n    onChange(newFormData, undefined, getFieldId());\r\n\r\n    setState({ \r\n      ...state,\r\n      selectedOption: intOption \r\n    });\r\n  };\r\n\r\n  function getFieldId() {\r\n    return `${idSchema.$id}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`;\r\n  }\r\n\r\n  /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`\r\n   */\r\n  // render() {\r\n    \r\n  const {\r\n    widget = 'select',\r\n    placeholder,\r\n    autofocus,\r\n    autocomplete,\r\n    title = schema.title,\r\n    ...uiOptions\r\n  } = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\r\n  const Widget = getWidget<T, S, F>({ type: 'number' }, widget, widgets);\r\n  const rawErrors = get(errorSchema, ERRORS_KEY, []);\r\n  const fieldErrorSchema = omit(errorSchema, [ERRORS_KEY]);\r\n  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n\r\n  const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;\r\n  let optionSchema: S | undefined | null;\r\n\r\n  if (option) {\r\n    // merge top level required field\r\n    const { required } = schema;\r\n    // Merge in all the non-oneOf/anyOf properties and also skip the special ADDITIONAL_PROPERTY_FLAG property\r\n    optionSchema = required ? (mergeSchemas({ required }, option) as S) : option;\r\n  }\r\n\r\n  // First we will check to see if there is an anyOf/oneOf override for the UI schema\r\n  let optionsUiSchema: UiSchema<T, S, F>[] = [];\r\n  if (ONE_OF_KEY in schema && uiSchema && ONE_OF_KEY in uiSchema) {\r\n    if (Array.isArray(uiSchema[ONE_OF_KEY])) {\r\n      optionsUiSchema = uiSchema[ONE_OF_KEY];\r\n    } else {\r\n      console.warn(`uiSchema.oneOf is not an array for \"${title || name}\"`);\r\n    }\r\n  } else if (ANY_OF_KEY in schema && uiSchema && ANY_OF_KEY in uiSchema) {\r\n    if (Array.isArray(uiSchema[ANY_OF_KEY])) {\r\n      optionsUiSchema = uiSchema[ANY_OF_KEY];\r\n    } else {\r\n      console.warn(`uiSchema.anyOf is not an array for \"${title || name}\"`);\r\n    }\r\n  }\r\n  // Then we pick the one that matches the selected option index, if one exists otherwise default to the main uiSchema\r\n  let optionUiSchema = uiSchema;\r\n  if (selectedOption >= 0 && optionsUiSchema.length > selectedOption) {\r\n    optionUiSchema = optionsUiSchema[selectedOption];\r\n  }\r\n\r\n  const translateEnum: TranslatableString = title\r\n    ? TranslatableString.TitleOptionPrefix\r\n    : TranslatableString.OptionPrefix;\r\n  const translateParams = title ? [title] : [];\r\n  const enumOptions = retrievedOptions.map((opt: { title?: string }, index: number) => {\r\n    // Also see if there is an override title in the uiSchema for each option, otherwise use the title from the option\r\n    const { title: uiTitle = opt.title } = getUiOptions<T, S, F>(optionsUiSchema[index]);\r\n    return {\r\n      label: uiTitle || translateString(translateEnum, translateParams.concat(String(index + 1))),\r\n      value: index,\r\n    };\r\n  });\r\n\r\n  return (\r\n    <div className='panel panel-default panel-body'>\r\n      <div className='form-group'>\r\n        <Widget\r\n          id={getFieldId()}\r\n          name={`${name}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`}\r\n          schema={{ type: 'number', default: 0 } as S}\r\n          onChange={onOptionChange}\r\n          onBlur={onBlur}\r\n          onFocus={onFocus}\r\n          disabled={disabled || isEmpty(enumOptions)}\r\n          multiple={false}\r\n          rawErrors={rawErrors}\r\n          errorSchema={fieldErrorSchema}\r\n          value={selectedOption >= 0 ? selectedOption : undefined}\r\n          options={{ enumOptions, ...uiOptions }}\r\n          registry={registry}\r\n          formContext={formContext}\r\n          placeholder={placeholder}\r\n          autocomplete={autocomplete}\r\n          autofocus={autofocus}\r\n          label={title ?? name}\r\n          hideLabel={!displayLabel}\r\n        />\r\n      </div>\r\n      {optionSchema && <_SchemaField {...props} schema={optionSchema} uiSchema={optionUiSchema} />}\r\n    </div>\r\n  );\r\n  // }\r\n}\r\n\r\nexport default AnyOfField;","import { useState, useCallback } from 'react';\r\nimport { asNumber, FieldProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n// Matches a string that ends in a . character, optionally followed by a sequence of\r\n// digits followed by any number of 0 characters up until the end of the line.\r\n// Ensuring that there is at least one prefixed character is important so that\r\n// you don't incorrectly match against \"0\".\r\nconst trailingCharMatcherWithPrefix = /\\.([0-9]*0)*$/;\r\n\r\n// This is used for trimming the trailing 0 and . characters without affecting\r\n// the rest of the string. Its possible to use one RegEx with groups for this\r\n// functionality, but it is fairly complex compared to simply defining two\r\n// different matchers.\r\nconst trailingCharMatcher = /[0.]0*$/;\r\n\r\n/**\r\n * The NumberField class has some special handling for dealing with trailing\r\n * decimal points and/or zeroes. This logic is designed to allow trailing values\r\n * to be visible in the input element, but not be represented in the\r\n * corresponding form data.\r\n *\r\n * The algorithm is as follows:\r\n *\r\n * 1. When the input value changes the value is cached in the component state\r\n *\r\n * 2. The value is then normalized, removing trailing decimal points and zeros,\r\n *    then passed to the \"onChange\" callback\r\n *\r\n * 3. When the component is rendered, the formData value is checked against the\r\n *    value cached in the state. If it matches the cached value, the cached\r\n *    value is passed to the input instead of the formData value\r\n */\r\nfunction NumberField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const { registry, onChange, formData, value: initialValue } = props;\r\n  const [lastValue, setLastValue] = useState(initialValue);\r\n  const { StringField } = registry.fields;\r\n\r\n  let value = formData;\r\n\r\n  /** Handle the change from the `StringField` to properly convert to a number\r\n   *\r\n   * @param value - The current value for the change occurring\r\n   */\r\n  const handleChange = useCallback(\r\n    (value: FieldProps<T, S, F>['value']) => {\r\n      // Cache the original value in component state\r\n      setLastValue(value);\r\n\r\n      // Normalize decimals that don't start with a zero character in advance so\r\n      // that the rest of the normalization logic is simpler\r\n      if (`${value}`.charAt(0) === '.') {\r\n        value = `0${value}`;\r\n      }\r\n\r\n      // Check that the value is a string (this can happen if the widget used is a\r\n      // <select>, due to an enum declaration etc) then, if the value ends in a\r\n      // trailing decimal point or multiple zeroes, strip the trailing values\r\n      const processed =\r\n        typeof value === 'string' && value.match(trailingCharMatcherWithPrefix)\r\n          ? asNumber(value.replace(trailingCharMatcher, ''))\r\n          : asNumber(value);\r\n\r\n      onChange(processed as unknown as T);\r\n    },\r\n    [onChange]\r\n  );\r\n\r\n  if (typeof lastValue === 'string' && typeof value === 'number') {\r\n    // Construct a regular expression that checks for a string that consists\r\n    // of the formData value suffixed with zero or one '.' characters and zero\r\n    // or more '0' characters\r\n    const re = new RegExp(`^(${String(value).replace('.', '\\\\.')})?\\\\.?0*$`);\r\n\r\n    // If the cached \"lastValue\" is a match, use that instead of the formData\r\n    // value to prevent the input value from changing in the UI\r\n    if (lastValue.match(re)) {\r\n      value = lastValue as unknown as T;\r\n    }\r\n  }\r\n\r\n  return <StringField {...props} formData={value} onChange={handleChange} />;\r\n}\r\n\r\nexport default NumberField;\r\n","import { ComponentType, useState } from 'react';\r\nimport {\r\n  getTemplate,\r\n  getUiOptions,\r\n  orderProperties,\r\n  ErrorSchema,\r\n  FieldProps,\r\n  FormContextType,\r\n  GenericObjectType,\r\n  IdSchema,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  ANY_OF_KEY,\r\n  ONE_OF_KEY,\r\n} from '@react-jsf/utils';\r\nimport Markdown from 'markdown-to-jsx';\r\nimport get from 'lodash-es/get';\r\nimport has from 'lodash-es/has';\r\nimport isObject from 'lodash-es/isObject';\r\nimport set from 'lodash-es/set';\r\nimport unset from 'lodash-es/unset';\r\n\r\n/** Type used for the state of the `ObjectField` component */\r\ntype ObjectFieldState = {\r\n  /** Flag indicating whether an additional property key was modified */\r\n  wasPropertyKeyModified: boolean;\r\n  /** The set of additional properties */\r\n  additionalProperties: object;\r\n};\r\n\r\nfunction ObjectField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const {\r\n    schema: rawSchema,\r\n    uiSchema = {},\r\n    formData,\r\n    errorSchema,\r\n    idSchema,\r\n    name,\r\n    required = false,\r\n    disabled,\r\n    readonly,\r\n    hideError,\r\n    idPrefix,\r\n    idSeparator,\r\n    onBlur,\r\n    onFocus,\r\n    registry,\r\n    title,\r\n    onChange\r\n  } = props;\r\n  \r\n  const { fields, formContext, schemaUtils, translateString, globalUiOptions } = registry;\r\n  \r\n  const { SchemaField } = fields;\r\n  const [state, setState] = useState<ObjectFieldState>({\r\n    wasPropertyKeyModified: false,\r\n    additionalProperties: {},\r\n  });\r\n\r\n  /** Returns a flag indicating whether the `name` field is required in the object schema\r\n   *\r\n   * @param name - The name of the field to check for required-ness\r\n   * @returns - True if the field `name` is required, false otherwise\r\n   */\r\n  function isRequired(name: string) {\r\n    return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;\r\n  }\r\n\r\n  /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting\r\n   * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated\r\n   * formData.\r\n   *\r\n   * @param name - The name of the property\r\n   * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property\r\n   * @returns - The onPropertyChange callback for the `name` property\r\n   */\r\n  const onPropertyChange = (name: string, addedByAdditionalProperties = false) => {\r\n    return (value: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\r\n      \r\n      if (value === undefined && addedByAdditionalProperties) {\r\n        // Don't set value = undefined for fields added by\r\n        // additionalProperties. Doing so removes them from the\r\n        // formData, which causes them to completely disappear\r\n        // (including the input field for the property name). Unlike\r\n        // fields which are \"mandated\" by the schema, these fields can\r\n        // be set to undefined by clicking a \"delete field\" button, so\r\n        // set empty values to the empty string.\r\n        value = '' as unknown as T;\r\n      }\r\n      const newFormData = { ...formData, [name]: value } as unknown as T;\r\n      onChange(\r\n        newFormData,\r\n        errorSchema &&\r\n          errorSchema && {\r\n            ...errorSchema,\r\n            [name]: newErrorSchema,\r\n          },\r\n        id\r\n      );\r\n    };\r\n  };\r\n\r\n  /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data\r\n   * and calls the `onChange` callback with it\r\n   *\r\n   * @param key - The key for which the drop callback is desired\r\n   * @returns - The drop property click callback\r\n   */\r\n  const onDropPropertyClick = (key: string) => {\r\n    return (event: DragEvent) => {\r\n      event.preventDefault();\r\n      const copiedFormData = { ...formData } as T;\r\n      unset(copiedFormData, key);\r\n      onChange(copiedFormData);\r\n    };\r\n  };\r\n\r\n  /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one\r\n   * that is already not assigned is found.\r\n   *\r\n   * @param preferredKey - The preferred name of a new key\r\n   * @param [formData] - The form data in which to check if the desired key already exists\r\n   * @returns - The name of the next available key from `preferredKey`\r\n   */\r\n  const getAvailableKey = (preferredKey: string, formData?: T) => {\r\n    const { duplicateKeySuffixSeparator = '-' } = getUiOptions<T, S, F>(uiSchema, registry.globalUiOptions);\r\n\r\n    let index = 0;\r\n    let newKey = preferredKey;\r\n    while (has(formData, newKey)) {\r\n      newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;\r\n    }\r\n    return newKey;\r\n  };\r\n\r\n  /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That\r\n   * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.\r\n   *\r\n   * @param oldValue - The old value of a field\r\n   * @returns - The key change callback function\r\n   */\r\n  const onKeyChange = (oldValue: any) => {\r\n    return (value: any, newErrorSchema: ErrorSchema<T>) => {\r\n      if (oldValue === value) {\r\n        return;\r\n      }\r\n      const { formData, onChange, errorSchema } = props;\r\n\r\n      value = getAvailableKey(value, formData);\r\n      const newFormData: GenericObjectType = {\r\n        ...(formData as GenericObjectType),\r\n      };\r\n      const newKeys: GenericObjectType = { [oldValue]: value };\r\n      const keyValues = Object.keys(newFormData).map((key) => {\r\n        const newKey = newKeys[key] || key;\r\n        return { [newKey]: newFormData[key] };\r\n      });\r\n      const renamedObj = Object.assign({}, ...keyValues);\r\n\r\n      setState({ \r\n        ...state,\r\n        wasPropertyKeyModified: true \r\n      });\r\n\r\n      onChange(\r\n        renamedObj,\r\n        errorSchema &&\r\n          errorSchema && {\r\n            ...errorSchema,\r\n            [value]: newErrorSchema,\r\n          }\r\n      );\r\n    };\r\n  };\r\n\r\n  /** Returns a default value to be used for a new additional schema property of the given `type`\r\n   *\r\n   * @param type - The type of the new additional schema property\r\n   */\r\n  function getDefaultValue(type?: RJSFSchema['type']) {\r\n    switch (type) {\r\n      case 'array':\r\n        return [];\r\n      case 'boolean':\r\n        return false;\r\n      case 'null':\r\n        return null;\r\n      case 'number':\r\n        return 0;\r\n      case 'object':\r\n        return {};\r\n      case 'string':\r\n      default:\r\n        // We don't have a datatype for some reason (perhaps additionalProperties was true)\r\n        return translateString(TranslatableString.NewStringDefault);\r\n    }\r\n  }\r\n\r\n  /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new\r\n   * default data for that field has been added to the formData.\r\n   *\r\n   * @param schema - The schema element to which the new property is being added\r\n   */\r\n  const handleAddClick = (schema: S) => () => {\r\n    if (!schema.additionalProperties) {\r\n      return;\r\n    }\r\n    const newFormData = { ...formData } as T;\r\n\r\n    let type: RJSFSchema['type'] = undefined;\r\n    let defaultValue: RJSFSchema['default'] = undefined;\r\n    if (isObject(schema.additionalProperties)) {\r\n      type = schema.additionalProperties.type;\r\n      defaultValue = schema.additionalProperties.default;\r\n      let apSchema = schema.additionalProperties;\r\n      if (REF_KEY in apSchema) {\r\n        const { schemaUtils } = registry;\r\n        apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[REF_KEY] } as S, formData);\r\n        type = apSchema.type;\r\n        defaultValue = apSchema.default;\r\n      }\r\n      if (!type && (ANY_OF_KEY in apSchema || ONE_OF_KEY in apSchema)) {\r\n        type = 'object';\r\n      }\r\n    }\r\n\r\n    const newKey = getAvailableKey('newKey', newFormData);\r\n    // Cast this to make the `set` work properly\r\n    set(newFormData as GenericObjectType, newKey, defaultValue ?? getDefaultValue(type));\r\n\r\n    onChange(newFormData);\r\n  };\r\n  \r\n  const schema: S = schemaUtils.retrieveSchema(rawSchema, formData);\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\r\n  const { properties: schemaProperties = {} } = schema;\r\n\r\n  const templateTitle = uiOptions.title ?? schema.title ?? title ?? name;\r\n  const description = uiOptions.description ?? schema.description;\r\n  let orderedProperties: string[];\r\n  try {\r\n    const properties = Object.keys(schemaProperties);\r\n    orderedProperties = orderProperties(properties, uiOptions.order);\r\n  } catch (err) {\r\n    return (\r\n      <div>\r\n        <p className='config-error' style={{ color: 'red' }}>\r\n          <Markdown options={{ disableParsingRawHTML: true }}>\r\n            {translateString(TranslatableString.InvalidObjectField, [name || 'root', (err as Error).message])}\r\n          </Markdown>\r\n        </p>\r\n        <pre>{JSON.stringify(schema)}</pre>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const Template = getTemplate<'ObjectFieldTemplate', T, S, F>('ObjectFieldTemplate', registry, uiOptions);\r\n\r\n  const templateProps = {\r\n    // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`\r\n    title: uiOptions.label === false ? '' : templateTitle,\r\n    description: uiOptions.label === false ? undefined : description,\r\n    properties: orderedProperties.map((name) => {\r\n    const addedByAdditionalProperties = has(schema, [PROPERTIES_KEY, name, ADDITIONAL_PROPERTY_FLAG]);\r\n    const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];\r\n    const hidden = getUiOptions<T, S, F>(fieldUiSchema).widget === 'hidden';\r\n    const fieldIdSchema: IdSchema<T> = get(idSchema, [name], {});\r\n\r\n    const Field: ComponentType<FieldProps<T, S, F>> = SchemaField as ComponentType<FieldProps<T, S, F>>;\r\n    const fieldSchema: S = get(schema, [PROPERTIES_KEY, name], {}) as S;\r\n        \r\n    return {\r\n          content: (\r\n            <Field\r\n              key={name}\r\n              name={name}\r\n              required={isRequired(name)}\r\n              schema={fieldSchema}\r\n              uiSchema={fieldUiSchema}\r\n              errorSchema={get(errorSchema, name)}\r\n              idSchema={fieldIdSchema}\r\n              idPrefix={idPrefix}\r\n              idSeparator={idSeparator}\r\n              formData={get(formData, name)}\r\n              formContext={formContext}\r\n              wasPropertyKeyModified={state.wasPropertyKeyModified}\r\n              onKeyChange={onKeyChange(name)}\r\n              onChange={onPropertyChange(name, addedByAdditionalProperties)}\r\n              onBlur={onBlur}\r\n              onFocus={onFocus}\r\n              registry={registry}\r\n              disabled={disabled}\r\n              readonly={readonly}\r\n              hideError={hideError}\r\n              onDropPropertyClick={onDropPropertyClick}\r\n            />\r\n          ),\r\n          name,\r\n          readonly,\r\n          disabled,\r\n          required,\r\n          hidden,\r\n        };\r\n      }),\r\n      readonly,\r\n      disabled,\r\n      required,\r\n      idSchema,\r\n      uiSchema,\r\n      errorSchema,\r\n      schema,\r\n      formData,\r\n      formContext,\r\n      registry,\r\n    };\r\n    return <Template {...templateProps} onAddClick={handleAddClick} />;\r\n  \r\n}\r\n\r\nexport default ObjectField;","import { GenericObjectType } from './types';\r\n\r\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\r\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\r\n  if (!Array.isArray(order)) {\r\n    return properties;\r\n  }\r\n\r\n  const arrayToHash = (arr: string[]) =>\r\n    arr.reduce((prev: GenericObjectType, curr) => {\r\n      prev[curr] = true;\r\n      return prev;\r\n    }, {});\r\n  const errorPropList = (arr: string[]) =>\r\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\r\n  const propertyHash = arrayToHash(properties);\r\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\r\n  const orderHash = arrayToHash(orderFiltered);\r\n\r\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\r\n  const restIndex = orderFiltered.indexOf('*');\r\n  if (restIndex === -1) {\r\n    if (rest.length) {\r\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\r\n    }\r\n    return orderFiltered;\r\n  }\r\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\r\n    throw new Error('uiSchema order list contains more than one wildcard item');\r\n  }\r\n\r\n  const complete = [...orderFiltered];\r\n  complete.splice(restIndex, 1, ...rest);\r\n  return complete;\r\n}\r\n","import { ComponentType, useCallback } from 'react';\r\nimport {\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  descriptionId,\r\n  ErrorSchema,\r\n  FieldProps,\r\n  FieldTemplateProps,\r\n  FormContextType,\r\n  getSchemaType,\r\n  getTemplate,\r\n  getUiOptions,\r\n  ID_KEY,\r\n  IdSchema,\r\n  mergeObjects,\r\n  Registry,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  UI_OPTIONS_KEY,\r\n  UIOptionsType,\r\n} from '@react-jsf/utils';\r\nimport isObject from 'lodash-es/isObject';\r\nimport omit from 'lodash-es/omit';\r\nimport Markdown from 'markdown-to-jsx';\r\n\r\n/** The map of component type to FieldName */\r\nconst COMPONENT_TYPES: { [key: string]: string } = {\r\n  array: 'ArrayField',\r\n  boolean: 'BooleanField',\r\n  integer: 'NumberField',\r\n  number: 'NumberField',\r\n  object: 'ObjectField',\r\n  string: 'StringField',\r\n  null: 'NullField',\r\n};\r\n\r\n/** Computes and returns which `Field` implementation to return in order to render the field represented by the\r\n * `schema`. The `uiOptions` are used to alter what potential `Field` implementation is actually returned. If no\r\n * appropriate `Field` implementation can be found then a wrapper around `UnsupportedFieldTemplate` is used.\r\n *\r\n * @param schema - The schema from which to obtain the type\r\n * @param uiOptions - The UI Options that may affect the component decision\r\n * @param idSchema - The id that is passed to the `UnsupportedFieldTemplate`\r\n * @param registry - The registry from which fields and templates are obtained\r\n * @returns - The `Field` component that is used to render the actual field data\r\n */\r\nfunction getFieldComponent<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: S,\r\n  uiOptions: UIOptionsType<T, S, F>,\r\n  idSchema: IdSchema<T>,\r\n  registry: Registry<T, S, F>\r\n) {\r\n  const field = uiOptions.field;\r\n  const { fields, translateString } = registry;\r\n  if (typeof field === 'function') {\r\n    return field;\r\n  }\r\n  if (typeof field === 'string' && field in fields) {\r\n    return fields[field];\r\n  }\r\n\r\n  const schemaType = getSchemaType(schema);\r\n  const type: string = Array.isArray(schemaType) ? schemaType[0] : schemaType || '';\r\n\r\n  const schemaId = schema.$id;\r\n\r\n  let componentName = COMPONENT_TYPES[type];\r\n  if (schemaId && schemaId in fields) {\r\n    componentName = schemaId;\r\n  }\r\n\r\n  // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't\r\n  // render a field and let the MultiSchemaField component handle the form display\r\n  if (!componentName && (schema.anyOf || schema.oneOf)) {\r\n    return () => null;\r\n  }\r\n\r\n  return componentName in fields\r\n    ? fields[componentName]\r\n    : () => {\r\n        const UnsupportedFieldTemplate = getTemplate<'UnsupportedFieldTemplate', T, S, F>(\r\n          'UnsupportedFieldTemplate',\r\n          registry,\r\n          uiOptions\r\n        );\r\n\r\n        return (\r\n          <UnsupportedFieldTemplate\r\n            schema={schema}\r\n            idSchema={idSchema}\r\n            reason={translateString(TranslatableString.UnknownFieldType, [String(schema.type)])}\r\n            registry={registry}\r\n          />\r\n        );\r\n      };\r\n}\r\n\r\n/** The `SchemaFieldRender` component is the work-horse of react-jsonschema-form, determining what kind of real field to\r\n * render based on the `schema`, `uiSchema` and all the other props. It also deals with rendering the `anyOf` and\r\n * `oneOf` fields.\r\n *\r\n * @param props - The `FieldProps` for this component\r\n */\r\nfunction SchemaFieldRender<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const {\r\n    schema: _schema,\r\n    idSchema: _idSchema,\r\n    uiSchema,\r\n    formData,\r\n    errorSchema,\r\n    idPrefix,\r\n    idSeparator,\r\n    name,\r\n    onChange,\r\n    onKeyChange,\r\n    onDropPropertyClick,\r\n    required,\r\n    registry,\r\n    wasPropertyKeyModified = false,\r\n  } = props;\r\n  const { formContext, schemaUtils, globalUiOptions } = registry;\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalUiOptions);\r\n  const FieldTemplate = getTemplate<'FieldTemplate', T, S, F>('FieldTemplate', registry, uiOptions);\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  const FieldHelpTemplate = getTemplate<'FieldHelpTemplate', T, S, F>('FieldHelpTemplate', registry, uiOptions);\r\n  const FieldErrorTemplate = getTemplate<'FieldErrorTemplate', T, S, F>('FieldErrorTemplate', registry, uiOptions);\r\n  const schema = schemaUtils.retrieveSchema(_schema, formData);\r\n  const fieldId = _idSchema[ID_KEY];\r\n  const idSchema = mergeObjects(\r\n    schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator),\r\n    _idSchema\r\n  ) as IdSchema<T>;\r\n\r\n  /** Intermediary `onChange` handler for field components that will inject the `id` of the current field into the\r\n   * `onChange` chain if it is not already being provided from a deeper level in the hierarchy\r\n   */\r\n  const handleFieldComponentChange = useCallback(\r\n    (formData: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\r\n      const theId = id || fieldId;\r\n      return onChange(formData, newErrorSchema, theId);\r\n    },\r\n    [fieldId, onChange]\r\n  );\r\n\r\n  const FieldComponent = getFieldComponent<T, S, F>(schema, uiOptions, idSchema, registry) as ComponentType;\r\n  const disabled = Boolean(uiOptions.disabled ?? props.disabled);\r\n  const readonly = Boolean(uiOptions.readonly ?? (props.readonly || props.schema.readOnly || schema.readOnly));\r\n  const uiSchemaHideError = uiOptions.hideError;\r\n  // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children\r\n  const hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);\r\n  const autofocus = Boolean(uiOptions.autofocus ?? props.autofocus);\r\n  if (Object.keys(schema).length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n\r\n  const { __errors, ...fieldErrorSchema } = errorSchema || {};\r\n  // See #439: uiSchema: Don't pass consumed class names or style to child components\r\n  const fieldUiSchema = omit(uiSchema, ['ui:classNames', 'classNames', 'ui:style']);\r\n  if (UI_OPTIONS_KEY in fieldUiSchema) {\r\n    fieldUiSchema[UI_OPTIONS_KEY] = omit(fieldUiSchema[UI_OPTIONS_KEY], ['classNames', 'style']);\r\n  } \r\n  const TheFieldComponent = FieldComponent as ComponentType<FieldProps<T, S, F>>;\r\n  const field = (\r\n    <TheFieldComponent\r\n      {...props}\r\n      onChange={handleFieldComponentChange}\r\n      idSchema={idSchema}\r\n      schema={schema}\r\n      uiSchema={fieldUiSchema}\r\n      disabled={disabled}\r\n      readonly={readonly}\r\n      hideError={hideError}\r\n      autofocus={autofocus}\r\n      errorSchema={fieldErrorSchema as ErrorSchema} \r\n      formContext={formContext}\r\n      rawErrors={__errors}\r\n    />\r\n  );\r\n\r\n  const id = idSchema[ID_KEY];\r\n\r\n  // If this schema has a title defined, but the user has set a new key/label, retain their input.\r\n  let label;\r\n  if (wasPropertyKeyModified) {\r\n    label = name;\r\n  } else {\r\n    label =\r\n      ADDITIONAL_PROPERTY_FLAG in schema\r\n        ? name\r\n        : uiOptions.title || props.schema.title || schema.title || props.title || name;\r\n  }\r\n\r\n  const description = uiOptions.description || props.schema.description || schema.description || '';\r\n\r\n  const richDescription = uiOptions.enableMarkdownInDescription ? (\r\n    <Markdown options={{ disableParsingRawHTML: true }}>{description}</Markdown>\r\n  ) : (\r\n    description\r\n  );\r\n  const help = uiOptions.help;\r\n  const hidden = uiOptions.widget === 'hidden';\r\n\r\n  const classNames = ['form-group', 'field', `field-${getSchemaType(schema)}`];\r\n  if (!hideError && __errors && __errors.length > 0) {\r\n    classNames.push('field-error has-error has-danger');\r\n  }\r\n  if (uiSchema?.classNames) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      console.warn(\r\n        \"'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead.\"\r\n      );\r\n    }\r\n    classNames.push(uiSchema.classNames);\r\n  }\r\n  if (uiOptions.classNames) {\r\n    classNames.push(uiOptions.classNames);\r\n  }\r\n\r\n  const helpComponent = (\r\n    <FieldHelpTemplate\r\n      help={help}\r\n      idSchema={idSchema}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      hasErrors={!hideError && __errors && __errors.length > 0}\r\n      registry={registry}\r\n    />\r\n  );\r\n  /*\r\n   * AnyOf/OneOf errors handled by child schema\r\n   * unless it can be rendered as select control\r\n   */\r\n  const errorsComponent =\r\n    hideError || ((schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema)) ? undefined : (\r\n      <FieldErrorTemplate\r\n        errors={__errors}\r\n        errorSchema={errorSchema}\r\n        idSchema={idSchema}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n      />\r\n    );\r\n  const fieldProps: Omit<FieldTemplateProps<T, S, F>, 'children'> = {\r\n    description: (\r\n      <DescriptionFieldTemplate\r\n        id={descriptionId<T>(id)}\r\n        description={richDescription}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n      />\r\n    ),\r\n    rawDescription: description,\r\n    help: helpComponent,\r\n    rawHelp: typeof help === 'string' ? help : undefined,\r\n    errors: errorsComponent,\r\n    rawErrors: hideError ? undefined : __errors,\r\n    id,\r\n    label,\r\n    hidden,\r\n    onChange,\r\n    onKeyChange,\r\n    onDropPropertyClick,\r\n    required,\r\n    disabled,\r\n    readonly,\r\n    hideError,\r\n    displayLabel,\r\n    classNames: classNames.join(' ').trim(),\r\n    style: uiOptions.style,\r\n    formContext,\r\n    formData,\r\n    schema,\r\n    uiSchema,\r\n    registry,\r\n  };\r\n\r\n  const _AnyOfField = registry.fields.AnyOfField;\r\n  const _OneOfField = registry.fields.OneOfField;\r\n  const isReplacingAnyOrOneOf = uiSchema?.['ui:field'] && uiSchema?.['ui:fieldReplacesAnyOrOneOf'] === true;\r\n\r\n  return (\r\n    <FieldTemplate {...fieldProps}>\r\n      <>\r\n        {field}\r\n        {/*\r\n        If the schema `anyOf` or 'oneOf' can be rendered as a select control, don't\r\n        render the selection and let `StringField` component handle\r\n        rendering\r\n      */}\r\n        {schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && (\r\n          <_AnyOfField\r\n            name={name}\r\n            disabled={disabled}\r\n            readonly={readonly}\r\n            hideError={hideError}\r\n            errorSchema={errorSchema}\r\n            formData={formData}\r\n            formContext={formContext}\r\n            idPrefix={idPrefix}\r\n            idSchema={idSchema}\r\n            idSeparator={idSeparator}\r\n            onBlur={props.onBlur}\r\n            onChange={props.onChange}\r\n            onFocus={props.onFocus}\r\n            options={schema.anyOf.map((_schema) =>\r\n              schemaUtils.retrieveSchema(isObject(_schema) ? (_schema as S) : ({} as S), formData)\r\n            )}\r\n            registry={registry}\r\n            schema={schema}\r\n            uiSchema={uiSchema}\r\n          />\r\n        )}\r\n        {schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && (\r\n          <_OneOfField\r\n            name={name}\r\n            disabled={disabled}\r\n            readonly={readonly}\r\n            hideError={hideError}\r\n            errorSchema={errorSchema}\r\n            formData={formData}\r\n            formContext={formContext}\r\n            idPrefix={idPrefix}\r\n            idSchema={idSchema}\r\n            idSeparator={idSeparator}\r\n            onBlur={props.onBlur}\r\n            onChange={props.onChange}\r\n            onFocus={props.onFocus}\r\n            options={schema.oneOf.map((_schema) =>\r\n              schemaUtils.retrieveSchema(isObject(_schema) ? (_schema as S) : ({} as S), formData)\r\n            )}\r\n            registry={registry}\r\n            schema={schema}\r\n            uiSchema={uiSchema}\r\n          />\r\n        )}\r\n      </>\r\n    </FieldTemplate>\r\n  );\r\n}\r\n\r\n// function shouldComponentUpdate<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(props: Readonly<FieldProps<T, S, F>>, nextProps: Readonly<FieldProps<T, S, F>>) {\r\n//   return !deepEquals(props, nextProps);\r\n// }\r\n\r\n\r\nfunction SchemaField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  return <SchemaFieldRender<T, S, F> {...props} />;\r\n}\r\n\r\n// export default React.memo(SchemaField, shouldComponentUpdate);\r\nexport default SchemaField;","import {\r\n  getWidget,\r\n  getUiOptions,\r\n  optionsList,\r\n  hasWidget,\r\n  FieldProps,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `StringField` component is used to render a schema field that represents a string type\r\n *\r\n * @param props - The `FieldProps` for this template\r\n */\r\nfunction StringField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const {\r\n    schema,\r\n    name,\r\n    uiSchema,\r\n    idSchema,\r\n    formData,\r\n    required,\r\n    disabled = false,\r\n    readonly = false,\r\n    autofocus = false,\r\n    onChange,\r\n    onBlur,\r\n    onFocus,\r\n    registry,\r\n    rawErrors,\r\n    hideError,\r\n  } = props;\r\n  const { title, format } = schema;\r\n  const { widgets, formContext, schemaUtils, globalUiOptions } = registry;\r\n  const enumOptions = schemaUtils.isSelect(schema) ? optionsList<S, T, F>(schema, uiSchema) : undefined;\r\n  let defaultWidget = enumOptions ? 'select' : 'text';\r\n  if (format && hasWidget<T, S, F>(schema, format, widgets)) {\r\n    defaultWidget = format;\r\n  }\r\n  const { widget = defaultWidget, placeholder = '', title: uiTitle, ...options } = getUiOptions<T, S, F>(uiSchema);\r\n  const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);\r\n  const label = uiTitle ?? title ?? name;\r\n  const Widget = getWidget<T, S, F>(schema, widget, widgets);\r\n  return (\r\n    <Widget\r\n      options={{ ...options, enumOptions }}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      id={idSchema.$id}\r\n      name={name}\r\n      label={label}\r\n      hideLabel={!displayLabel}\r\n      hideError={hideError}\r\n      value={formData}\r\n      onChange={onChange}\r\n      onBlur={onBlur}\r\n      onFocus={onFocus}\r\n      required={required}\r\n      disabled={disabled}\r\n      readonly={readonly}\r\n      formContext={formContext}\r\n      autofocus={autofocus}\r\n      registry={registry}\r\n      placeholder={placeholder}\r\n      rawErrors={rawErrors}\r\n    />\r\n  );\r\n}\r\n\r\nexport default StringField;\r\n","import getWidget from './getWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\r\n\r\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\r\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n) {\r\n  try {\r\n    getWidget(schema, widget, registeredWidgets);\r\n    return true;\r\n  } catch (e) {\r\n    const err: Error = e as Error;\r\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n","import { useEffect } from 'react';\r\nimport { FieldProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The `NullField` component is used to render a field in the schema is null. It also ensures that the `formData` is\r\n * also set to null if it has no value.\r\n *\r\n * @param props - The `FieldProps` for this template\r\n */\r\nfunction NullField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: FieldProps<T, S, F>\r\n) {\r\n  const { formData, onChange } = props;\r\n  useEffect(() => {\r\n    if (formData === undefined) {\r\n      onChange(null as unknown as T);\r\n    }\r\n  }, [formData, onChange]);\r\n\r\n  return null;\r\n}\r\n\r\nexport default NullField;\r\n","import { Field, FormContextType, RegistryFieldsType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nimport ArrayField from './ArrayField';\r\nimport BooleanField from './BooleanField';\r\nimport MultiSchemaField from './MultiSchemaField';\r\nimport NumberField from './NumberField';\r\nimport ObjectField from './ObjectField';\r\nimport SchemaField from './SchemaField';\r\nimport StringField from './StringField';\r\nimport NullField from './NullField';\r\n\r\nfunction fields<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): RegistryFieldsType<T, S, F> {\r\n  return {\r\n    AnyOfField: MultiSchemaField,\r\n    ArrayField: ArrayField as unknown as Field<T, S, F>,\r\n    // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default\r\n    BooleanField,\r\n    NumberField,\r\n    ObjectField,\r\n    OneOfField: MultiSchemaField,\r\n    SchemaField,\r\n    StringField,\r\n    NullField,\r\n  };\r\n}\r\n\r\nexport default fields;\r\n","import {\r\n  descriptionId,\r\n  getTemplate,\r\n  getUiOptions,\r\n  ArrayFieldDescriptionProps,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `ArrayFieldDescriptionTemplate` component renders a `DescriptionFieldTemplate` with an `id` derived from\r\n * the `idSchema`.\r\n *\r\n * @param props - The `ArrayFieldDescriptionProps` for the component\r\n */\r\nexport default function ArrayFieldDescriptionTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldDescriptionProps<T, S, F>) {\r\n  const { idSchema, description, registry, schema, uiSchema } = props;\r\n  const options = getUiOptions<T, S, F>(uiSchema, registry.globalUiOptions);\r\n  const { label: displayLabel = true } = options;\r\n  if (!description || !displayLabel) {\r\n    return null;\r\n  }\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    options\r\n  );\r\n  return (\r\n    <DescriptionFieldTemplate\r\n      id={descriptionId<T>(idSchema)}\r\n      description={description}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      registry={registry}\r\n    />\r\n  );\r\n}\r\n","import { CSSProperties } from 'react';\r\nimport { ArrayFieldTemplateItemType, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The `ArrayFieldItemTemplate` component is the template used to render an items of an array.\r\n *\r\n * @param props - The `ArrayFieldTemplateItemType` props for the component\r\n */\r\nexport default function ArrayFieldItemTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldTemplateItemType<T, S, F>) {\r\n  const {\r\n    children,\r\n    className,\r\n    disabled,\r\n    hasToolbar,\r\n    hasMoveDown,\r\n    hasMoveUp,\r\n    hasRemove,\r\n    hasCopy,\r\n    index,\r\n    onCopyIndexClick,\r\n    onDropIndexClick,\r\n    onReorderClick,\r\n    readonly,\r\n    registry,\r\n    uiSchema,\r\n  } = props;\r\n  const { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;\r\n  const btnStyle: CSSProperties = {\r\n    flex: 1,\r\n    paddingLeft: 6,\r\n    paddingRight: 6,\r\n    fontWeight: 'bold',\r\n  };\r\n  return (\r\n    <div className={className}>\r\n      <div className={hasToolbar ? 'col-xs-9' : 'col-xs-12'}>{children}</div>\r\n      {hasToolbar && (\r\n        <div className='col-xs-3 array-item-toolbox'>\r\n          <div\r\n            className='btn-group'\r\n            style={{\r\n              display: 'flex',\r\n              justifyContent: 'space-around',\r\n            }}\r\n          >\r\n            {(hasMoveUp || hasMoveDown) && (\r\n              <MoveUpButton\r\n                style={btnStyle}\r\n                disabled={disabled || readonly || !hasMoveUp}\r\n                onClick={onReorderClick(index, index - 1)}\r\n                uiSchema={uiSchema}\r\n                registry={registry}\r\n              />\r\n            )}\r\n            {(hasMoveUp || hasMoveDown) && (\r\n              <MoveDownButton\r\n                style={btnStyle}\r\n                disabled={disabled || readonly || !hasMoveDown}\r\n                onClick={onReorderClick(index, index + 1)}\r\n                uiSchema={uiSchema}\r\n                registry={registry}\r\n              />\r\n            )}\r\n            {hasCopy && (\r\n              <CopyButton\r\n                style={btnStyle}\r\n                disabled={disabled || readonly}\r\n                onClick={onCopyIndexClick(index)}\r\n                uiSchema={uiSchema}\r\n                registry={registry}\r\n              />\r\n            )}\r\n            {hasRemove && (\r\n              <RemoveButton\r\n                style={btnStyle}\r\n                disabled={disabled || readonly}\r\n                onClick={onDropIndexClick(index)}\r\n                uiSchema={uiSchema}\r\n                registry={registry}\r\n              />\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n","import {\r\n  getTemplate,\r\n  getUiOptions,\r\n  ArrayFieldTemplateProps,\r\n  ArrayFieldTemplateItemType,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `ArrayFieldTemplate` component is the template used to render all items in an array.\r\n *\r\n * @param props - The `ArrayFieldTemplateItemType` props for the component\r\n */\r\nexport default function ArrayFieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldTemplateProps<T, S, F>) {\r\n  const {\r\n    canAdd,\r\n    className,\r\n    disabled,\r\n    idSchema,\r\n    uiSchema,\r\n    items,\r\n    onAddClick,\r\n    readonly,\r\n    registry,\r\n    required,\r\n    schema,\r\n    title,\r\n  } = props;\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  const ArrayFieldDescriptionTemplate = getTemplate<'ArrayFieldDescriptionTemplate', T, S, F>(\r\n    'ArrayFieldDescriptionTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  const ArrayFieldItemTemplate = getTemplate<'ArrayFieldItemTemplate', T, S, F>(\r\n    'ArrayFieldItemTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  const ArrayFieldTitleTemplate = getTemplate<'ArrayFieldTitleTemplate', T, S, F>(\r\n    'ArrayFieldTitleTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  // Button templates are not overridden in the uiSchema\r\n  const {\r\n    ButtonTemplates: { AddButton },\r\n  } = registry.templates;\r\n  return (\r\n    <fieldset className={className} id={idSchema.$id}>\r\n      <ArrayFieldTitleTemplate\r\n        idSchema={idSchema}\r\n        title={uiOptions.title || title}\r\n        required={required}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n      />\r\n      <ArrayFieldDescriptionTemplate\r\n        idSchema={idSchema}\r\n        description={uiOptions.description || schema.description}\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        registry={registry}\r\n      />\r\n      <div className='row array-item-list'>\r\n        {items &&\r\n          items.map(({ key, ...itemProps }: ArrayFieldTemplateItemType<T, S, F>) => (\r\n            <ArrayFieldItemTemplate key={key} {...itemProps} />\r\n          ))}\r\n      </div>\r\n      {canAdd && (\r\n        <AddButton\r\n          className='array-item-add'\r\n          onClick={onAddClick}\r\n          disabled={disabled || readonly}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n    </fieldset>\r\n  );\r\n}\r\n","import {\r\n  getTemplate,\r\n  getUiOptions,\r\n  titleId,\r\n  ArrayFieldTitleProps,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TemplatesType,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `ArrayFieldTitleTemplate` component renders a `TitleFieldTemplate` with an `id` derived from\r\n * the `idSchema`.\r\n *\r\n * @param props - The `ArrayFieldTitleProps` for the component\r\n */\r\nexport default function ArrayFieldTitleTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldTitleProps<T, S, F>) {\r\n  const { idSchema, title, schema, uiSchema, required, registry } = props;\r\n  const options = getUiOptions<T, S, F>(uiSchema, registry.globalUiOptions);\r\n  const { label: displayLabel = true } = options;\r\n  if (!title || !displayLabel) {\r\n    return null;\r\n  }\r\n  const TitleFieldTemplate: TemplatesType<T, S, F>['TitleFieldTemplate'] = getTemplate<'TitleFieldTemplate', T, S, F>(\r\n    'TitleFieldTemplate',\r\n    registry,\r\n    options\r\n  );\r\n  return (\r\n    <TitleFieldTemplate\r\n      id={titleId<T>(idSchema)}\r\n      title={title}\r\n      required={required}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      registry={registry}\r\n    />\r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent, useCallback } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  BaseInputTemplateProps,\r\n  examplesId,\r\n  getInputProps,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `BaseInputTemplate` is the template to use to render the basic `<input>` component for the `core` theme.\r\n * It is used as the template for rendering many of the <input> based widgets that differ by `type` and callbacks only.\r\n * It can be customized/overridden for other themes or individual implementations as needed.\r\n *\r\n * @param props - The `WidgetProps` for this template\r\n */\r\nexport default function BaseInputTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: BaseInputTemplateProps<T, S, F>) {\r\n  const {\r\n    id,\r\n    name, // remove this from ...rest\r\n    value,\r\n    readonly,\r\n    disabled,\r\n    autofocus,\r\n    onBlur,\r\n    onFocus,\r\n    onChange,\r\n    onChangeOverride,\r\n    options,\r\n    schema,\r\n    uiSchema,\r\n    formContext,\r\n    registry,\r\n    rawErrors,\r\n    type,\r\n    hideLabel, // remove this from ...rest\r\n    hideError, // remove this from ...rest\r\n    ...rest\r\n  } = props;\r\n\r\n  // Note: since React 15.2.0 we can't forward unknown element attributes, so we\r\n  // exclude the \"options\" and \"schema\" ones here.\r\n  if (!id) {\r\n    console.log('No id for', props);\r\n    throw new Error(`no id for props ${JSON.stringify(props)}`);\r\n  }\r\n  const inputProps = {\r\n    ...rest,\r\n    ...getInputProps<T, S, F>(schema, type, options),\r\n  };\r\n\r\n  let inputValue;\r\n  if (inputProps.type === 'number' || inputProps.type === 'integer') {\r\n    inputValue = value || value === 0 ? value : '';\r\n  } else {\r\n    inputValue = value == null ? '' : value;\r\n  }\r\n\r\n  const _onChange = useCallback(\r\n    ({ target: { value } }: ChangeEvent<HTMLInputElement>) => onChange(value === '' ? options.emptyValue : value),\r\n    [onChange, options]\r\n  );\r\n  const _onBlur = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) => onBlur(id, target && target.value),\r\n    [onBlur, id]\r\n  );\r\n  const _onFocus = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) => onFocus(id, target && target.value),\r\n    [onFocus, id]\r\n  );\r\n\r\n  return (\r\n    <>\r\n      <input\r\n        id={id}\r\n        name={id}\r\n        className='form-control'\r\n        readOnly={readonly}\r\n        disabled={disabled}\r\n        autoFocus={autofocus}\r\n        value={inputValue}\r\n        {...inputProps}\r\n        list={schema.examples ? examplesId<T>(id) : undefined}\r\n        onChange={onChangeOverride || _onChange}\r\n        onBlur={_onBlur}\r\n        onFocus={_onFocus}\r\n        aria-describedby={ariaDescribedByIds<T>(id, !!schema.examples)}\r\n      />\r\n      {Array.isArray(schema.examples) && (\r\n        <datalist key={`datalist_${id}`} id={examplesId<T>(id)}>\r\n          {(schema.examples as string[])\r\n            .concat(schema.default && !schema.examples.includes(schema.default) ? ([schema.default] as string[]) : [])\r\n            .map((example: any) => {\r\n              return <option key={example} value={example} />;\r\n            })}\r\n        </datalist>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n","import { getSubmitButtonOptions, FormContextType, RJSFSchema, StrictRJSFSchema, SubmitButtonProps } from '@react-jsf/utils';\r\n\r\n/** The `SubmitButton` renders a button that represent the `Submit` action on a form\r\n */\r\nexport default function SubmitButton<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({ uiSchema }: SubmitButtonProps<T, S, F>) {\r\n  const { submitText, norender, props: submitButtonProps = {} } = getSubmitButtonOptions<T, S, F>(uiSchema);\r\n  if (norender) {\r\n    return null;\r\n  }\r\n  return (\r\n    <div>\r\n      <button type='submit' {...submitButtonProps} className={`btn btn-info ${submitButtonProps.className || ''}`}>\r\n        {submitText}\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\n","import { FormContextType, IconButtonProps, RJSFSchema, StrictRJSFSchema, TranslatableString } from '@react-jsf/utils';\r\n\r\nexport default function IconButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const { iconType = 'default', icon, className, uiSchema, registry, ...otherProps } = props;\r\n  return (\r\n    <button type='button' className={`btn btn-${iconType} ${className}`} {...otherProps}>\r\n      <i className={`glyphicon glyphicon-${icon}`} />\r\n    </button>\r\n  );\r\n}\r\n\r\nexport function CopyButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton\r\n      title={translateString(TranslatableString.CopyButton)}\r\n      className='array-item-copy'\r\n      {...props}\r\n      icon='copy'\r\n    />\r\n  );\r\n}\r\n\r\nexport function MoveDownButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton\r\n      title={translateString(TranslatableString.MoveDownButton)}\r\n      className='array-item-move-down'\r\n      {...props}\r\n      icon='arrow-down'\r\n    />\r\n  );\r\n}\r\n\r\nexport function MoveUpButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton\r\n      title={translateString(TranslatableString.MoveUpButton)}\r\n      className='array-item-move-up'\r\n      {...props}\r\n      icon='arrow-up'\r\n    />\r\n  );\r\n}\r\n\r\nexport function RemoveButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton\r\n      title={translateString(TranslatableString.RemoveButton)}\r\n      className='array-item-remove'\r\n      {...props}\r\n      iconType='danger'\r\n      icon='remove'\r\n    />\r\n  );\r\n}\r\n","import { FormContextType, IconButtonProps, RJSFSchema, StrictRJSFSchema, TranslatableString } from '@react-jsf/utils';\r\n\r\nimport IconButton from './IconButton';\r\n\r\n/** The `AddButton` renders a button that represent the `Add` action on a form\r\n */\r\nexport default function AddButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  className,\r\n  onClick,\r\n  disabled,\r\n  registry,\r\n}: IconButtonProps<T, S, F>) {\r\n  const { translateString } = registry;\r\n  return (\r\n    <div className='row'>\r\n      <p className={`col-xs-3 col-xs-offset-9 text-right ${className}`}>\r\n        <IconButton\r\n          iconType='info'\r\n          icon='plus'\r\n          className='btn-add col-xs-12'\r\n          title={translateString(TranslatableString.AddButton)}\r\n          onClick={onClick}\r\n          disabled={disabled}\r\n          registry={registry}\r\n        />\r\n      </p>\r\n    </div>\r\n  );\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, TemplatesType } from '@react-jsf/utils';\r\n\r\nimport SubmitButton from './SubmitButton';\r\nimport AddButton from './AddButton';\r\nimport { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } from './IconButton';\r\n\r\nfunction buttonTemplates<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): TemplatesType<T, S, F>['ButtonTemplates'] {\r\n  return {\r\n    SubmitButton,\r\n    AddButton,\r\n    CopyButton,\r\n    MoveDownButton,\r\n    MoveUpButton,\r\n    RemoveButton,\r\n  };\r\n}\r\n\r\nexport default buttonTemplates;\r\n","import { DescriptionFieldProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The `DescriptionField` is the template to use to render the description of a field\r\n *\r\n * @param props - The `DescriptionFieldProps` for this component\r\n */\r\nexport default function DescriptionField<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: DescriptionFieldProps<T, S, F>) {\r\n  const { id, description } = props;\r\n  if (!description) {\r\n    return null;\r\n  }\r\n  if (typeof description === 'string') {\r\n    return (\r\n      <p id={id} className='field-description'>\r\n        {description}\r\n      </p>\r\n    );\r\n  } else {\r\n    return (\r\n      <div id={id} className='field-description'>\r\n        {description}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import {\r\n  ErrorListProps,\r\n  FormContextType,\r\n  RJSFValidationError,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `ErrorList` component is the template that renders the all the errors associated with the fields in the `Form`\r\n *\r\n * @param props - The `ErrorListProps` for this component\r\n */\r\nexport default function ErrorList<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  errors,\r\n  registry,\r\n}: ErrorListProps<T, S, F>) {\r\n  const { translateString } = registry;\r\n  return (\r\n    <div className='panel panel-danger errors'>\r\n      <div className='panel-heading'>\r\n        <h3 className='panel-title'>{translateString(TranslatableString.ErrorsLabel)}</h3>\r\n      </div>\r\n      <ul className='list-group'>\r\n        {errors.map((error: RJSFValidationError, i: number) => {\r\n          return (\r\n            <li key={i} className='list-group-item text-danger'>\r\n              {error.stack}\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","const REQUIRED_FIELD_SYMBOL = '*';\r\n\r\nexport type LabelProps = {\r\n  /** The label for the field */\r\n  label?: string;\r\n  /** A boolean value stating if the field is required */\r\n  required?: boolean;\r\n  /** The id of the input field being labeled */\r\n  id?: string;\r\n};\r\n\r\n/** Renders a label for a field\r\n *\r\n * @param props - The `LabelProps` for this component\r\n */\r\nexport default function Label(props: LabelProps) {\r\n  const { label, required, id } = props;\r\n  if (!label) {\r\n    return null;\r\n  }\r\n  return (\r\n    <label className='control-label' htmlFor={id}>\r\n      {label}\r\n      {required && <span className='required'>{REQUIRED_FIELD_SYMBOL}</span>}\r\n    </label>\r\n  );\r\n}\r\n","import FieldTemplate from './FieldTemplate';\r\n\r\nexport default FieldTemplate;\r\n","import {\r\n  FieldTemplateProps,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  getTemplate,\r\n  getUiOptions,\r\n} from '@react-jsf/utils';\r\n\r\nimport Label from './Label';\r\n\r\n/** The `FieldTemplate` component is the template used by `SchemaField` to render any field. It renders the field\r\n * content, (label, description, children, errors and help) inside of a `WrapIfAdditional` component.\r\n *\r\n * @param props - The `FieldTemplateProps` for this component\r\n */\r\nexport default function FieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: FieldTemplateProps<T, S, F>) {\r\n  const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;\r\n  const uiOptions = getUiOptions(uiSchema);\r\n  const WrapIfAdditionalTemplate = getTemplate<'WrapIfAdditionalTemplate', T, S, F>(\r\n    'WrapIfAdditionalTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  if (hidden) {\r\n    return <div className='hidden'>{children}</div>;\r\n  }\r\n  return (\r\n    <WrapIfAdditionalTemplate {...props}>\r\n      {displayLabel && <Label label={label} required={required} id={id} />}\r\n      {displayLabel && description ? description : null}\r\n      {children}\r\n      {errors}\r\n      {help}\r\n    </WrapIfAdditionalTemplate>\r\n  );\r\n}\r\n","import { errorId, FieldErrorProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The `FieldErrorTemplate` component renders the errors local to the particular field\r\n *\r\n * @param props - The `FieldErrorProps` for the errors being rendered\r\n */\r\nexport default function FieldErrorTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: FieldErrorProps<T, S, F>) {\r\n  const { errors = [], idSchema } = props;\r\n  if (errors.length === 0) {\r\n    return null;\r\n  }\r\n  const id = errorId<T>(idSchema);\r\n\r\n  return (\r\n    <div>\r\n      <ul id={id} className='error-detail bs-callout bs-callout-info'>\r\n        {errors\r\n          .filter((elem) => !!elem)\r\n          .map((error, index: number) => {\r\n            return (\r\n              <li className='text-danger' key={index}>\r\n                {error}\r\n              </li>\r\n            );\r\n          })}\r\n      </ul>\r\n    </div>\r\n  );\r\n}\r\n","import { helpId, FieldHelpProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The `FieldHelpTemplate` component renders any help desired for a field\r\n *\r\n * @param props - The `FieldHelpProps` to be rendered\r\n */\r\nexport default function FieldHelpTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: FieldHelpProps<T, S, F>) {\r\n  const { idSchema, help } = props;\r\n  if (!help) {\r\n    return null;\r\n  }\r\n  const id = helpId<T>(idSchema);\r\n  if (typeof help === 'string') {\r\n    return (\r\n      <p id={id} className='help-block'>\r\n        {help}\r\n      </p>\r\n    );\r\n  }\r\n  return (\r\n    <div id={id} className='help-block'>\r\n      {help}\r\n    </div>\r\n  );\r\n}\r\n","import {\r\n  FormContextType,\r\n  ObjectFieldTemplatePropertyType,\r\n  ObjectFieldTemplateProps,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  canExpand,\r\n  descriptionId,\r\n  getTemplate,\r\n  getUiOptions,\r\n  titleId,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `ObjectFieldTemplate` is the template to use to render all the inner properties of an object along with the\r\n * title and description if available. If the object is expandable, then an `AddButton` is also rendered after all\r\n * the properties.\r\n *\r\n * @param props - The `ObjectFieldTemplateProps` for this component\r\n */\r\nexport default function ObjectFieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ObjectFieldTemplateProps<T, S, F>) {\r\n  const {\r\n    description,\r\n    disabled,\r\n    formData,\r\n    idSchema,\r\n    onAddClick,\r\n    properties,\r\n    readonly,\r\n    registry,\r\n    required,\r\n    schema,\r\n    title,\r\n    uiSchema,\r\n  } = props;\r\n  const options = getUiOptions<T, S, F>(uiSchema);\r\n  const TitleFieldTemplate = getTemplate<'TitleFieldTemplate', T, S, F>('TitleFieldTemplate', registry, options);\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    options\r\n  );\r\n  // Button templates are not overridden in the uiSchema\r\n  const {\r\n    ButtonTemplates: { AddButton },\r\n  } = registry.templates;\r\n  return (\r\n    <fieldset id={idSchema.$id}>\r\n      {title && (\r\n        <TitleFieldTemplate\r\n          id={titleId<T>(idSchema)}\r\n          title={title}\r\n          required={required}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      {description && (\r\n        <DescriptionFieldTemplate\r\n          id={descriptionId<T>(idSchema)}\r\n          description={description}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      {properties.map((prop: ObjectFieldTemplatePropertyType) => prop.content)}\r\n      {canExpand<T, S, F>(schema, uiSchema, formData) && (\r\n        <AddButton\r\n          className='object-property-expand'\r\n          onClick={onAddClick(schema)}\r\n          disabled={disabled || readonly}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n    </fieldset>\r\n  );\r\n}\r\n","import { FormContextType, TitleFieldProps, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nconst REQUIRED_FIELD_SYMBOL = '*';\r\n\r\n/** The `TitleField` is the template to use to render the title of a field\r\n *\r\n * @param props - The `TitleFieldProps` for this component\r\n */\r\nexport default function TitleField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: TitleFieldProps<T, S, F>\r\n) {\r\n  const { id, title, required } = props;\r\n  return (\r\n    <legend id={id}>\r\n      {title}\r\n      {required && <span className='required'>{REQUIRED_FIELD_SYMBOL}</span>}\r\n    </legend>\r\n  );\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, TranslatableString, UnsupportedFieldProps } from '@react-jsf/utils';\r\nimport Markdown from 'markdown-to-jsx';\r\n\r\n/** The `UnsupportedField` component is used to render a field in the schema is one that is not supported by\r\n * react-jsonschema-form.\r\n *\r\n * @param props - The `FieldProps` for this template\r\n */\r\nfunction UnsupportedField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: UnsupportedFieldProps<T, S, F>\r\n) {\r\n  const { schema, idSchema, reason, registry } = props;\r\n  const { translateString } = registry;\r\n  let translateEnum: TranslatableString = TranslatableString.UnsupportedField;\r\n  const translateParams: string[] = [];\r\n  if (idSchema && idSchema.$id) {\r\n    translateEnum = TranslatableString.UnsupportedFieldWithId;\r\n    translateParams.push(idSchema.$id);\r\n  }\r\n  if (reason) {\r\n    translateEnum =\r\n      translateEnum === TranslatableString.UnsupportedField\r\n        ? TranslatableString.UnsupportedFieldWithReason\r\n        : TranslatableString.UnsupportedFieldWithIdAndReason;\r\n    translateParams.push(reason);\r\n  }\r\n  return (\r\n    <div className='unsupported-field'>\r\n      <p>\r\n        <Markdown options={{ disableParsingRawHTML: true }}>{translateString(translateEnum, translateParams)}</Markdown>\r\n      </p>\r\n      {schema && <pre>{JSON.stringify(schema, null, 2)}</pre>}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UnsupportedField;\r\n","import {\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  WrapIfAdditionalTemplateProps,\r\n} from '@react-jsf/utils';\r\n\r\nimport Label from './FieldTemplate/Label';\r\n\r\n/** The `WrapIfAdditional` component is used by the `FieldTemplate` to rename, or remove properties that are\r\n * part of an `additionalProperties` part of a schema.\r\n *\r\n * @param props - The `WrapIfAdditionalProps` for this component\r\n */\r\nexport default function WrapIfAdditionalTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: WrapIfAdditionalTemplateProps<T, S, F>) {\r\n  const {\r\n    id,\r\n    classNames,\r\n    style,\r\n    disabled,\r\n    label,\r\n    onKeyChange,\r\n    onDropPropertyClick,\r\n    readonly,\r\n    required,\r\n    schema,\r\n    children,\r\n    uiSchema,\r\n    registry,\r\n  } = props;\r\n  const { templates, translateString } = registry;\r\n  // Button templates are not overridden in the uiSchema\r\n  const { RemoveButton } = templates.ButtonTemplates;\r\n  const keyLabel = translateString(TranslatableString.KeyLabel, [label]);\r\n  const additional = ADDITIONAL_PROPERTY_FLAG in schema;\r\n\r\n  if (!additional) {\r\n    return (\r\n      <div className={classNames} style={style}>\r\n        {children}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className={classNames} style={style}>\r\n      <div className='row'>\r\n        <div className='col-xs-5 form-additional'>\r\n          <div className='form-group'>\r\n            <Label label={keyLabel} required={required} id={`${id}-key`} />\r\n            <input\r\n              className='form-control'\r\n              type='text'\r\n              id={`${id}-key`}\r\n              onBlur={({ target }) => onKeyChange(target && target.value)}\r\n              defaultValue={label}\r\n            />\r\n          </div>\r\n        </div>\r\n        <div className='form-additional form-group col-xs-5'>{children}</div>\r\n        <div className='col-xs-2'>\r\n          <RemoveButton\r\n            className='array-item-remove btn-block'\r\n            style={{ border: '0' }}\r\n            disabled={disabled || readonly}\r\n            onClick={onDropPropertyClick(label)}\r\n            uiSchema={uiSchema}\r\n            registry={registry}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, TemplatesType } from '@react-jsf/utils';\r\n\r\nimport ArrayFieldDescriptionTemplate from './ArrayFieldDescriptionTemplate';\r\nimport ArrayFieldItemTemplate from './ArrayFieldItemTemplate';\r\nimport ArrayFieldTemplate from './ArrayFieldTemplate';\r\nimport ArrayFieldTitleTemplate from './ArrayFieldTitleTemplate';\r\nimport BaseInputTemplate from './BaseInputTemplate';\r\nimport ButtonTemplates from './ButtonTemplates';\r\nimport DescriptionField from './DescriptionField';\r\nimport ErrorList from './ErrorList';\r\nimport FieldTemplate from './FieldTemplate';\r\nimport FieldErrorTemplate from './FieldErrorTemplate';\r\nimport FieldHelpTemplate from './FieldHelpTemplate';\r\nimport ObjectFieldTemplate from './ObjectFieldTemplate';\r\nimport TitleField from './TitleField';\r\nimport UnsupportedField from './UnsupportedField';\r\nimport WrapIfAdditionalTemplate from './WrapIfAdditionalTemplate';\r\n\r\nfunction templates<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(): TemplatesType<\r\n  T,\r\n  S,\r\n  F\r\n> {\r\n  return {\r\n    ArrayFieldDescriptionTemplate,\r\n    ArrayFieldItemTemplate,\r\n    ArrayFieldTemplate,\r\n    ArrayFieldTitleTemplate,\r\n    ButtonTemplates: ButtonTemplates<T, S, F>(),\r\n    BaseInputTemplate,\r\n    DescriptionFieldTemplate: DescriptionField,\r\n    ErrorListTemplate: ErrorList,\r\n    FieldTemplate,\r\n    FieldErrorTemplate,\r\n    FieldHelpTemplate,\r\n    ObjectFieldTemplate,\r\n    TitleFieldTemplate: TitleField,\r\n    UnsupportedFieldTemplate: UnsupportedField,\r\n    WrapIfAdditionalTemplate,\r\n  };\r\n}\r\n\r\nexport default templates;\r\n","import { MouseEvent, useCallback, useEffect, useReducer, useState } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  dateRangeOptions,\r\n  parseDateString,\r\n  toDateString,\r\n  DateObject,\r\n  type DateElementFormat,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  WidgetProps,\r\n  getDateElementProps,\r\n} from '@react-jsf/utils';\r\n\r\nfunction readyForChange(state: DateObject) {\r\n  return Object.values(state).every((value) => value !== -1);\r\n}\r\n\r\ntype DateElementProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = Pick<\r\n  WidgetProps<T, S, F>,\r\n  'value' | 'name' | 'disabled' | 'readonly' | 'autofocus' | 'registry' | 'onBlur' | 'onFocus'\r\n> & {\r\n  rootId: string;\r\n  select: (property: keyof DateObject, value: any) => void;\r\n  type: string;\r\n  range: [number, number];\r\n};\r\n\r\nfunction DateElement<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  type,\r\n  range,\r\n  value,\r\n  select,\r\n  rootId,\r\n  name,\r\n  disabled,\r\n  readonly,\r\n  autofocus,\r\n  registry,\r\n  onBlur,\r\n  onFocus,\r\n}: DateElementProps<T, S, F>) {\r\n  const id = rootId + '_' + type;\r\n  const { SelectWidget } = registry.widgets;\r\n  return (\r\n    <SelectWidget\r\n      schema={{ type: 'integer' } as S}\r\n      id={id}\r\n      name={name}\r\n      className='form-control'\r\n      options={{ enumOptions: dateRangeOptions<S>(range[0], range[1]) }}\r\n      placeholder={type}\r\n      value={value}\r\n      disabled={disabled}\r\n      readonly={readonly}\r\n      autofocus={autofocus}\r\n      onChange={(value: any) => select(type as keyof DateObject, value)}\r\n      onBlur={onBlur}\r\n      onFocus={onFocus}\r\n      registry={registry}\r\n      label=''\r\n      aria-describedby={ariaDescribedByIds<T>(rootId)}\r\n    />\r\n  );\r\n}\r\n\r\n/** The `AltDateWidget` is an alternative widget for rendering date properties.\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction AltDateWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  time = false,\r\n  disabled = false,\r\n  readonly = false,\r\n  autofocus = false,\r\n  options,\r\n  id,\r\n  name,\r\n  registry,\r\n  onBlur,\r\n  onFocus,\r\n  onChange,\r\n  value,\r\n}: WidgetProps<T, S, F>) {\r\n  const { translateString } = registry;\r\n  const [lastValue, setLastValue] = useState(value);\r\n  const [state, setState] = useReducer((state: DateObject, action: Partial<DateObject>) => {\r\n    return { ...state, ...action };\r\n  }, parseDateString(value, time));\r\n\r\n  useEffect(() => {\r\n    const stateValue = toDateString(state, time);\r\n    if (readyForChange(state) && stateValue !== value) {\r\n      // The user changed the date to a new valid data via the comboboxes, so call onChange\r\n      onChange(stateValue);\r\n    } else if (lastValue !== value) {\r\n      // We got a new value in the props\r\n      setLastValue(value);\r\n      setState(parseDateString(value, time));\r\n    }\r\n  }, [time, value, onChange, state, lastValue]);\r\n\r\n  const handleChange = useCallback((property: keyof DateObject, value: string) => {\r\n    setState({ [property]: value });\r\n  }, []);\r\n\r\n  const handleSetNow = useCallback(\r\n    (event: MouseEvent<HTMLAnchorElement>) => {\r\n      event.preventDefault();\r\n      if (disabled || readonly) {\r\n        return;\r\n      }\r\n      const nextState = parseDateString(new Date().toJSON(), time);\r\n      onChange(toDateString(nextState, time));\r\n    },\r\n    [disabled, readonly, time]\r\n  );\r\n\r\n  const handleClear = useCallback(\r\n    (event: MouseEvent<HTMLAnchorElement>) => {\r\n      event.preventDefault();\r\n      if (disabled || readonly) {\r\n        return;\r\n      }\r\n      onChange(undefined);\r\n    },\r\n    [disabled, readonly, onChange]\r\n  );\r\n\r\n  return (\r\n    <ul className='list-inline'>\r\n      {getDateElementProps(\r\n        state,\r\n        time,\r\n        options.yearsRange as [number, number] | undefined,\r\n        options.format as DateElementFormat | undefined\r\n      ).map((elemProps, i) => (\r\n        <li className='list-inline-item' key={i}>\r\n          <DateElement\r\n            rootId={id}\r\n            name={name}\r\n            select={handleChange}\r\n            {...elemProps}\r\n            disabled={disabled}\r\n            readonly={readonly}\r\n            registry={registry}\r\n            onBlur={onBlur}\r\n            onFocus={onFocus}\r\n            autofocus={autofocus && i === 0}\r\n          />\r\n        </li>\r\n      ))}\r\n      {(options.hideNowButton !== 'undefined' ? !options.hideNowButton : true) && (\r\n        <li className='list-inline-item'>\r\n          <a href='#' className='btn btn-info btn-now' onClick={handleSetNow}>\r\n            {translateString(TranslatableString.NowLabel)}\r\n          </a>\r\n        </li>\r\n      )}\r\n      {(options.hideClearButton !== 'undefined' ? !options.hideClearButton : true) && (\r\n        <li className='list-inline-item'>\r\n          <a href='#' className='btn btn-warning btn-clear' onClick={handleClear}>\r\n            {translateString(TranslatableString.ClearLabel)}\r\n          </a>\r\n        </li>\r\n      )}\r\n    </ul>\r\n  );\r\n}\r\n\r\nexport default AltDateWidget;\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `AltDateTimeWidget` is an alternative widget for rendering datetime properties.\r\n *  It uses the AltDateWidget for rendering, with the `time` prop set to true by default.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction AltDateTimeWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  time = true,\r\n  ...props\r\n}: WidgetProps<T, S, F>) {\r\n  const { AltDateWidget } = props.registry.widgets;\r\n  return <AltDateWidget time={time} {...props} />;\r\n}\r\n\r\nexport default AltDateTimeWidget;\r\n","import { ChangeEvent, FocusEvent, useCallback } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  descriptionId,\r\n  getTemplate,\r\n  labelValue,\r\n  schemaRequiresTrueValue,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `CheckBoxWidget` is a widget for rendering boolean properties.\r\n *  It is typically used to represent a boolean.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction CheckboxWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  schema,\r\n  uiSchema,\r\n  options,\r\n  id,\r\n  value,\r\n  disabled,\r\n  readonly,\r\n  label,\r\n  hideLabel,\r\n  autofocus = false,\r\n  onBlur,\r\n  onFocus,\r\n  onChange,\r\n  registry,\r\n}: WidgetProps<T, S, F>) {\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    options\r\n  );\r\n  // Because an unchecked checkbox will cause html5 validation to fail, only add\r\n  // the \"required\" attribute if the field value must be \"true\", due to the\r\n  // \"const\" or \"enum\" keywords\r\n  const required = schemaRequiresTrueValue<S>(schema);\r\n\r\n  const handleChange = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => onChange(event.target.checked),\r\n    [onChange]\r\n  );\r\n\r\n  const handleBlur = useCallback(\r\n    (event: FocusEvent<HTMLInputElement>) => onBlur(id, event.target.checked),\r\n    [onBlur, id]\r\n  );\r\n\r\n  const handleFocus = useCallback(\r\n    (event: FocusEvent<HTMLInputElement>) => onFocus(id, event.target.checked),\r\n    [onFocus, id]\r\n  );\r\n  const description = options.description ?? schema.description;\r\n\r\n  return (\r\n    <div className={`checkbox ${disabled || readonly ? 'disabled' : ''}`}>\r\n      {!hideLabel && !!description && (\r\n        <DescriptionFieldTemplate\r\n          id={descriptionId<T>(id)}\r\n          description={description}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      <label>\r\n        <input\r\n          type='checkbox'\r\n          id={id}\r\n          name={id}\r\n          checked={typeof value === 'undefined' ? false : value}\r\n          required={required}\r\n          disabled={disabled || readonly}\r\n          autoFocus={autofocus}\r\n          onChange={handleChange}\r\n          onBlur={handleBlur}\r\n          onFocus={handleFocus}\r\n          aria-describedby={ariaDescribedByIds<T>(id)}\r\n        />\r\n        {labelValue(<span>{label}</span>, hideLabel)}\r\n      </label>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CheckboxWidget;\r\n","import { ChangeEvent, FocusEvent, useCallback } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  enumOptionsDeselectValue,\r\n  enumOptionsIsSelected,\r\n  enumOptionsSelectValue,\r\n  enumOptionsValueForIndex,\r\n  optionId,\r\n  FormContextType,\r\n  WidgetProps,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `CheckboxesWidget` is a widget for rendering checkbox groups.\r\n *  It is typically used to represent an array of enums.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction CheckboxesWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  id,\r\n  disabled,\r\n  options: { inline = false, enumOptions, enumDisabled, emptyValue },\r\n  value,\r\n  autofocus = false,\r\n  readonly,\r\n  onChange,\r\n  onBlur,\r\n  onFocus,\r\n}: WidgetProps<T, S, F>) {\r\n  const checkboxesValues = Array.isArray(value) ? value : [value];\r\n\r\n  const handleBlur = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) =>\r\n      onBlur(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue)),\r\n    [onBlur, id]\r\n  );\r\n\r\n  const handleFocus = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) =>\r\n      onFocus(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue)),\r\n    [onFocus, id]\r\n  );\r\n  return (\r\n    <div className='checkboxes' id={id}>\r\n      {Array.isArray(enumOptions) &&\r\n        enumOptions.map((option, index) => {\r\n          const checked = enumOptionsIsSelected<S>(option.value, checkboxesValues);\r\n          const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\r\n          const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';\r\n\r\n          const handleChange = (event: ChangeEvent<HTMLInputElement>) => {\r\n            if (event.target.checked) {\r\n              onChange(enumOptionsSelectValue<S>(index, checkboxesValues, enumOptions));\r\n            } else {\r\n              onChange(enumOptionsDeselectValue<S>(index, checkboxesValues, enumOptions));\r\n            }\r\n          };\r\n\r\n          const checkbox = (\r\n            <span>\r\n              <input\r\n                type='checkbox'\r\n                id={optionId(id, index)}\r\n                name={id}\r\n                checked={checked}\r\n                value={String(index)}\r\n                disabled={disabled || itemDisabled || readonly}\r\n                autoFocus={autofocus && index === 0}\r\n                onChange={handleChange}\r\n                onBlur={handleBlur}\r\n                onFocus={handleFocus}\r\n                aria-describedby={ariaDescribedByIds<T>(id)}\r\n              />\r\n              <span>{option.label}</span>\r\n            </span>\r\n          );\r\n          return inline ? (\r\n            <label key={index} className={`checkbox-inline ${disabledCls}`}>\r\n              {checkbox}\r\n            </label>\r\n          ) : (\r\n            <div key={index} className={`checkbox ${disabledCls}`}>\r\n              <label>{checkbox}</label>\r\n            </div>\r\n          );\r\n        })}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default CheckboxesWidget;\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `ColorWidget` component uses the `BaseInputTemplate` changing the type to `color` and disables it when it is\r\n * either disabled or readonly.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function ColorWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { disabled, readonly, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate type='color' {...props} disabled={disabled || readonly} />;\r\n}\r\n","import { useCallback } from 'react';\r\nimport { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `DateWidget` component uses the `BaseInputTemplate` changing the type to `date` and transforms\r\n * the value to undefined when it is falsy during the `onChange` handling.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function DateWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { onChange, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  const handleChange = useCallback((value: any) => onChange(value || undefined), [onChange]);\r\n\r\n  return <BaseInputTemplate type='date' {...props} onChange={handleChange} />;\r\n}\r\n","import {\r\n  getTemplate,\r\n  localToUTC,\r\n  utcToLocal,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `DateTimeWidget` component uses the `BaseInputTemplate` changing the type to `datetime-local` and transforms\r\n * the value to/from utc using the appropriate utility functions.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function DateTimeWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: WidgetProps<T, S, F>) {\r\n  const { onChange, value, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return (\r\n    <BaseInputTemplate\r\n      type='datetime-local'\r\n      {...props}\r\n      value={utcToLocal(value)}\r\n      onChange={(value) => onChange(localToUTC(value))}\r\n    />\r\n  );\r\n}\r\n","/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\r\nexport default function localToUTC(dateString: string) {\r\n  return dateString ? new Date(dateString).toJSON() : undefined;\r\n}\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `EmailWidget` component uses the `BaseInputTemplate` changing the type to `email`.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function EmailWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate type='email' {...props} />;\r\n}\r\n","import { ChangeEvent, useCallback, useMemo } from 'react';\r\nimport {\r\n  dataURItoBlob,\r\n  FormContextType,\r\n  getTemplate,\r\n  Registry,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  UIOptionsType,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\nimport Markdown from 'markdown-to-jsx';\r\n\r\nfunction addNameToDataURL(dataURL: string, name: string) {\r\n  if (dataURL === null) {\r\n    return null;\r\n  }\r\n  return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);\r\n}\r\n\r\ntype FileInfoType = {\r\n  dataURL?: string | null;\r\n  name: string;\r\n  size: number;\r\n  type: string;\r\n};\r\n\r\nfunction processFile(file: File): Promise<FileInfoType> {\r\n  const { name, size, type } = file;\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new window.FileReader();\r\n    reader.onerror = reject;\r\n    reader.onload = (event) => {\r\n      if (typeof event.target?.result === 'string') {\r\n        resolve({\r\n          dataURL: addNameToDataURL(event.target.result, name),\r\n          name,\r\n          size,\r\n          type,\r\n        });\r\n      } else {\r\n        resolve({\r\n          dataURL: null,\r\n          name,\r\n          size,\r\n          type,\r\n        });\r\n      }\r\n    };\r\n    reader.readAsDataURL(file);\r\n  });\r\n}\r\n\r\nfunction processFiles(files: FileList) {\r\n  return Promise.all(Array.from(files).map(processFile));\r\n}\r\n\r\nfunction FileInfoPreview<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  fileInfo,\r\n  registry,\r\n}: {\r\n  fileInfo: FileInfoType;\r\n  registry: Registry<T, S, F>;\r\n}) {\r\n  const { translateString } = registry;\r\n  const { dataURL, type, name } = fileInfo;\r\n  if (!dataURL) {\r\n    return null;\r\n  }\r\n\r\n  // If type is JPEG or PNG then show image preview.\r\n  // Originally, any type of image was supported, but this was changed into a whitelist\r\n  // since SVGs and animated GIFs are also images, which are generally considered a security risk.\r\n  if (['image/jpeg', 'image/png'].includes(type)) {\r\n    return <img src={dataURL} style={{ maxWidth: '100%' }} className='file-preview' />;\r\n  }\r\n\r\n  // otherwise, let users download file\r\n\r\n  return (\r\n    <>\r\n      {' '}\r\n      <a download={`preview-${name}`} href={dataURL} className='file-download'>\r\n        {translateString(TranslatableString.PreviewLabel)}\r\n      </a>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction FilesInfo<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  filesInfo,\r\n  registry,\r\n  preview,\r\n  onRemove,\r\n  options,\r\n}: {\r\n  filesInfo: FileInfoType[];\r\n  registry: Registry<T, S, F>;\r\n  preview?: boolean;\r\n  onRemove: (index: number) => void;\r\n  options: UIOptionsType<T, S, F>;\r\n}) {\r\n  if (filesInfo.length === 0) {\r\n    return null;\r\n  }\r\n  const { translateString } = registry;\r\n\r\n  const { RemoveButton } = getTemplate<'ButtonTemplates', T, S, F>('ButtonTemplates', registry, options);\r\n\r\n  return (\r\n    <ul className='file-info'>\r\n      {filesInfo.map((fileInfo, key) => {\r\n        const { name, size, type } = fileInfo;\r\n        const handleRemove = () => onRemove(key);\r\n        return (\r\n          <li key={key}>\r\n            <Markdown>{translateString(TranslatableString.FilesInfo, [name, type, String(size)])}</Markdown>\r\n            {preview && <FileInfoPreview<T, S, F> fileInfo={fileInfo} registry={registry} />}\r\n            <RemoveButton onClick={handleRemove} registry={registry} />\r\n          </li>\r\n        );\r\n      })}\r\n    </ul>\r\n  );\r\n}\r\n\r\nfunction extractFileInfo(dataURLs: string[]): FileInfoType[] {\r\n  return dataURLs.reduce((acc, dataURL) => {\r\n    if (!dataURL) {\r\n      return acc;\r\n    }\r\n    try {\r\n      const { blob, name } = dataURItoBlob(dataURL);\r\n      return [\r\n        ...acc,\r\n        {\r\n          dataURL,\r\n          name: name,\r\n          size: blob.size,\r\n          type: blob.type,\r\n        },\r\n      ];\r\n    } catch (e) {\r\n      // Invalid dataURI, so just ignore it.\r\n      return acc;\r\n    }\r\n  }, [] as FileInfoType[]);\r\n}\r\n\r\n/**\r\n *  The `FileWidget` is a widget for rendering file upload fields.\r\n *  It is typically used with a string property with data-url format.\r\n */\r\nfunction FileWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n\r\n  const handleChange = useCallback(\r\n    (event: ChangeEvent<HTMLInputElement>) => {\r\n      if (!event.target.files) {\r\n        return;\r\n      }\r\n      // Due to variances in themes, dealing with multiple files for the array case now happens one file at a time.\r\n      // This is because we don't pass `multiple` into the `BaseInputTemplate` anymore. Instead, we deal with the single\r\n      // file in each event and concatenate them together ourselves\r\n      processFiles(event.target.files).then((filesInfoEvent) => {\r\n        const newValue = filesInfoEvent.map((fileInfo) => fileInfo.dataURL);\r\n        if (multiple) {\r\n          onChange(value.concat(newValue[0]));\r\n        } else {\r\n          onChange(newValue[0]);\r\n        }\r\n      });\r\n    },\r\n    [multiple, value, onChange]\r\n  );\r\n\r\n  const filesInfo = useMemo(() => extractFileInfo(Array.isArray(value) ? value : [value]), [value]);\r\n  const rmFile = useCallback(\r\n    (index: number) => {\r\n      if (multiple) {\r\n        const newValue = value.filter((_: any, i: number) => i !== index);\r\n        onChange(newValue);\r\n      } else {\r\n        onChange(undefined);\r\n      }\r\n    },\r\n    [multiple, value, onChange]\r\n  );\r\n  return (\r\n    <div>\r\n      <BaseInputTemplate\r\n        {...props}\r\n        disabled={disabled || readonly}\r\n        type='file'\r\n        required={value ? false : required} // this turns off HTML required validation when a value exists\r\n        onChangeOverride={handleChange}\r\n        value=''\r\n        accept={options.accept ? String(options.accept) : undefined}\r\n      />\r\n      <FilesInfo<T, S, F>\r\n        filesInfo={filesInfo}\r\n        onRemove={rmFile}\r\n        registry={registry}\r\n        preview={options.filePreview}\r\n        options={options}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FileWidget;\r\n","/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\r\nexport default function dataURItoBlob(dataURILike: string) {\r\n  // check if is dataURI\r\n  if (dataURILike.indexOf('data:') === -1) {\r\n    throw new Error('File is invalid: URI must be a dataURI');\r\n  }\r\n  const dataURI = dataURILike.slice(5);\r\n  // split the dataURI into media and base64, with the base64 signature\r\n  const splitted = dataURI.split(';base64,');\r\n  // if the base64 signature is not present, the latter part will become empty\r\n  if (splitted.length !== 2) {\r\n    throw new Error('File is invalid: dataURI must be base64');\r\n  }\r\n  // extract the mime type, media parameters including the name, and the base64 string\r\n  const [media, base64] = splitted;\r\n  const [mime, ...mediaparams] = media.split(';');\r\n  const type = mime || '';\r\n\r\n  // extract the name from the parameters\r\n  const name = decodeURI(\r\n    // parse the parameters into key-value pairs, find a key, and extract a value\r\n    // if no key is found, then the name is unknown\r\n    mediaparams.map((param) => param.split('=')).find(([key]) => key === 'name')?.[1] || 'unknown'\r\n  );\r\n\r\n  // Built the Uint8Array Blob parameter from the base64 string.\r\n  try {\r\n    const binary = atob(base64);\r\n    const array = new Array(binary.length);\r\n    for (let i = 0; i < binary.length; i++) {\r\n      array[i] = binary.charCodeAt(i);\r\n    }\r\n    // Create the blob object\r\n    const blob = new window.Blob([new Uint8Array(array)], { type });\r\n\r\n    return { blob, name };\r\n  } catch (error) {\r\n    throw new Error('File is invalid: ' + (error as Error).message);\r\n  }\r\n}\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `HiddenWidget` is a widget for rendering a hidden input field.\r\n *  It is typically used by setting type to \"hidden\".\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction HiddenWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  id,\r\n  value,\r\n}: WidgetProps<T, S, F>) {\r\n  return <input type='hidden' id={id} name={id} value={typeof value === 'undefined' ? '' : value} />;\r\n}\r\n\r\nexport default HiddenWidget;\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `PasswordWidget` component uses the `BaseInputTemplate` changing the type to `password`.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function PasswordWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: WidgetProps<T, S, F>) {\r\n  const { options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate type='password' {...props} />;\r\n}\r\n","import { FocusEvent, useCallback } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  enumOptionsIsSelected,\r\n  enumOptionsValueForIndex,\r\n  optionId,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\n/** The `RadioWidget` is a widget for rendering a radio group.\r\n *  It is typically used with a string property constrained with enum options.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction RadioWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  options,\r\n  value,\r\n  required,\r\n  disabled,\r\n  readonly,\r\n  autofocus = false,\r\n  onBlur,\r\n  onFocus,\r\n  onChange,\r\n  id,\r\n}: WidgetProps<T, S, F>) {\r\n  const { enumOptions, enumDisabled, inline, emptyValue } = options;\r\n\r\n  const handleBlur = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) =>\r\n      onBlur(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue)),\r\n    [onBlur, id]\r\n  );\r\n\r\n  const handleFocus = useCallback(\r\n    ({ target }: FocusEvent<HTMLInputElement>) =>\r\n      onFocus(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue)),\r\n    [onFocus, id]\r\n  );\r\n\r\n  return (\r\n    <div className='field-radio-group' id={id}>\r\n      {Array.isArray(enumOptions) &&\r\n        enumOptions.map((option, i) => {\r\n          const checked = enumOptionsIsSelected<S>(option.value, value);\r\n          const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\r\n          const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';\r\n\r\n          const handleChange = () => onChange(option.value);\r\n\r\n          const radio = (\r\n            <span>\r\n              <input\r\n                type='radio'\r\n                id={optionId(id, i)}\r\n                checked={checked}\r\n                name={id}\r\n                required={required}\r\n                value={String(i)}\r\n                disabled={disabled || itemDisabled || readonly}\r\n                autoFocus={autofocus && i === 0}\r\n                onChange={handleChange}\r\n                onBlur={handleBlur}\r\n                onFocus={handleFocus}\r\n                aria-describedby={ariaDescribedByIds<T>(id)}\r\n              />\r\n              <span>{option.label}</span>\r\n            </span>\r\n          );\r\n\r\n          return inline ? (\r\n            <label key={i} className={`radio-inline ${disabledCls}`}>\r\n              {radio}\r\n            </label>\r\n          ) : (\r\n            <div key={i} className={`radio ${disabledCls}`}>\r\n              <label>{radio}</label>\r\n            </div>\r\n          );\r\n        })}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default RadioWidget;\r\n","import { FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `RangeWidget` component uses the `BaseInputTemplate` changing the type to `range` and wrapping the result\r\n * in a div, with the value along side it.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function RangeWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const {\r\n    value,\r\n    registry: {\r\n      templates: { BaseInputTemplate },\r\n    },\r\n  } = props;\r\n  return (\r\n    <div className='field-range-wrapper'>\r\n      <BaseInputTemplate type='range' {...props} />\r\n      <span className='range-view'>{value}</span>\r\n    </div>\r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent, SyntheticEvent, useCallback } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  enumOptionsIndexForValue,\r\n  enumOptionsValueForIndex,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\nfunction getValue(event: SyntheticEvent<HTMLSelectElement>, multiple: boolean) {\r\n  if (multiple) {\r\n    return Array.from((event.target as HTMLSelectElement).options)\r\n      .slice()\r\n      .filter((o) => o.selected)\r\n      .map((o) => o.value);\r\n  }\r\n  return (event.target as HTMLSelectElement).value;\r\n}\r\n\r\n/** The `SelectWidget` is a widget for rendering dropdowns.\r\n *  It is typically used with string properties constrained with enum options.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction SelectWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  schema,\r\n  id,\r\n  options,\r\n  value,\r\n  required,\r\n  disabled,\r\n  readonly,\r\n  multiple = false,\r\n  autofocus = false,\r\n  onChange,\r\n  onBlur,\r\n  onFocus,\r\n  placeholder,\r\n}: WidgetProps<T, S, F>) {\r\n  const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;\r\n  const emptyValue = multiple ? [] : '';\r\n\r\n  const handleFocus = useCallback(\r\n    (event: FocusEvent<HTMLSelectElement>) => {\r\n      const newValue = getValue(event, multiple);\r\n      return onFocus(id, enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyVal));\r\n    },\r\n    [onFocus, id, schema, multiple, enumOptions, optEmptyVal]\r\n  );\r\n\r\n  const handleBlur = useCallback(\r\n    (event: FocusEvent<HTMLSelectElement>) => {\r\n      const newValue = getValue(event, multiple);\r\n      return onBlur(id, enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyVal));\r\n    },\r\n    [onBlur, id, schema, multiple, enumOptions, optEmptyVal]\r\n  );\r\n\r\n  const handleChange = useCallback(\r\n    (event: ChangeEvent<HTMLSelectElement>) => {\r\n      const newValue = getValue(event, multiple);\r\n      return onChange(enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyVal));\r\n    },\r\n    [onChange, schema, multiple, enumOptions, optEmptyVal]\r\n  );\r\n\r\n  const selectedIndexes = enumOptionsIndexForValue<S>(value, enumOptions, multiple);\r\n  const showPlaceholderOption = !multiple && schema.default === undefined;\r\n\r\n  return (\r\n    <select\r\n      id={id}\r\n      name={id}\r\n      multiple={multiple}\r\n      className='form-control'\r\n      value={typeof selectedIndexes === 'undefined' ? emptyValue : selectedIndexes}\r\n      required={required}\r\n      disabled={disabled || readonly}\r\n      autoFocus={autofocus}\r\n      onBlur={handleBlur}\r\n      onFocus={handleFocus}\r\n      onChange={handleChange}\r\n      aria-describedby={ariaDescribedByIds<T>(id)}\r\n    >\r\n      {showPlaceholderOption && <option value=''>{placeholder}</option>}\r\n      {Array.isArray(enumOptions) &&\r\n        enumOptions.map(({ value, label }, i) => {\r\n          const disabled = enumDisabled && enumDisabled.indexOf(value) !== -1;\r\n          return (\r\n            <option key={i} value={String(i)} disabled={disabled}>\r\n              {label}\r\n            </option>\r\n          );\r\n        })}\r\n    </select>\r\n  );\r\n}\r\n\r\nexport default SelectWidget;\r\n","import { ChangeEvent, FocusEvent, useCallback } from 'react';\r\nimport { ariaDescribedByIds, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `TextareaWidget` is a widget for rendering input fields as textarea.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nfunction TextareaWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  id,\r\n  options = {},\r\n  placeholder,\r\n  value,\r\n  required,\r\n  disabled,\r\n  readonly,\r\n  autofocus = false,\r\n  onChange,\r\n  onBlur,\r\n  onFocus,\r\n}: WidgetProps<T, S, F>) {\r\n  const handleChange = useCallback(\r\n    ({ target: { value } }: ChangeEvent<HTMLTextAreaElement>) => onChange(value === '' ? options.emptyValue : value),\r\n    [onChange, options.emptyValue]\r\n  );\r\n\r\n  const handleBlur = useCallback(\r\n    ({ target }: FocusEvent<HTMLTextAreaElement>) => onBlur(id, target && target.value),\r\n    [onBlur, id]\r\n  );\r\n\r\n  const handleFocus = useCallback(\r\n    ({ target }: FocusEvent<HTMLTextAreaElement>) => onFocus(id, target && target.value),\r\n    [id, onFocus]\r\n  );\r\n\r\n  return (\r\n    <textarea\r\n      id={id}\r\n      name={id}\r\n      className='form-control'\r\n      value={value ? value : ''}\r\n      placeholder={placeholder}\r\n      required={required}\r\n      disabled={disabled}\r\n      readOnly={readonly}\r\n      autoFocus={autofocus}\r\n      rows={options.rows}\r\n      onBlur={handleBlur}\r\n      onFocus={handleFocus}\r\n      onChange={handleChange}\r\n      aria-describedby={ariaDescribedByIds<T>(id)}\r\n    />\r\n  );\r\n}\r\n\r\nTextareaWidget.defaultProps = {\r\n  autofocus: false,\r\n  options: {},\r\n};\r\n\r\nexport default TextareaWidget;\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `TextWidget` component uses the `BaseInputTemplate`.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function TextWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate {...props} />;\r\n}\r\n","import { useCallback } from 'react';\r\nimport { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `TimeWidget` component uses the `BaseInputTemplate` changing the type to `time` and transforms\r\n * the value to undefined when it is falsy during the `onChange` handling.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function TimeWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { onChange, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  const handleChange = useCallback((value: any) => onChange(value ? `${value}:00` : undefined), [onChange]);\r\n\r\n  return <BaseInputTemplate type='time' {...props} onChange={handleChange} />;\r\n}\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `URLWidget` component uses the `BaseInputTemplate` changing the type to `url`.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function URLWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate type='url' {...props} />;\r\n}\r\n","import { getTemplate, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\n/** The `UpDownWidget` component uses the `BaseInputTemplate` changing the type to `number`.\r\n *\r\n * @param props - The `WidgetProps` for this component\r\n */\r\nexport default function UpDownWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return <BaseInputTemplate type='number' {...props} />;\r\n}\r\n","import { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nimport AltDateWidget from './AltDateWidget';\r\nimport AltDateTimeWidget from './AltDateTimeWidget';\r\nimport CheckboxWidget from './CheckboxWidget';\r\nimport CheckboxesWidget from './CheckboxesWidget';\r\nimport ColorWidget from './ColorWidget';\r\nimport DateWidget from './DateWidget';\r\nimport DateTimeWidget from './DateTimeWidget';\r\nimport EmailWidget from './EmailWidget';\r\nimport FileWidget from './FileWidget';\r\nimport HiddenWidget from './HiddenWidget';\r\nimport PasswordWidget from './PasswordWidget';\r\nimport RadioWidget from './RadioWidget';\r\nimport RangeWidget from './RangeWidget';\r\nimport SelectWidget from './SelectWidget';\r\nimport TextareaWidget from './TextareaWidget';\r\nimport TextWidget from './TextWidget';\r\nimport TimeWidget from './TimeWidget';\r\nimport URLWidget from './URLWidget';\r\nimport UpDownWidget from './UpDownWidget';\r\n\r\nfunction widgets<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): RegistryWidgetsType<T, S, F> {\r\n  return {\r\n    AltDateWidget,\r\n    AltDateTimeWidget,\r\n    CheckboxWidget,\r\n    CheckboxesWidget,\r\n    ColorWidget,\r\n    DateWidget,\r\n    DateTimeWidget,\r\n    EmailWidget,\r\n    FileWidget,\r\n    HiddenWidget,\r\n    PasswordWidget,\r\n    RadioWidget,\r\n    RangeWidget,\r\n    SelectWidget,\r\n    TextWidget,\r\n    TextareaWidget,\r\n    TimeWidget,\r\n    UpDownWidget,\r\n    URLWidget,\r\n  };\r\n}\r\n\r\nexport default widgets;\r\n","import { ElementType, FormEvent, ReactNode, useEffect, useState } from 'react';\r\nimport {\r\n  createSchemaUtils,\r\n  CustomValidator,\r\n  // deepEquals,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  GenericObjectType,\r\n  getTemplate,\r\n  getUiOptions,\r\n  IdSchema,\r\n  isObject,\r\n  mergeObjects,\r\n  NAME_KEY,\r\n  PathSchema,\r\n  StrictRJSFSchema,\r\n  Registry,\r\n  RegistryFieldsType,\r\n  RegistryWidgetsType,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  RJSF_ADDITIONAL_PROPERTIES_FLAG,\r\n  SchemaUtilsType,\r\n  SUBMIT_BTN_OPTIONS_KEY,\r\n  TemplatesType,\r\n  toErrorList,\r\n  UiSchema,\r\n  UI_GLOBAL_OPTIONS_KEY,\r\n  UI_OPTIONS_KEY,\r\n  ValidationData,\r\n  validationDataMerge,\r\n  ValidatorType,\r\n  Experimental_DefaultFormStateBehavior,\r\n} from '@react-jsf/utils';\r\nimport _forEach from 'lodash-es/forEach';\r\nimport _get from 'lodash-es/get';\r\nimport _isEmpty from 'lodash-es/isEmpty';\r\nimport _pick from 'lodash-es/pick';\r\nimport _toPath from 'lodash-es/toPath';\r\n\r\nimport getDefaultRegistry from '../getDefaultRegistry';\r\n\r\n/** The properties that are passed to the `Form` */\r\nexport interface FormProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\r\n  /** The JSON schema object for the form */\r\n  schema: S;\r\n  /** An implementation of the `ValidatorType` interface that is needed for form validation to work */\r\n  validator: ValidatorType<T, S, F>;\r\n  /** The optional children for the form, if provided, it will replace the default `SubmitButton` */\r\n  children?: ReactNode;\r\n  /** The uiSchema for the form */\r\n  uiSchema?: UiSchema<T, S, F>;\r\n  /** The data for the form, used to prefill a form with existing data */\r\n  formData?: T;\r\n  // Form presentation and behavior modifiers\r\n  /** You can provide a `formContext` object to the form, which is passed down to all fields and widgets. Useful for\r\n   * implementing context aware fields and widgets.\r\n   *\r\n   * NOTE: Setting `{readonlyAsDisabled: false}` on the formContext will make the antd theme treat readOnly fields as\r\n   * disabled.\r\n   */\r\n  formContext?: F;\r\n  /** To avoid collisions with existing ids in the DOM, it is possible to change the prefix used for ids;\r\n   * Default is `root`\r\n   */\r\n  idPrefix?: string;\r\n  /** To avoid using a path separator that is present in field names, it is possible to change the separator used for\r\n   * ids (Default is `_`)\r\n   */\r\n  idSeparator?: string;\r\n  /** It's possible to disable the whole form by setting the `disabled` prop. The `disabled` prop is then forwarded down\r\n   * to each field of the form. If you just want to disable some fields, see the `ui:disabled` parameter in `uiSchema`\r\n   */\r\n  disabled?: boolean;\r\n  /** It's possible to make the whole form read-only by setting the `readonly` prop. The `readonly` prop is then\r\n   * forwarded down to each field of the form. If you just want to make some fields read-only, see the `ui:readonly`\r\n   * parameter in `uiSchema`\r\n   */\r\n  readonly?: boolean;\r\n  // Form registry\r\n  /** The dictionary of registered fields in the form */\r\n  fields?: RegistryFieldsType<T, S, F>;\r\n  /** The dictionary of registered templates in the form; Partial allows a subset to be provided beyond the defaults */\r\n  templates?: Partial<Omit<TemplatesType<T, S, F>, 'ButtonTemplates'>> & {\r\n    ButtonTemplates?: Partial<TemplatesType<T, S, F>['ButtonTemplates']>;\r\n  };\r\n  /** The dictionary of registered widgets in the form */\r\n  widgets?: RegistryWidgetsType<T, S, F>;\r\n  // Callbacks\r\n  /** If you plan on being notified every time the form data are updated, you can pass an `onChange` handler, which will\r\n   * receive the same args as `onSubmit` any time a value is updated in the form. Can also return the `id` of the field\r\n   * that caused the change\r\n   */\r\n  onChange?: (data: IChangeEvent<T, S, F>, id?: string) => void;\r\n  /** To react when submitted form data are invalid, pass an `onError` handler. It will be passed the list of\r\n   * encountered errors\r\n   */\r\n  onError?: (errors: RJSFValidationError[]) => void;\r\n  /** You can pass a function as the `onSubmit` prop of your `Form` component to listen to when the form is submitted\r\n   * and its data are valid. It will be passed a result object having a `formData` attribute, which is the valid form\r\n   * data you're usually after. The original event will also be passed as a second parameter\r\n   */\r\n  onSubmit?: (data: IChangeEvent<T, S, F>, event: FormEvent<any>) => void;\r\n  /** Sometimes you may want to trigger events or modify external state when a field has been touched, so you can pass\r\n   * an `onBlur` handler, which will receive the id of the input that was blurred and the field value\r\n   */\r\n  onBlur?: (id: string, data: any) => void;\r\n  /** Sometimes you may want to trigger events or modify external state when a field has been focused, so you can pass\r\n   * an `onFocus` handler, which will receive the id of the input that is focused and the field value\r\n   */\r\n  onFocus?: (id: string, data: any) => void;\r\n  // <form /> HTML attributes\r\n  /** The value of this prop will be passed to the `accept-charset` HTML attribute on the form\r\n   * @deprecated replaced with `acceptCharset` which will supercede this value if both are specified\r\n   */\r\n  acceptcharset?: string;\r\n  /** The value of this prop will be passed to the `accept-charset` HTML attribute on the form */\r\n  acceptCharset?: string;\r\n  /** The value of this prop will be passed to the `action` HTML attribute on the form\r\n   *\r\n   * NOTE: this just renders the `action` attribute in the HTML markup. There is no real network request being sent to\r\n   * this `action` on submit. Instead, react-jsonschema-form catches the submit event with `event.preventDefault()`\r\n   * and then calls the `onSubmit` function, where you could send a request programmatically with `fetch` or similar.\r\n   */\r\n  action?: string;\r\n  /** The value of this prop will be passed to the `autocomplete` HTML attribute on the form */\r\n  autoComplete?: string;\r\n  /** The value of this prop will be passed to the `class` HTML attribute on the form */\r\n  className?: string;\r\n  /** The value of this prop will be passed to the `enctype` HTML attribute on the form */\r\n  enctype?: string;\r\n  /** The value of this prop will be passed to the `id` HTML attribute on the form */\r\n  id?: string;\r\n  /** The value of this prop will be passed to the `name` HTML attribute on the form */\r\n  name?: string;\r\n  /** The value of this prop will be passed to the `method` HTML attribute on the form */\r\n  method?: string;\r\n  /** It's possible to change the default `form` tag name to a different HTML tag, which can be helpful if you are\r\n   * nesting forms. However, native browser form behaviour, such as submitting when the `Enter` key is pressed, may no\r\n   * longer work\r\n   */\r\n  tagName?: ElementType;\r\n  /** The value of this prop will be passed to the `target` HTML attribute on the form */\r\n  target?: string;\r\n  // Errors and validation\r\n  /** Formerly the `validate` prop; Takes a function that specifies custom validation rules for the form */\r\n  customValidate?: CustomValidator<T, S, F>;\r\n  /** This prop allows passing in custom errors that are augmented with the existing JSON Schema errors on the form; it\r\n   * can be used to implement asynchronous validation. By default, these are non-blocking errors, meaning that you can\r\n   * still submit the form when these are the only errors displayed to the user.\r\n   */\r\n  extraErrors?: ErrorSchema<T>;\r\n  /** If set to true, causes the `extraErrors` to become blocking when the form is submitted */\r\n  extraErrorsBlockSubmit?: boolean;\r\n  /** If set to true, turns off HTML5 validation on the form; Set to `false` by default */\r\n  noHtml5Validate?: boolean;\r\n  /** If set to true, turns off all validation. Set to `false` by default\r\n   *\r\n   * @deprecated - In a future release, this switch may be replaced by making `validator` prop optional\r\n   */\r\n  noValidate?: boolean;\r\n  /** If set to true, the form will perform validation and show any validation errors whenever the form data is changed,\r\n   * rather than just on submit\r\n   */\r\n  liveValidate?: boolean;\r\n  /** If `omitExtraData` and `liveOmit` are both set to true, then extra form data values that are not in any form field\r\n   * will be removed whenever `onChange` is called. Set to `false` by default\r\n   */\r\n  liveOmit?: boolean;\r\n  /** If set to true, then extra form data values that are not in any form field will be removed whenever `onSubmit` is\r\n   * called. Set to `false` by default.\r\n   */\r\n  omitExtraData?: boolean;\r\n  /** When this prop is set to `top` or 'bottom', a list of errors (or the custom error list defined in the `ErrorList`) will also\r\n   * show. When set to false, only inline input validation errors will be shown. Set to `top` by default\r\n   */\r\n  showErrorList?: false | 'top' | 'bottom';\r\n  /** A function can be passed to this prop in order to make modifications to the default errors resulting from JSON\r\n   * Schema validation\r\n   */\r\n  transformErrors?: ErrorTransformer<T, S, F>;\r\n  /** If set to true, then the first field with an error will receive the focus when the form is submitted with errors\r\n   */\r\n  focusOnFirstError?: boolean | ((error: RJSFValidationError) => void);\r\n  /** Optional string translation function, if provided, allows users to change the translation of the RJSF internal\r\n   * strings. Some strings contain replaceable parameter values as indicated by `%1`, `%2`, etc. The number after the\r\n   * `%` indicates the order of the parameter. The ordering of parameters is important because some languages may choose\r\n   * to put the second parameter before the first in its translation.\r\n   */\r\n  translateString?: Registry['translateString'];\r\n  /** Optional configuration object with flags, if provided, allows users to override default form state behavior\r\n   * Currently only affecting minItems on array fields and handling of setting defaults based on the value of\r\n   * `emptyObjectFields`\r\n   */\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\r\n  // Private\r\n  /**\r\n   * _internalFormWrapper is currently used by the semantic-ui theme to provide a custom wrapper around `<Form />`\r\n   * that supports the proper rendering of those themes. To use this prop, one must pass a component that takes two\r\n   * props: `children` and `as`. That component, at minimum, should render the `children` inside of a <form /> tag\r\n   * unless `as` is provided, in which case, use the `as` prop in place of `<form />`.\r\n   * i.e.:\r\n   * ```\r\n   * export default function InternalForm({ children, as }) {\r\n   *   const FormTag = as || 'form';\r\n   *   return <FormTag>{children}</FormTag>;\r\n   * }\r\n   * ```\r\n   *\r\n   * Use at your own risk as this prop is private and may change at any time without notice.\r\n   */\r\n  _internalFormWrapper?: ElementType;\r\n  /** Support receiving a React formRef to the Form\r\n   */\r\n  // formRef?: Ref<Form<T, S, F>>;\r\n  formRef?: any;\r\n}\r\n\r\n/** The data that is contained within the state for the `Form` */\r\nexport interface FormState<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> {\r\n  /** The JSON schema object for the form */\r\n  schema: S;\r\n  /** The uiSchema for the form */\r\n  uiSchema: UiSchema<T, S, F>;\r\n  /** The `IdSchema` for the form, computed from the `schema`, the `rootFieldId`, the `formData` and the `idPrefix` and\r\n   * `idSeparator` props.\r\n   */\r\n  idSchema: IdSchema<T>;\r\n  /** The schemaUtils implementation used by the `Form`, created from the `validator` and the `schema` */\r\n  schemaUtils: SchemaUtilsType<T, S, F>;\r\n  /** The current data for the form, computed from the `formData` prop and the changes made by the user */\r\n  formData?: T;\r\n  /** Flag indicating whether the form is in edit mode, true when `formData` is passed to the form, otherwise false */\r\n  edit: boolean;\r\n  /** The current list of errors for the form, includes `extraErrors` */\r\n  errors: RJSFValidationError[];\r\n  /** The current errors, in `ErrorSchema` format, for the form, includes `extraErrors` */\r\n  errorSchema: ErrorSchema<T>;\r\n  /** The current list of errors for the form directly from schema validation, does NOT include `extraErrors` */\r\n  schemaValidationErrors: RJSFValidationError[];\r\n  /** The current errors, in `ErrorSchema` format, for the form directly from schema validation, does NOT include\r\n   * `extraErrors`\r\n   */\r\n  schemaValidationErrorSchema: ErrorSchema<T>;\r\n  // Private\r\n  /** @description result of schemaUtils.retrieveSchema(schema, formData). This a memoized value to avoid re calculate at internal functions (getStateFromProps, onChange) */\r\n  retrievedSchema: S;\r\n}\r\n\r\n\r\n/** The event data passed when changes have been made to the form, includes everything from the `FormState` except\r\n * the schema validation errors. An additional `status` is added when returned from `onSubmit`\r\n */\r\nexport interface IChangeEvent<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  extends Omit<FormState<T, S, F>, 'schemaValidationErrors' | 'schemaValidationErrorSchema'> {\r\n  /** The status of the form when submitted */\r\n  status?: 'submitted';\r\n}\r\n\r\n/** The `Form` component renders the outer form and all the fields defined in the `schema` */\r\nconst Form = <T extends any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(props: FormProps<T, S, F>) => {  \r\n  /** The formRef used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can\r\n   * provide any possible type here\r\n   */\r\n  if (!props.validator) {\r\n    throw new Error('A validator is required for Form functionality to work');\r\n  }\r\n  const {\r\n    children,\r\n    id,\r\n    idPrefix,\r\n    idSeparator,\r\n    className = '',\r\n    tagName,\r\n    name,\r\n    method,\r\n    target,\r\n    action,\r\n    autoComplete,\r\n    enctype,\r\n    acceptcharset,\r\n    acceptCharset,\r\n    noHtml5Validate = false,\r\n    disabled,\r\n    readonly,\r\n    formContext,\r\n    showErrorList = 'top',\r\n    _internalFormWrapper,\r\n    formRef\r\n  } = props;\r\n  \r\n  const [state, setState] = useState<FormState<T, S, F>>(getStateFromProps(undefined, props, props.formData));\r\n  const { schema, schemaUtils, retrievedSchema, uiSchema, formData, errorSchema, idSchema } = state;\r\n  const registry = getRegistry();\r\n  const { SchemaField: _SchemaField } = registry.fields;\r\n\r\n  /**\r\n   * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered\r\n   * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before\r\n   * they are potentially changed.\r\n   *\r\n   * In this case, it checks if the props have changed since the last render. If they have, it computes the next state\r\n   * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF\r\n   * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date\r\n   * state ready to be applied in `componentDidUpdate`.\r\n   *\r\n   * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a\r\n   * state update is not necessary.\r\n   *\r\n   * @param prevProps - The previous set of props before the update.\r\n   * @param prevState - The previous state before the update.\r\n   * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object\r\n   *        with a flag indicating that an update is not necessary.\r\n   */\r\n  // function getSnapshotBeforeUpdate(\r\n  //   prevProps: FormProps<T, S, F>,\r\n  //   prevState: FormState<T, S, F>\r\n  // ): { nextState: FormState<T, S, F>; shouldUpdate: true } | { shouldUpdate: false } {\r\n  //   if (!deepEquals(props, prevProps)) {\r\n  //     const isSchemaChanged = !deepEquals(prevProps.schema, props.schema);\r\n  //     const isFormDataChanged = !deepEquals(prevProps.formData, props.formData);\r\n  //     const nextState = getStateFromProps(\r\n  //       props,\r\n  //       props.formData,\r\n  //       // If the `schema` has changed, we need to update the retrieved schema.\r\n  //       // Or if the `formData` changes, for example in the case of a schema with dependencies that need to\r\n  //       //  match one of the subSchemas, the retrieved schema must be updated.\r\n  //       isSchemaChanged || isFormDataChanged ? undefined : state.retrievedSchema,\r\n  //       isSchemaChanged\r\n  //     );\r\n  //     const shouldUpdate = !deepEquals(nextState, prevState);\r\n  //     return { nextState, shouldUpdate };\r\n  //   }\r\n  //   return { shouldUpdate: false };\r\n  // }\r\n\r\n  /**\r\n   * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is\r\n   * not called for the initial render.\r\n   *\r\n   * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.\r\n   * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about\r\n   * changes.\r\n   *\r\n   * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative\r\n   * to handle prop changes and state updates.\r\n   *\r\n   * @param _ - The previous set of props.\r\n   * @param prevState - The previous state of the component before the update.\r\n   * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.\r\n   */\r\n  useEffect(() => {\r\n    if (props.onChange) {\r\n      props.onChange(state);\r\n    }\r\n  },[state]);\r\n  \r\n  /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the\r\n   * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the\r\n   * validation process IF required by the `props`.\r\n   *\r\n   * @param props - The props passed to the `Form`\r\n   * @param inputFormData - The new or current data for the `Form`\r\n   * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.\r\n   * @param isSchemaChanged - A flag indicating whether the schema has changed.\r\n   * @returns - The new state for the `Form`\r\n   */\r\n  function getStateFromProps(\r\n    currentState: FormState<T, S, F> | undefined,\r\n    localProps: FormProps<T, S, F>,\r\n    inputFormData?: T,\r\n    retrievedSchema?: S,\r\n    isSchemaChanged = false\r\n  ): FormState<T, S, F> {\r\n    const localState: Partial<FormState<T, S, F>> = currentState || {};\r\n    const schema = 'schema' in localProps ? localProps.schema : props.schema;\r\n    const uiSchema: UiSchema<T, S, F> = ('uiSchema' in localProps ? localProps.uiSchema! : props.uiSchema!) || {};\r\n    const edit = typeof inputFormData !== 'undefined';\r\n    const liveValidate = 'liveValidate' in localProps ? localProps.liveValidate : props.liveValidate;\r\n    const mustValidate = edit && !localProps.noValidate && liveValidate;\r\n    const rootSchema = schema;\r\n    const experimental_defaultFormStateBehavior =\r\n      'experimental_defaultFormStateBehavior' in localProps\r\n        ? localProps.experimental_defaultFormStateBehavior\r\n        : props.experimental_defaultFormStateBehavior;\r\n    let schemaUtils: SchemaUtilsType<T, S, F> | undefined = localState.schemaUtils;\r\n    if (\r\n      !schemaUtils ||\r\n      schemaUtils.doesSchemaUtilsDiffer(localProps.validator, rootSchema, experimental_defaultFormStateBehavior)\r\n    ) {\r\n      schemaUtils = createSchemaUtils<T, S, F>(localProps.validator, rootSchema, experimental_defaultFormStateBehavior);\r\n    }\r\n    const formData: T = schemaUtils.getDefaultFormState(schema, inputFormData) as T;\r\n    const _retrievedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);\r\n    const getCurrentErrors = (): ValidationData<T> => {\r\n      // If the `props.noValidate` option is set or the schema has changed, we reset the error state.\r\n      if (localProps.noValidate || isSchemaChanged) {\r\n        return { errors: [], errorSchema: {} };\r\n      } else if (!localProps.liveValidate) {\r\n        return {\r\n          errors: localState.schemaValidationErrors || [],\r\n          errorSchema: localState.schemaValidationErrorSchema || {},\r\n        };\r\n      }\r\n      return {\r\n        errors: localState.errors || [],\r\n        errorSchema: localState.errorSchema || {},\r\n      };\r\n    };\r\n\r\n    let errors: RJSFValidationError[];\r\n    let errorSchema: ErrorSchema<T> | undefined;\r\n    let schemaValidationErrors: RJSFValidationError[] = localState.schemaValidationErrors ? localState.schemaValidationErrors : [];\r\n    let schemaValidationErrorSchema: ErrorSchema<T> = localState.schemaValidationErrorSchema ? localState.schemaValidationErrorSchema : {};\r\n    if (mustValidate) {\r\n      const schemaValidation = validate(formData, schema, schemaUtils, _retrievedSchema);\r\n      errors = schemaValidation.errors;\r\n      // If the schema has changed, we do not merge state.errorSchema.\r\n      // Else in the case where it hasn't changed, we merge 'state.errorSchema' with 'schemaValidation.errorSchema.' This done to display the raised field error.\r\n      if (isSchemaChanged) {\r\n        errorSchema = schemaValidation.errorSchema;\r\n      } else {\r\n        errorSchema = mergeObjects(\r\n          currentState && currentState.errorSchema ? currentState.errorSchema : {},\r\n          schemaValidation.errorSchema,\r\n          'preventDuplicates'\r\n        ) as ErrorSchema<T>;\r\n      }\r\n      schemaValidationErrors = errors;\r\n      schemaValidationErrorSchema = errorSchema;\r\n    } else {\r\n      const currentErrors = getCurrentErrors();\r\n      errors = currentErrors.errors;\r\n      errorSchema = currentErrors.errorSchema;\r\n    }\r\n    if (localProps.extraErrors) {\r\n      const merged = validationDataMerge({ errorSchema, errors }, props.extraErrors);\r\n      errorSchema = merged.errorSchema;\r\n      errors = merged.errors;\r\n    }\r\n    const idSchema = schemaUtils.toIdSchema(\r\n      _retrievedSchema,\r\n      uiSchema['ui:rootFieldId'],\r\n      formData,\r\n      localProps.idPrefix,\r\n      localProps.idSeparator\r\n    );\r\n    const nextState: FormState<T, S, F> = {\r\n      schemaUtils,\r\n      schema,\r\n      uiSchema,\r\n      idSchema,\r\n      formData,\r\n      edit,\r\n      errors,\r\n      errorSchema,\r\n      schemaValidationErrors,\r\n      schemaValidationErrorSchema,\r\n      retrievedSchema: _retrievedSchema,\r\n    };\r\n    return nextState;\r\n  }\r\n\r\n\r\n  /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the\r\n   * `schemaUtils` in the state), returning the results.\r\n   *\r\n   * @param formData - The new form data to validate\r\n   * @param schema - The schema used to validate against\r\n   * @param altSchemaUtils - The alternate schemaUtils to use for validation\r\n   */\r\n  function validate(\r\n    formData: T | undefined,\r\n    schema = props.schema,\r\n    altSchemaUtils?: SchemaUtilsType<T, S, F>,\r\n    retrievedSchema?: S\r\n  ): ValidationData<T> {\r\n    const schemaUtils = altSchemaUtils ? altSchemaUtils : state.schemaUtils;\r\n    const { customValidate, transformErrors, uiSchema } = props;\r\n    const resolvedSchema = retrievedSchema ?? schemaUtils.retrieveSchema(schema, formData);\r\n    return schemaUtils\r\n      .getValidator()\r\n      .validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);\r\n  }\r\n\r\n  /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */\r\n  function renderErrors(registry: Registry<T, S, F>) {\r\n    const { errors, errorSchema, schema, uiSchema } = state;\r\n    const { formContext } = props;\r\n    const options = getUiOptions<T, S, F>(uiSchema);\r\n    const ErrorListTemplate = getTemplate<'ErrorListTemplate', T, S, F>('ErrorListTemplate', registry, options);\r\n\r\n    if (errors && errors.length) {\r\n      return (\r\n        <ErrorListTemplate\r\n          errors={errors}\r\n          errorSchema={errorSchema || {}}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          formContext={formContext}\r\n          registry={registry}\r\n        />\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Returns the `formData` with only the elements specified in the `fields` list\r\n   *\r\n   * @param formData - The data for the `Form`\r\n   * @param fields - The fields to keep while filtering\r\n   */\r\n  const getUsedFormData = (formData: T | undefined, fields: string[][]): T | undefined => {\r\n    // For the case of a single input form\r\n    if (fields.length === 0 && typeof formData !== 'object') {\r\n      return formData;\r\n    }\r\n\r\n    // _pick has incorrect type definition, it works with string[][], because lodash/hasIn supports it\r\n    const data: GenericObjectType = _pick(formData, fields as unknown as string[]);\r\n    if (Array.isArray(formData)) {\r\n      return Object.keys(data).map((key: string) => data[key]) as unknown as T;\r\n    }\r\n\r\n    return data as T;\r\n  };\r\n\r\n  /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`\r\n   *\r\n   * @param pathSchema - The `PathSchema` object for the form\r\n   * @param [formData] - The form data to use while checking for empty objects/arrays\r\n   */\r\n  const getFieldNames = (pathSchema: PathSchema<T>, formData?: T): string[][] => {\r\n    const getAllPaths = (_obj: GenericObjectType, acc: string[][] = [], paths: string[][] = [[]]) => {\r\n      Object.keys(_obj).forEach((key: string) => {\r\n        if (typeof _obj[key] === 'object') {\r\n          const newPaths = paths.map((path) => [...path, key]);\r\n          // If an object is marked with additionalProperties, all its keys are valid\r\n          if (_obj[key][RJSF_ADDITIONAL_PROPERTIES_FLAG] && _obj[key][NAME_KEY] !== '') {\r\n            acc.push(_obj[key][NAME_KEY]);\r\n          } else {\r\n            getAllPaths(_obj[key], acc, newPaths);\r\n          }\r\n        } else if (key === NAME_KEY && _obj[key] !== '') {\r\n          paths.forEach((path) => {\r\n            const formValue = _get(formData, path);\r\n            // adds path to fieldNames if it points to a value\r\n            // or an empty object/array\r\n            if (\r\n              typeof formValue !== 'object' ||\r\n              _isEmpty(formValue) ||\r\n              (Array.isArray(formValue) && formValue.every((val) => typeof val !== 'object'))\r\n            ) {\r\n              acc.push(path);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      return acc;\r\n    };\r\n\r\n    return getAllPaths(pathSchema);\r\n  };\r\n\r\n  /** Returns the `formData` after filtering to remove any extra data not in a form field\r\n   *\r\n   * @param formData - The data for the `Form`\r\n   * @returns The `formData` after omitting extra data\r\n   */\r\n  const doOmitExtraData = (formData?: T): T | undefined => {\r\n    const { schema, schemaUtils } = state;\r\n    const retrievedSchema = schemaUtils.retrieveSchema(schema, formData);\r\n    const pathSchema = schemaUtils.toPathSchema(retrievedSchema, '', formData);\r\n    const fieldNames = getFieldNames(pathSchema, formData);\r\n    const newFormData = getUsedFormData(formData, fieldNames);\r\n    return newFormData;\r\n  };\r\n\r\n  // Filtering errors based on your retrieved schema to only show errors for properties in the selected branch.\r\n  function filterErrorsBasedOnSchema(schemaErrors: ErrorSchema<T>, resolvedSchema?: S, formData?: any): ErrorSchema<T> {\r\n    const { retrievedSchema, schemaUtils } = state;\r\n    const _retrievedSchema = resolvedSchema ?? retrievedSchema;\r\n    const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, '', formData);\r\n    const fieldNames = getFieldNames(pathSchema, formData);\r\n    const filteredErrors: ErrorSchema<T> = _pick(schemaErrors, fieldNames as unknown as string[]);\r\n    // If the root schema is of a primitive type, do not filter out the __errors\r\n    if (resolvedSchema?.type !== 'object' && resolvedSchema?.type !== 'array') {\r\n      filteredErrors.__errors = schemaErrors.__errors;\r\n    }\r\n    // Removing undefined and empty errors.\r\n    const filterUndefinedErrors = (errors: any): ErrorSchema<T> => {\r\n      _forEach(errors, (errorAtKey, errorKey: keyof typeof errors) => {\r\n        if (errorAtKey === undefined) {\r\n          delete errors[errorKey];\r\n        } else if (typeof errorAtKey === 'object' && !Array.isArray(errorAtKey.__errors)) {\r\n          filterUndefinedErrors(errorAtKey);\r\n        }\r\n      });\r\n      return errors;\r\n    };\r\n    return filterUndefinedErrors(filteredErrors);\r\n  }\r\n\r\n  /** Function to handle changes made to a field in the `Form`. This handler receives an entirely new copy of the\r\n   * `formData` along with a new `ErrorSchema`. It will first update the `formData` with any missing default fields and\r\n   * then, if `omitExtraData` and `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not\r\n   * in a form field. Then, the resulting formData will be validated if required. The state will be updated with the new\r\n   * updated (potentially filtered) `formData`, any errors that resulted from validation. Finally the `onChange`\r\n   * callback will be called if specified with the updated state.\r\n   *\r\n   * @param formData - The new form data from a change to a field\r\n   * @param newErrorSchema - The new `ErrorSchema` based on the field change\r\n   * @param id - The id of the field that caused the change\r\n   */\r\n  const doOnChange = (formData: T | undefined, newErrorSchema?: ErrorSchema<T>, id?: string) => {\r\n    const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = props;\r\n    \r\n    if (isObject(formData) || Array.isArray(formData)) {\r\n      const newState = getStateFromProps(state, props, formData, retrievedSchema);\r\n      formData = newState.formData;\r\n    }\r\n\r\n    const mustValidate = !noValidate && liveValidate;\r\n    let nextState: Partial<FormState<T, S, F>> = { formData, schema };\r\n    let newFormData = formData;\r\n\r\n    let _retrievedSchema: S | undefined;\r\n    if (omitExtraData === true && liveOmit === true) {\r\n      newFormData = doOmitExtraData(formData);\r\n      nextState = {\r\n        formData: newFormData,\r\n      };\r\n    }\r\n\r\n    if (mustValidate) {\r\n      const schemaValidation = validate(newFormData, schema, schemaUtils, retrievedSchema);\r\n      let errors = schemaValidation.errors;\r\n      let errorSchema = schemaValidation.errorSchema;\r\n      const schemaValidationErrors = errors;\r\n      const schemaValidationErrorSchema = errorSchema;\r\n      if (extraErrors) {\r\n        const merged = validationDataMerge(schemaValidation, extraErrors);\r\n        errorSchema = merged.errorSchema;\r\n        errors = merged.errors;\r\n      }\r\n      // Merging 'newErrorSchema' into 'errorSchema' to display the custom raised errors.\r\n      if (newErrorSchema) {\r\n        const filteredErrors = filterErrorsBasedOnSchema(newErrorSchema, retrievedSchema, newFormData);\r\n        errorSchema = mergeObjects(errorSchema, filteredErrors, 'preventDuplicates') as ErrorSchema<T>;\r\n      }\r\n      nextState = {\r\n        formData: newFormData,\r\n        errors,\r\n        errorSchema,\r\n        schemaValidationErrors,\r\n        schemaValidationErrorSchema,\r\n      };\r\n    } else if (!noValidate && newErrorSchema) {\r\n      const errorSchema = extraErrors\r\n        ? (mergeObjects(newErrorSchema, extraErrors, 'preventDuplicates') as ErrorSchema<T>)\r\n        : newErrorSchema;\r\n      nextState = {\r\n        formData: newFormData,\r\n        errorSchema: errorSchema,\r\n        errors: toErrorList(errorSchema),\r\n      };\r\n    }\r\n    if (_retrievedSchema) {\r\n      nextState.retrievedSchema = _retrievedSchema;\r\n    }\r\n    setState(() => {return { ...state, ...nextState }});\r\n    onChange && onChange({ ...state, ...nextState }, id)\r\n  };\r\n\r\n  /**\r\n   * Callback function to handle reset form data.\r\n   * - Reset all fields with default values.\r\n   * - Reset validations and errors\r\n   *\r\n   */\r\n  // const reset = () => {\r\n  //   const newState = getStateFromProps(state, props, undefined);\r\n  //   const newFormData = newState.formData;\r\n  //   const nextState = {\r\n  //     formData: newFormData,\r\n  //     errorSchema: {},\r\n  //     errors: [] as unknown,\r\n  //     schemaValidationErrors: [] as unknown,\r\n  //     schemaValidationErrorSchema: {},\r\n  //   } as FormState<T, S, F>;\r\n\r\n  //   setState(nextState);\r\n  // };\r\n\r\n  /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it\r\n   * was provided.\r\n   *\r\n   * @param id - The unique `id` of the field that was blurred\r\n   * @param data - The data associated with the field that was blurred\r\n   */\r\n  const doOnBlur = (id: string, data: any) => {\r\n    const { onBlur } = props;\r\n    if (onBlur) {\r\n      onBlur(id, data);\r\n    }\r\n  };\r\n\r\n  /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it\r\n   * was provided.\r\n   *\r\n   * @param id - The unique `id` of the field that was focused\r\n   * @param data - The data associated with the field that was focused\r\n   */\r\n  const doOnFocus = (id: string, data: any) => {\r\n    const { onFocus } = props;\r\n    if (onFocus) {\r\n      onFocus(id, data);\r\n    }\r\n  };\r\n\r\n  /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing\r\n   * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the\r\n   * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors\r\n   * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call\r\n   * back the `onSubmit` callback if it was provided.\r\n   *\r\n   * @param event - The submit HTML form event\r\n   */\r\n  const doOnSubmit = (event: FormEvent<any>) => {\r\n    event.preventDefault();\r\n    if (event.target !== event.currentTarget) {\r\n      return;\r\n    }\r\n\r\n    event.persist();\r\n    const { omitExtraData, extraErrors, noValidate, onSubmit } = props;\r\n    let { formData: newFormData } = state;\r\n\r\n    if (omitExtraData === true) {\r\n      newFormData = doOmitExtraData(newFormData);\r\n    }\r\n\r\n    if (noValidate || validateFormWithFormData(newFormData)) {\r\n      // There are no errors generated through schema validation.\r\n      // Check for user provided errors and update state accordingly.\r\n      const errorSchema = extraErrors || {};\r\n      const errors = extraErrors ? toErrorList(extraErrors) : [];\r\n      setState(() => {\r\n        return {\r\n          ...state,\r\n          formData: newFormData,\r\n          errors,\r\n          errorSchema,\r\n          schemaValidationErrors: [],\r\n          schemaValidationErrorSchema: {}\r\n        };\r\n      });\r\n      if (onSubmit) {\r\n        onSubmit({ \r\n          ...state, \r\n          formData: newFormData, \r\n          status: 'submitted' \r\n        }, event);\r\n      }\r\n    }\r\n  };\r\n\r\n  /** Returns the registry for the form */\r\n  function getRegistry(): Registry<T, S, F> {\r\n    const { translateString: customTranslateString, uiSchema = {} } = props;\r\n    const { schemaUtils } = state;\r\n    const { fields, templates, widgets, formContext, translateString } = getDefaultRegistry<T, S, F>();\r\n    return {\r\n      fields: { ...fields, ...props.fields },\r\n      templates: {\r\n        ...templates,\r\n        ...props.templates,\r\n        ButtonTemplates: {\r\n          ...templates.ButtonTemplates,\r\n          ...props.templates?.ButtonTemplates,\r\n        },\r\n      },\r\n      widgets: { ...widgets, ...props.widgets },\r\n      rootSchema: props.schema,\r\n      formContext: props.formContext || formContext,\r\n      schemaUtils,\r\n      translateString: customTranslateString || translateString,\r\n      globalUiOptions: uiSchema[UI_GLOBAL_OPTIONS_KEY],\r\n    };\r\n  }\r\n\r\n  // TODO\r\n  /** Provides a function that can be used to programmatically submit the `Form` */\r\n  // const submit = () => {\r\n  //   if (formRef.current) {\r\n  //     const submitCustomEvent = new CustomEvent('submit', {\r\n  //       cancelable: true,\r\n  //     });\r\n  //     submitCustomEvent.preventDefault();\r\n  //     formRef.current.dispatchEvent(submitCustomEvent);\r\n  //     formRef.current.requestSubmit();\r\n  //   }\r\n  // };\r\n\r\n  /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error\r\n   * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that\r\n   * id is attempted to be found using the `formRef` ref. If it is located, then it is focused.\r\n   *\r\n   * @param error - The error on which to focus\r\n   */\r\n  function focusOnError(error: RJSFValidationError) {\r\n    const { idPrefix = 'root', idSeparator = '_' } = props;\r\n    const { property } = error;\r\n    const path = _toPath(property);\r\n    if (path[0] === '') {\r\n      // Most of the time the `.foo` property results in the first element being empty, so replace it with the idPrefix\r\n      path[0] = idPrefix;\r\n    } else {\r\n      // Otherwise insert the idPrefix into the first location using unshift\r\n      path.unshift(idPrefix);\r\n    }\r\n\r\n    const elementId = path.join(idSeparator);\r\n    // let field = formRef?.current?.elements[elementId];\r\n    // if (!field) {\r\n      // if not an exact match, try finding an input starting with the element id (like radio buttons or checkboxes)\r\n    const field = formRef?.current?.querySelector(`input[id^=${elementId}`) as HTMLElement;\r\n    // }\r\n    // if (field && field.length) {\r\n      // If we got a list with length > 0\r\n    //   field = field[0];\r\n    // }\r\n    if (field) {\r\n      field.focus();\r\n    }\r\n  }\r\n\r\n  /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.\r\n   * If `onError` is provided, then it will be called with the list of errors.\r\n   *\r\n   * @param formData - The form data to validate\r\n   * @returns - True if the form is valid, false otherwise.\r\n   */\r\n  const validateFormWithFormData = (formData?: T): boolean => {\r\n    const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = props;\r\n    const { errors: prevErrors } = state;\r\n    const schemaValidation = validate(formData);\r\n    let errors = schemaValidation.errors;\r\n    let errorSchema = schemaValidation.errorSchema;\r\n    const schemaValidationErrors = errors;\r\n    const schemaValidationErrorSchema = errorSchema;\r\n    const hasError = errors.length > 0 || (extraErrors && extraErrorsBlockSubmit);\r\n    if (hasError) {\r\n      if (extraErrors) {\r\n        const merged = validationDataMerge(schemaValidation, extraErrors);\r\n        errorSchema = merged.errorSchema;\r\n        errors = merged.errors;\r\n      }\r\n      if (focusOnFirstError) {\r\n        if (typeof focusOnFirstError === 'function') {\r\n          focusOnFirstError(errors[0]);\r\n        } else {\r\n          focusOnError(errors[0]);\r\n        }\r\n      }\r\n      if (onError) {\r\n        onError(errors);\r\n      } else {\r\n        console.error('Form validation failed', errors);\r\n      }\r\n      setState(() => { return {\r\n        ...state,\r\n        errors,\r\n        errorSchema,\r\n        schemaValidationErrors,\r\n        schemaValidationErrorSchema,\r\n      }});\r\n        \r\n      \r\n    } else if (prevErrors.length > 0) {\r\n      setState(() => { return {\r\n        ...state,\r\n        errors: [],\r\n        errorSchema: {},\r\n        schemaValidationErrors: [],\r\n        schemaValidationErrorSchema: {},\r\n      }});\r\n    }\r\n    return !hasError;\r\n  };\r\n\r\n  /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove\r\n   * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the\r\n   * same way as would happen on form submission.\r\n   *\r\n   * @returns - True if the form is valid, false otherwise.\r\n   */\r\n  // function validateForm() {\r\n  //   const { omitExtraData } = props;\r\n  //   let { formData: newFormData } = state;\r\n  //   if (omitExtraData === true) {\r\n  //     newFormData = doOmitExtraData(newFormData);\r\n  //   }\r\n  //   return validateFormWithFormData(newFormData);\r\n  // }\r\n\r\n  // render\r\n  const { SubmitButton } = registry.templates.ButtonTemplates;\r\n  // The `semantic-ui` theme has an `_internalFormWrapper` that take an `as` prop that is the\r\n  // PropTypes.elementType to use for the inner tag, so we'll need to pass `tagName` along if it is provided.\r\n  // NOTE, the `as` prop is native to `semantic-ui`\r\n  const as = _internalFormWrapper ? tagName : undefined;\r\n  const FormTag = _internalFormWrapper || tagName || 'form';\r\n  let { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = getUiOptions<T, S, F>(uiSchema);\r\n  if (disabled) {\r\n    submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };\r\n  }\r\n  const submitUiSchema = { [UI_OPTIONS_KEY]: { [SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };\r\n  return (\r\n    <FormTag\r\n      className={className ? className : 'rjsf'}\r\n      id={id}\r\n      name={name}\r\n      method={method}\r\n      target={target}\r\n      action={action}\r\n      autoComplete={autoComplete}\r\n      encType={enctype}\r\n      acceptCharset={acceptCharset || acceptcharset}\r\n      noValidate={noHtml5Validate}\r\n      onSubmit={doOnSubmit}\r\n      as={as}\r\n      ref={formRef}\r\n    >\r\n      {showErrorList === 'top' && renderErrors(registry)}\r\n      <_SchemaField\r\n        name=''\r\n        schema={schema}\r\n        uiSchema={uiSchema}\r\n        errorSchema={errorSchema}\r\n        idSchema={idSchema}\r\n        idPrefix={idPrefix}\r\n        idSeparator={idSeparator}\r\n        formContext={formContext}\r\n        formData={formData}\r\n        onChange={doOnChange}\r\n        onBlur={doOnBlur}\r\n        onFocus={doOnFocus}\r\n        registry={registry}\r\n        disabled={disabled}\r\n        readonly={readonly}\r\n      />\r\n\r\n      {children ? children : <SubmitButton uiSchema={submitUiSchema} registry={registry} />}\r\n      {showErrorList === 'bottom' && renderErrors(registry)}\r\n    </FormTag>\r\n  );\r\n\r\n};\r\n  /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if\r\n   * needed along with the submit button or any children of the form.\r\n   */\r\n  // function shouldComponentUpdate(nextProps: FormProps<T, S, F>, nextState: FormState<T, S, F>): boolean {\r\n  //   return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\r\n  // }\r\n\r\n// export default React.memo(Form, shouldComponentUpdate);\r\nexport default Form;","import { englishStringTranslator, FormContextType, Registry, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nimport fields from './components/fields';\r\nimport templates from './components/templates';\r\nimport widgets from './components/widgets';\r\n\r\n/** The default registry consists of all the fields, templates and widgets provided in the core implementation,\r\n * plus an empty `rootSchema` and `formContext. We omit schemaUtils here because it cannot be defaulted without a\r\n * rootSchema and validator. It will be added into the computed registry later in the Form.\r\n */\r\nexport default function getDefaultRegistry<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): Omit<Registry<T, S, F>, 'schemaUtils'> {\r\n  return {\r\n    fields: fields<T, S, F>(),\r\n    templates: templates<T, S, F>(),\r\n    widgets: widgets<T, S, F>(),\r\n    rootSchema: {} as S,\r\n    formContext: {} as F,\r\n    translateString: englishStringTranslator,\r\n  };\r\n}\r\n","import { FormContextType, IconButtonProps, RJSFSchema, StrictRJSFSchema, TranslatableString } from '@react-jsf/utils';\r\nimport { Button } from '@patternfly/react-core';\r\nimport { BsPlus } from 'react-icons/bs';\r\n\r\nexport default function AddButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  uiSchema,\r\n  registry,\r\n  ...props\r\n}: IconButtonProps<T, S, F>) {\r\n  const { translateString } = registry;\r\n  return (\r\n    <Button\r\n      {...props}\r\n      style={{ width: '100%' }}\r\n      className={`ml-1 ${props.className}`}\r\n      title={translateString(TranslatableString.AddItemButton)}\r\n    >\r\n      <BsPlus />\r\n    </Button>\r\n  );\r\n}\r\n","import { CSSProperties } from 'react';\r\nimport { Grid, GridItem } from '@patternfly/react-core';\r\nimport { ArrayFieldTemplateItemType, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nexport default function ArrayFieldItemTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldTemplateItemType<T, S, F>) {\r\n  const {\r\n    children,\r\n    disabled,\r\n    hasToolbar,\r\n    hasCopy,\r\n    hasMoveDown,\r\n    hasMoveUp,\r\n    hasRemove,\r\n    index,\r\n    onCopyIndexClick,\r\n    onDropIndexClick,\r\n    onReorderClick,\r\n    readonly,\r\n    registry,\r\n    uiSchema,\r\n  } = props;\r\n  const { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;\r\n  const btnStyle: CSSProperties = {\r\n    flex: 1,\r\n    paddingLeft: 6,\r\n    paddingRight: 6,\r\n    fontWeight: 'bold',\r\n  };\r\n  return (\r\n    <div>\r\n      <Grid>\r\n        <GridItem sm={9} lg={9}>\r\n          {children}\r\n        </GridItem>\r\n        <GridItem sm={3} lg={3} className='pf-v5-u-py-sm'>\r\n          {hasToolbar && (\r\n            <div className='d-flex flex-row'>\r\n              {(hasMoveUp || hasMoveDown) && (\r\n                <div className='m-0 p-0'>\r\n                  <MoveUpButton\r\n                    className='array-item-move-up'\r\n                    style={btnStyle}\r\n                    disabled={disabled || readonly || !hasMoveUp}\r\n                    onClick={onReorderClick(index, index - 1)}\r\n                    uiSchema={uiSchema}\r\n                    registry={registry}\r\n                  />\r\n                </div>\r\n              )}\r\n              {(hasMoveUp || hasMoveDown) && (\r\n                <div className='m-0 p-0'>\r\n                  <MoveDownButton\r\n                    style={btnStyle}\r\n                    disabled={disabled || readonly || !hasMoveDown}\r\n                    onClick={onReorderClick(index, index + 1)}\r\n                    uiSchema={uiSchema}\r\n                    registry={registry}\r\n                  />\r\n                </div>\r\n              )}\r\n              {hasCopy && (\r\n                <div className='m-0 p-0'>\r\n                  <CopyButton\r\n                    style={btnStyle}\r\n                    disabled={disabled || readonly}\r\n                    onClick={onCopyIndexClick(index)}\r\n                    uiSchema={uiSchema}\r\n                    registry={registry}\r\n                  />\r\n                </div>\r\n              )}\r\n              {hasRemove && (\r\n                <div className='m-0 p-0'>\r\n                  <RemoveButton\r\n                    style={btnStyle}\r\n                    disabled={disabled || readonly}\r\n                    onClick={onDropIndexClick(index)}\r\n                    uiSchema={uiSchema}\r\n                    registry={registry}\r\n                  />\r\n                </div>\r\n              )}\r\n            </div>\r\n          )}\r\n        </GridItem>\r\n      </Grid>\r\n    </div>\r\n  );\r\n}\r\n","import { Grid, GridItem } from '@patternfly/react-core';\r\nimport { Card, Panel, PanelMain, PanelMainBody } from '@patternfly/react-core';\r\n\r\nimport {\r\n  ArrayFieldTemplateItemType,\r\n  ArrayFieldTemplateProps,\r\n  FormContextType,\r\n  getTemplate,\r\n  getUiOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function ArrayFieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: ArrayFieldTemplateProps<T, S, F>) {\r\n  const { canAdd, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, schema, title } =\r\n    props;\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  const ArrayFieldDescriptionTemplate = getTemplate<'ArrayFieldDescriptionTemplate', T, S, F>(\r\n    'ArrayFieldDescriptionTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  const ArrayFieldItemTemplate = getTemplate<'ArrayFieldItemTemplate', T, S, F>(\r\n    'ArrayFieldItemTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  const ArrayFieldTitleTemplate = getTemplate<'ArrayFieldTitleTemplate', T, S, F>(\r\n    'ArrayFieldTitleTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  // Button templates are not overridden in the uiSchema\r\n  const {\r\n    ButtonTemplates: { AddButton },\r\n  } = registry.templates;\r\n  return (\r\n    <div>\r\n      <Grid className='pf-v5-u-p-0, pf-v5-u-m-0'>\r\n        <GridItem className='pf-v5-u-p-0, pf-v5-u-m-0'>\r\n          <ArrayFieldTitleTemplate\r\n            idSchema={idSchema}\r\n            title={uiOptions.title || title}\r\n            schema={schema}\r\n            uiSchema={uiSchema}\r\n            required={required}\r\n            registry={registry}\r\n          />\r\n          <ArrayFieldDescriptionTemplate\r\n            idSchema={idSchema}\r\n            description={uiOptions.description || schema.description}\r\n            schema={schema}\r\n            uiSchema={uiSchema}\r\n            registry={registry}\r\n          />\r\n          \r\n          <Panel>\r\n            <PanelMain>  \r\n            <PanelMainBody key={`array-item-list-${idSchema.$id}`} className='pf-v5-u-p-0, pf-v5-u-m-0'>\r\n            {items &&\r\n              items.map(({ key, ...itemProps }: ArrayFieldTemplateItemType<T, S, F>) => (\r\n                <ArrayFieldItemTemplate key={key} {...itemProps} />\r\n              ))}\r\n            {canAdd && (\r\n              <Card ouiaId=\"BasicCard\">\r\n                <Grid className='pf-v5-u-mt-xs'>\r\n                  <GridItem span={9}></GridItem>\r\n                  <GridItem span={3} className='pf-v5-u-py-sm'>\r\n                    <AddButton\r\n                      className='array-item-add' \r\n                      onClick={onAddClick}\r\n                      disabled={disabled || readonly}\r\n                      uiSchema={uiSchema}\r\n                      registry={registry}\r\n                    />\r\n                  </GridItem>\r\n                </Grid>\r\n              </Card>\r\n            )}\r\n            </PanelMainBody>\r\n            </PanelMain>  \r\n          </Panel>  \r\n        </GridItem>\r\n      </Grid>\r\n    </div>\r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent } from 'react';\r\nimport { TextInput } from '@patternfly/react-core';\r\nimport {\r\n  ariaDescribedByIds,\r\n  BaseInputTemplateProps,\r\n  examplesId,\r\n  FormContextType,\r\n  getInputProps,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function BaseInputTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  id,\r\n  placeholder,\r\n  required,\r\n  readonly,\r\n  disabled,\r\n  type,\r\n  value,\r\n  onChange,\r\n  onChangeOverride,\r\n  onBlur,\r\n  onFocus,\r\n  autofocus,\r\n  options,\r\n  schema,\r\n  rawErrors = [],\r\n  children,\r\n  extraProps,\r\n}: BaseInputTemplateProps<T, S, F>) {\r\n  const inputProps = {\r\n    ...extraProps,\r\n    ...getInputProps<T, S, F>(schema, type, options),\r\n  };\r\n  const _onChange = ({ target: { value } }: ChangeEvent<HTMLInputElement>) =>\r\n    onChange(value === '' ? options.emptyValue : value);\r\n  const _onBlur = ({ target }: FocusEvent<HTMLInputElement>) => onBlur(id, target && target.value);\r\n  const _onFocus = ({ target }: FocusEvent<HTMLInputElement>) => onFocus(id, target && target.value);\r\n\r\n  // const classNames = [rawErrors.length > 0 ? \"is-invalid\" : \"\", type === 'file' ? 'custom-file-label': \"\"]\r\n  return (\r\n    <>\r\n      <TextInput\r\n        id={id}\r\n        name={id}\r\n        placeholder={placeholder}\r\n        autoFocus={autofocus}\r\n        isRequired={required}\r\n        isDisabled={disabled}\r\n        readOnly={readonly}\r\n        className={rawErrors.length > 0 ? 'is-invalid' : ''}\r\n        list={schema.examples ? examplesId<T>(id) : undefined}\r\n        {...inputProps}\r\n        value={value || value === 0 ? value : ''}\r\n        onChange={onChangeOverride || _onChange}\r\n        onBlur={_onBlur}\r\n        onFocus={_onFocus}\r\n        aria-describedby={ariaDescribedByIds<T>(id, !!schema.examples)}\r\n      />\r\n      {children}\r\n      {Array.isArray(schema.examples) ? (\r\n        <datalist id={examplesId<T>(id)}>\r\n          {(schema.examples as string[])\r\n            .concat(schema.default && !schema.examples.includes(schema.default) ? ([schema.default] as string[]) : [])\r\n            .map((example: any) => {\r\n              return <option key={example} value={example} />;\r\n            })}\r\n        </datalist>\r\n      ) : null}\r\n    </>\r\n  );\r\n}\r\n","import { DescriptionFieldProps, FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nexport default function DescriptionField<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({ id, description }: DescriptionFieldProps<T, S, F>) {\r\n  if (description) {\r\n    return (\r\n      <div>\r\n        <div id={id} className='mb-3'>\r\n          {description}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return null;\r\n}\r\n","import { Card, CardHeader, CardBody } from '@patternfly/react-core';\r\nimport {  List, ListItem, FormHelperText, HelperText, HelperTextItem } from '@patternfly/react-core';\r\n\r\nimport { ErrorListProps, FormContextType, RJSFSchema, StrictRJSFSchema, TranslatableString } from '@react-jsf/utils';\r\n\r\nexport default function ErrorList<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  errors,\r\n  registry,\r\n}: ErrorListProps<T, S, F>) {\r\n  const { translateString } = registry;\r\n  return (\r\n    <Card className='pf-v5-u-mb-sm, pf-m-error'>\r\n      <CardHeader className='alert-danger'>{translateString(TranslatableString.ErrorsLabel)}</CardHeader>\r\n      <CardBody className='pf-v5-u-p-0'>\r\n        <FormHelperText>\r\n          <List isPlain>\r\n            {errors.map((error, i: number) => {\r\n              return (\r\n                <ListItem key={i}>\r\n                  <HelperText><HelperTextItem variant=\"error\">{error.stack}</HelperTextItem></HelperText>\r\n                </ListItem>\r\n              );\r\n            })}\r\n          </List>\r\n        </FormHelperText>\r\n      </CardBody>\r\n    </Card>\r\n  );\r\n}\r\n","import { FormContextType, IconButtonProps, RJSFSchema, StrictRJSFSchema, TranslatableString } from '@react-jsf/utils';\r\nimport { Button, ButtonProps } from '@patternfly/react-core';\r\n\r\nimport { IoIosCopy } from 'react-icons/io';\r\nimport { IoIosRemove } from 'react-icons/io';\r\nimport { AiOutlineArrowUp } from 'react-icons/ai';\r\nimport { AiOutlineArrowDown } from 'react-icons/ai';\r\n\r\nexport default function IconButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F> & ButtonProps\r\n) {\r\n  const { icon, iconType, className, uiSchema, registry, ...otherProps } = props;\r\n  return (\r\n    <Button isBlock={iconType === 'block'} {...otherProps} variant={props.variant || 'plain'} size='sm'>\r\n      {icon}\r\n    </Button>\r\n  );\r\n}\r\n\r\nexport function CopyButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return <IconButton title={translateString(TranslatableString.CopyButton)} {...props} icon={<IoIosCopy />} />;\r\n}\r\n\r\nexport function MoveDownButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton title={translateString(TranslatableString.MoveDownButton)} {...props} icon={<AiOutlineArrowDown />} />\r\n  );\r\n}\r\n\r\nexport function MoveUpButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return <IconButton title={translateString(TranslatableString.MoveUpButton)} {...props} icon={<AiOutlineArrowUp />} />;\r\n}\r\n\r\nexport function RemoveButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: IconButtonProps<T, S, F>\r\n) {\r\n  const {\r\n    registry: { translateString },\r\n  } = props;\r\n  return (\r\n    <IconButton\r\n      title={translateString(TranslatableString.RemoveButton)}\r\n      {...props}\r\n      variant='danger'\r\n      icon={<IoIosRemove />}\r\n    />\r\n  );\r\n}\r\n","import { FieldErrorProps, FormContextType, RJSFSchema, StrictRJSFSchema, errorId } from '@react-jsf/utils';\r\nimport { FormHelperText, HelperText, HelperTextItem } from '@patternfly/react-core';\r\n\r\n/** The `FieldErrorTemplate` component renders the errors local to the particular field\r\n *\r\n * @param props - The `FieldErrorProps` for the errors being rendered\r\n */\r\nexport default function FieldErrorTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: FieldErrorProps<T, S, F>) {\r\n  const { errors = [], idSchema } = props;\r\n  if (errors.length === 0) {\r\n    return null;\r\n  }\r\n  const id = errorId<T>(idSchema);\r\n\r\n  return (\r\n    <HelperText id={id}>\r\n      {errors.map((error, i) => {\r\n        return (\r\n          <FormHelperText>\r\n            <HelperText>\r\n              <HelperTextItem variant=\"error\" key={i} className='pf-v5-u-p-0, pf-v5-u-m-0'>\r\n                <small className='m-0 text-danger'>{error}</small>\r\n              </HelperTextItem>\r\n            </HelperText> \r\n          </FormHelperText>\r\n        );\r\n      })}\r\n    </HelperText>\r\n  );\r\n}\r\n","import { FieldHelpProps, FormContextType, RJSFSchema, StrictRJSFSchema, helpId } from '@react-jsf/utils';\r\nimport { FormHelperText, HelperText, HelperTextItem } from '@patternfly/react-core';\r\n\r\n/** The `FieldHelpTemplate` component renders any help desired for a field\r\n *\r\n * @param props - The `FieldHelpProps` to be rendered\r\n */\r\nexport default function FieldHelpTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: FieldHelpProps<T, S, F>) {\r\n  const { idSchema, help, hasErrors } = props;\r\n  if (!help) {\r\n    return null;\r\n  }\r\n  const id = helpId<T>(idSchema);\r\n  return (\r\n    <FormHelperText>\r\n      <HelperText>\r\n        <HelperTextItem id={id} variant={hasErrors ? 'error' : undefined}>{help}</HelperTextItem>\r\n      </HelperText>\r\n    </FormHelperText>\r\n  );\r\n}\r\n","import {\r\n  FieldTemplateProps,\r\n  FormContextType,\r\n  getTemplate,\r\n  getUiOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n} from '@react-jsf/utils';\r\nimport { FormGroup, TextInput } from '@patternfly/react-core';\r\n\r\nexport default function FieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  id,\r\n  children,\r\n  displayLabel,\r\n  rawErrors = [],\r\n  errors,\r\n  help,\r\n  description,\r\n  rawDescription,\r\n  classNames,\r\n  style,\r\n  disabled,\r\n  label,\r\n  hidden,\r\n  onDropPropertyClick,\r\n  onKeyChange,\r\n  readonly,\r\n  required,\r\n  schema,\r\n  uiSchema,\r\n  registry,\r\n}: FieldTemplateProps<T, S, F>) {\r\n  const uiOptions = getUiOptions(uiSchema);\r\n  const WrapIfAdditionalTemplate = getTemplate<'WrapIfAdditionalTemplate', T, S, F>(\r\n    'WrapIfAdditionalTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  if (hidden) {\r\n    return <div className='hidden'>{children}</div>;\r\n  }\r\n  return (\r\n    <WrapIfAdditionalTemplate\r\n      classNames={classNames}\r\n      style={style}\r\n      disabled={disabled}\r\n      id={id}\r\n      label={label}\r\n      onDropPropertyClick={onDropPropertyClick}\r\n      onKeyChange={onKeyChange}\r\n      readonly={readonly}\r\n      required={required}\r\n      schema={schema}\r\n      uiSchema={uiSchema}\r\n      registry={registry}\r\n    >\r\n      <FormGroup label={displayLabel ? label : undefined} isRequired={required} fieldId='{id}'>\r\n        {children}\r\n        {displayLabel && rawDescription && (\r\n          <TextInput validated={rawErrors.length > 0 ? 'error' : 'default'} id={`${id}-description`}>{description}</TextInput>\r\n        )}\r\n        {errors}\r\n        {help}\r\n      </FormGroup>\r\n    </WrapIfAdditionalTemplate>\r\n  );\r\n}\r\n","import { Grid, GridItem } from '@patternfly/react-core';\r\nimport { Panel } from '@patternfly/react-core';\r\n\r\nimport {\r\n  canExpand,\r\n  descriptionId,\r\n  FormContextType,\r\n  getTemplate,\r\n  getUiOptions,\r\n  ObjectFieldTemplateProps,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  titleId,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function ObjectFieldTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  description,\r\n  title,\r\n  properties,\r\n  required,\r\n  uiSchema,\r\n  idSchema,\r\n  schema,\r\n  formData,\r\n  onAddClick,\r\n  disabled,\r\n  readonly,\r\n  registry,\r\n}: ObjectFieldTemplateProps<T, S, F>) {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  const TitleFieldTemplate = getTemplate<'TitleFieldTemplate', T, S, F>('TitleFieldTemplate', registry, uiOptions);\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    uiOptions\r\n  );\r\n  // Button templates are not overridden in the uiSchema\r\n  const {\r\n    ButtonTemplates: { AddButton },\r\n  } = registry.templates;\r\n  return (\r\n    <>\r\n      {title && (\r\n        <TitleFieldTemplate\r\n          id={titleId<T>(idSchema)}\r\n          title={title}\r\n          required={required}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      {description && (\r\n        <DescriptionFieldTemplate\r\n          id={descriptionId<T>(idSchema)}\r\n          description={description}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      <Panel className='pf-v5-u-p-0'>\r\n        {properties.map((element: any, index: number) => (\r\n          <Grid key={index} style={{ marginBottom: '10px' }} className={element.hidden ? 'pf-v5-u-display-none' : undefined}>\r\n            <GridItem sm={12}> {element.content}</GridItem>\r\n          </Grid>\r\n        ))}\r\n        {canExpand(schema, uiSchema, formData) ? (\r\n          <Grid>\r\n            <GridItem sm={3} smOffset={9} className='pf-v5-u-py-sm'>\r\n              <AddButton\r\n                onClick={onAddClick(schema)}\r\n                disabled={disabled || readonly}\r\n                className='object-property-expand'\r\n                uiSchema={uiSchema}\r\n                registry={registry}\r\n              />\r\n            </GridItem>\r\n          </Grid>\r\n        ) : null}\r\n      </Panel>\r\n    </>\r\n  );\r\n}\r\n","import { Button } from '@patternfly/react-core';\r\nimport { FormContextType, getSubmitButtonOptions, RJSFSchema, StrictRJSFSchema, SubmitButtonProps } from '@react-jsf/utils';\r\n\r\nexport default function SubmitButton<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: SubmitButtonProps<T, S, F>\r\n) {\r\n  const { submitText, norender, props: submitButtonProps } = getSubmitButtonOptions<T, S, F>(props.uiSchema);\r\n  if (norender) {\r\n    return null;\r\n  }\r\n  return (\r\n    <div>\r\n      <Button variant='primary' type='submit' {...submitButtonProps}>\r\n        {submitText}\r\n      </Button>\r\n    </div>\r\n  );\r\n}\r\n","import { FormContextType, getUiOptions, RJSFSchema, StrictRJSFSchema, TitleFieldProps } from '@react-jsf/utils';\r\n\r\nexport default function TitleField<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  id,\r\n  title,\r\n  uiSchema,\r\n}: TitleFieldProps<T, S, F>) {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  return (\r\n    <div id={id} className='my-1'>\r\n      <h5>{uiOptions.title || title}</h5>\r\n      <hr className='border-0 bg-secondary' style={{ height: '1px' }} />\r\n    </div>\r\n  );\r\n}\r\n","import { FocusEvent } from 'react';\r\nimport {\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  TranslatableString,\r\n  WrapIfAdditionalTemplateProps,\r\n} from '@react-jsf/utils';\r\nimport { Grid, GridItem } from '@patternfly/react-core';\r\nimport { FormGroup, TextInput } from '@patternfly/react-core';\r\n\r\nexport default function WrapIfAdditionalTemplate<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  classNames,\r\n  style,\r\n  children,\r\n  disabled,\r\n  id,\r\n  label,\r\n  onDropPropertyClick,\r\n  onKeyChange,\r\n  readonly,\r\n  required,\r\n  schema,\r\n  uiSchema,\r\n  registry,\r\n}: WrapIfAdditionalTemplateProps<T, S, F>) {\r\n  const { templates, translateString } = registry;\r\n  // Button templates are not overridden in the uiSchema\r\n  const { RemoveButton } = templates.ButtonTemplates;\r\n  const keyLabel = translateString(TranslatableString.KeyLabel, [label]);\r\n  const additional = ADDITIONAL_PROPERTY_FLAG in schema;\r\n\r\n  if (!additional) {\r\n    return (\r\n      <div className={classNames} style={style}>\r\n        {children}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const handleBlur = ({ target }: FocusEvent<HTMLInputElement>) => onKeyChange(target.value);\r\n  const keyId = `${id}-key`;\r\n\r\n  return (\r\n    <Grid className={classNames} style={style} key={keyId}>\r\n      <GridItem sm={5}>\r\n        <FormGroup label={keyLabel} fieldId={keyId}>\r\n          <TextInput\r\n            isRequired={required}\r\n            defaultValue={label}\r\n            isDisabled={disabled || readonly}\r\n            id={keyId}\r\n            name={keyId}\r\n            onBlur={!readonly ? handleBlur : undefined}\r\n          />\r\n        </FormGroup>\r\n      </GridItem>\r\n      <GridItem sm={5}>{children}</GridItem>\r\n      <GridItem sm={2} className='py-4'>\r\n        <RemoveButton\r\n          iconType='block'\r\n          className='w-100'\r\n          disabled={disabled || readonly}\r\n          onClick={onDropPropertyClick(label)}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      </GridItem>\r\n    </Grid>\r\n  );\r\n}\r\n","import AddButton from '../AddButton';\r\nimport ArrayFieldItemTemplate from '../ArrayFieldItemTemplate';\r\nimport ArrayFieldTemplate from '../ArrayFieldTemplate';\r\nimport BaseInputTemplate from '../BaseInputTemplate/BaseInputTemplate';\r\nimport DescriptionField from '../DescriptionField';\r\nimport ErrorList from '../ErrorList';\r\nimport { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } from '../IconButton';\r\nimport FieldErrorTemplate from '../FieldErrorTemplate';\r\nimport FieldHelpTemplate from '../FieldHelpTemplate';\r\nimport FieldTemplate from '../FieldTemplate';\r\nimport ObjectFieldTemplate from '../ObjectFieldTemplate';\r\nimport SubmitButton from '../SubmitButton';\r\nimport TitleField from '../TitleField';\r\nimport WrapIfAdditionalTemplate from '../WrapIfAdditionalTemplate';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, TemplatesType } from '@react-jsf/utils';\r\n\r\nexport function generateTemplates<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): Partial<TemplatesType<T, S, F>> {\r\n  return {\r\n    ArrayFieldItemTemplate,\r\n    ArrayFieldTemplate,\r\n    BaseInputTemplate,\r\n    ButtonTemplates: {\r\n      AddButton,\r\n      CopyButton,\r\n      MoveDownButton,\r\n      MoveUpButton,\r\n      RemoveButton,\r\n      SubmitButton,\r\n    },\r\n    DescriptionFieldTemplate: DescriptionField,\r\n    ErrorListTemplate: ErrorList,\r\n    FieldErrorTemplate,\r\n    FieldHelpTemplate,\r\n    FieldTemplate,\r\n    ObjectFieldTemplate,\r\n    TitleFieldTemplate: TitleField,\r\n    WrapIfAdditionalTemplate,\r\n  };\r\n}\r\n\r\nexport default generateTemplates();\r\n","import { FocusEvent } from 'react';\r\nimport {\r\n  ariaDescribedByIds,\r\n  descriptionId,\r\n  getTemplate,\r\n  labelValue,\r\n  WidgetProps,\r\n  schemaRequiresTrueValue,\r\n  StrictRJSFSchema,\r\n  RJSFSchema,\r\n  FormContextType,\r\n} from '@react-jsf/utils';\r\nimport { FormGroup, Checkbox } from '@patternfly/react-core';\r\nexport default function CheckboxWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(props: WidgetProps<T, S, F>) {\r\n  const {\r\n    id,\r\n    value,\r\n    disabled,\r\n    readonly,\r\n    label,\r\n    hideLabel,\r\n    schema,\r\n    autofocus,\r\n    options,\r\n    onChange,\r\n    onBlur,\r\n    onFocus,\r\n    registry,\r\n    uiSchema,\r\n  } = props;\r\n  // Because an unchecked checkbox will cause html5 validation to fail, only add\r\n  // the \"required\" attribute if the field value must be \"true\", due to the\r\n  // \"const\" or \"enum\" keywords\r\n  const required = schemaRequiresTrueValue<S>(schema);\r\n  const DescriptionFieldTemplate = getTemplate<'DescriptionFieldTemplate', T, S, F>(\r\n    'DescriptionFieldTemplate',\r\n    registry,\r\n    options\r\n  );\r\n\r\n  const _onChange = ({ target: { checked } }: FocusEvent<HTMLInputElement>) => onChange(checked);\r\n  const _onBlur = ({ target }: FocusEvent<HTMLInputElement>) => onBlur(id, target && target.checked);\r\n  const _onFocus = ({ target }: FocusEvent<HTMLInputElement>) => onFocus(id, target && target.checked);\r\n\r\n  const description = options.description || schema.description;\r\n  return (\r\n    <FormGroup\r\n      className={`checkbox ${disabled || readonly ? 'disabled' : ''}`}\r\n      aria-describedby={ariaDescribedByIds<T>(id)}\r\n    >\r\n      {!hideLabel && !!description && (\r\n        <DescriptionFieldTemplate\r\n          id={descriptionId<T>(id)}\r\n          description={description}\r\n          schema={schema}\r\n          uiSchema={uiSchema}\r\n          registry={registry}\r\n        />\r\n      )}\r\n      <Checkbox\r\n        id={id}\r\n        name={id}\r\n        label={labelValue(label, hideLabel || !label)}\r\n        checked={typeof value === 'undefined' ? false : value}\r\n        isRequired={required}\r\n        isDisabled={disabled || readonly}\r\n        autoFocus={autofocus}\r\n        onChange={() => _onChange}\r\n        onBlur={_onBlur}\r\n        onFocus={_onFocus}\r\n      />\r\n    </FormGroup>\r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent } from 'react';\r\nimport { FormGroup, Checkbox } from '@patternfly/react-core';\r\nimport {\r\n  ariaDescribedByIds,\r\n  enumOptionsDeselectValue,\r\n  enumOptionsIsSelected,\r\n  enumOptionsSelectValue,\r\n  enumOptionsValueForIndex,\r\n  optionId,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function CheckboxesWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({ id, disabled, options, value, autofocus, readonly, required, onChange, onBlur, onFocus }: WidgetProps<T, S, F>) {\r\n  const { enumOptions, enumDisabled, inline, emptyValue } = options;\r\n  const checkboxesValues = Array.isArray(value) ? value : [value];\r\n\r\n  const _onChange =\r\n    (index: number) =>\r\n    ({ target: { checked } }: ChangeEvent<HTMLInputElement>) => {\r\n      if (checked) {\r\n        onChange(enumOptionsSelectValue<S>(index, checkboxesValues, enumOptions));\r\n      } else {\r\n        onChange(enumOptionsDeselectValue<S>(index, checkboxesValues, enumOptions));\r\n      }\r\n    };\r\n\r\n  const _onBlur = ({ target }: FocusEvent<HTMLInputElement>) =>\r\n    onBlur(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue));\r\n  const _onFocus = ({ target }: FocusEvent<HTMLInputElement>) =>\r\n    onFocus(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue));\r\n\r\n  return (\r\n    <FormGroup role=\"group\" isInline={inline} isStack={!inline}>\r\n      {Array.isArray(enumOptions) &&\r\n        enumOptions.map((option, index: number) => {\r\n          const checked = enumOptionsIsSelected<S>(option.value, checkboxesValues);\r\n          const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\r\n\r\n          return (\r\n            <Checkbox\r\n              key={option.value}\r\n              isRequired={required}\r\n              checked={checked}\r\n              className='bg-transparent border-0'\r\n              id={optionId(id, index)}\r\n              name={id}\r\n              label={option.label}\r\n              autoFocus={autofocus && index === 0}\r\n              onChange={() => _onChange(index)}\r\n              onBlur={_onBlur}\r\n              onFocus={_onFocus}\r\n              isDisabled={disabled || itemDisabled || readonly}\r\n              aria-describedby={ariaDescribedByIds<T>(id)}\r\n            />\r\n          );\r\n        })}\r\n    </FormGroup>\r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent } from 'react';\r\nimport { FormGroup, Radio } from '@patternfly/react-core';\r\nimport {\r\n  ariaDescribedByIds,\r\n  enumOptionsIsSelected,\r\n  enumOptionsValueForIndex,\r\n  optionId,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function RadioWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>({\r\n  id,\r\n  options,\r\n  value,\r\n  disabled,\r\n  readonly,\r\n  onChange,\r\n  onBlur,\r\n  onFocus,\r\n}: WidgetProps<T, S, F>) {\r\n  const { enumOptions, enumDisabled, emptyValue } = options;\r\n\r\n  const _onChange = ({ target: { value } }: ChangeEvent<HTMLInputElement>) =>\r\n    onChange(enumOptionsValueForIndex<S>(value, enumOptions, emptyValue));\r\n  const _onBlur = ({ target }: FocusEvent<HTMLInputElement>) =>\r\n    onBlur(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue));\r\n  const _onFocus = ({ target }: FocusEvent<HTMLInputElement>) =>\r\n    onFocus(id, enumOptionsValueForIndex<S>(target && target.value, enumOptions, emptyValue));\r\n\r\n  const inline = Boolean(options && options.inline);\r\n\r\n  return (\r\n    <FormGroup className='pf-v5-u-mb-sm' role=\"radiogroup\" isInline={inline} isStack={!inline}>\r\n      {Array.isArray(enumOptions) &&\r\n        enumOptions.map((option, index) => {\r\n          const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;\r\n          const checked = enumOptionsIsSelected<S>(option.value, value);\r\n\r\n          const radio = (\r\n            <Radio\r\n              label={option.label}\r\n              id={optionId(id, index)}\r\n              key={index}\r\n              name={id}\r\n              isDisabled={disabled || itemDisabled || readonly}\r\n              checked={checked}\r\n              value={String(index)}\r\n              onChange={() => _onChange}\r\n              onBlur={_onBlur}\r\n              onFocus={_onFocus}\r\n              aria-describedby={ariaDescribedByIds<T>(id)}\r\n            />\r\n          );\r\n          return radio;\r\n        })}\r\n    </FormGroup>\r\n  );\r\n}\r\n","import { FormContextType, getTemplate, labelValue, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\n\r\nexport default function RangeWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  props: WidgetProps<T, S, F>\r\n) {\r\n  const { value, label, hideLabel, options, registry } = props;\r\n  const BaseInputTemplate = getTemplate<'BaseInputTemplate', T, S, F>('BaseInputTemplate', registry, options);\r\n  return (\r\n    <BaseInputTemplate {...props} extraProps={{ label: labelValue(label || undefined, hideLabel) }}>\r\n      <span className='range-view'>{value}</span>\r\n    </BaseInputTemplate>\r\n  );\r\n}\r\n","import {\r\n  FormSelect,\r\n  FormSelectOption,\r\n} from '@patternfly/react-core';\r\nimport {\r\n  ariaDescribedByIds,\r\n  FormContextType,\r\n  enumOptionsIndexForValue,\r\n  enumOptionsValueForIndex,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  WidgetProps,\r\n} from '@react-jsf/utils';\r\n\r\nexport default function SelectWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  schema,\r\n  id,\r\n  options,\r\n  required,\r\n  disabled,\r\n  readonly,\r\n  value,\r\n  multiple,\r\n  autofocus,\r\n  onChange,\r\n  onBlur,\r\n  onFocus,\r\n  placeholder,\r\n  rawErrors = [],\r\n}: WidgetProps<T, S, F>) {\r\n  const { enumOptions, enumDisabled, emptyValue: optEmptyValue } = options;\r\n\r\n  const emptyValue = multiple ? [] : '';\r\n\r\n  function getValue(event: any, multiple?: boolean) {\r\n    if (multiple) {\r\n      return [].slice\r\n        .call(event.target.options as any)\r\n        .filter((o: any) => o.selected)\r\n        .map((o: any) => o.value);\r\n    } else {\r\n      return event.target.value;\r\n    }\r\n  }\r\n  const selectedIndexes = enumOptionsIndexForValue<S>(value, enumOptions, multiple);\r\n  const showPlaceholderOption = !multiple && schema.default === undefined;\r\n\r\n  return (\r\n    <FormSelect\r\n      as='select'\r\n      id={id}\r\n      name={id}\r\n      value={typeof selectedIndexes === 'undefined' ? emptyValue : selectedIndexes}\r\n      isRequired={required}\r\n      multiple={multiple}\r\n      isDisabled={disabled || readonly}\r\n      autoFocus={autofocus}\r\n      className={rawErrors.length > 0 ? 'is-invalid' : ''}\r\n      onBlur={\r\n        onBlur &&\r\n        ((event) => {\r\n          const newValue = getValue(event, multiple);\r\n          onBlur(id, enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyValue));\r\n        })\r\n      }\r\n      onFocus={\r\n        onFocus &&\r\n        ((event) => {\r\n          const newValue = getValue(event, multiple);\r\n          onFocus(id, enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyValue));\r\n        })\r\n      }\r\n      onChange={(event) => {\r\n        const newValue = getValue(event, multiple);\r\n        onChange(enumOptionsValueForIndex<S>(newValue, enumOptions, optEmptyValue));\r\n      }}\r\n      aria-describedby={ariaDescribedByIds<T>(id)}\r\n    >\r\n      {showPlaceholderOption && <FormSelectOption label={placeholder ? placeholder: ''} value=''/>}\r\n      {(enumOptions as any).map(({ value, label }: any, i: number) => {\r\n        const disabled: any = Array.isArray(enumDisabled) && (enumDisabled as any).indexOf(value) != -1;\r\n        return (\r\n          <FormSelectOption key={i} id={label} label={label} value={String(i)} isDisabled={disabled}/>\r\n        );\r\n      })}\r\n    </FormSelect>\r\n    \r\n  );\r\n}\r\n","import { ChangeEvent, FocusEvent } from 'react';\r\nimport { ariaDescribedByIds, FormContextType, RJSFSchema, StrictRJSFSchema, WidgetProps } from '@react-jsf/utils';\r\nimport { FormGroup, TextArea } from '@patternfly/react-core';\r\ntype CustomWidgetProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = WidgetProps<\r\n  T,\r\n  S,\r\n  F\r\n> & {\r\n  options: any;\r\n};\r\n\r\nexport default function TextareaWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>({\r\n  id,\r\n  placeholder,\r\n  value,\r\n  required,\r\n  disabled,\r\n  autofocus,\r\n  readonly,\r\n  onBlur,\r\n  onFocus,\r\n  onChange,\r\n  options,\r\n}: CustomWidgetProps<T, S, F>) {\r\n  const _onChange = ({ target: { value } }: ChangeEvent<HTMLTextAreaElement>) =>\r\n    onChange(value === '' ? options.emptyValue : value);\r\n  const _onBlur = ({ target }: FocusEvent<HTMLTextAreaElement>) => onBlur(id, target && target.value);\r\n  const _onFocus = ({ target }: FocusEvent<HTMLTextAreaElement>) => onFocus(id, target && target.value);\r\n\r\n  return (\r\n    <FormGroup fieldId={id} >\r\n      <TextArea\r\n        id={id}\r\n        name={id}\r\n        placeholder={placeholder}\r\n        isDisabled={disabled}\r\n        readOnly={readonly}\r\n        value={value}\r\n        isRequired={required}\r\n        autoFocus={autofocus}\r\n        rows={options.rows || 5}\r\n        onChange={() => _onChange}\r\n        onBlur={() => _onBlur}\r\n        onFocus={() => _onFocus}\r\n        aria-describedby={ariaDescribedByIds<T>(id)}\r\n      />\r\n    </FormGroup>\r\n  );\r\n}\r\n","import CheckboxWidget from '../CheckboxWidget/CheckboxWidget';\r\nimport CheckboxesWidget from '../CheckboxesWidget/CheckboxesWidget';\r\nimport RadioWidget from '../RadioWidget/RadioWidget';\r\nimport RangeWidget from '../RangeWidget/RangeWidget';\r\nimport SelectWidget from '../SelectWidget/SelectWidget';\r\nimport TextareaWidget from '../TextareaWidget/TextareaWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nexport function generateWidgets<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): RegistryWidgetsType<T, S, F> {\r\n  return {\r\n    CheckboxWidget,\r\n    CheckboxesWidget,\r\n    RadioWidget,\r\n    RangeWidget,\r\n    SelectWidget,\r\n    TextareaWidget,\r\n  };\r\n}\r\n\r\nexport default generateWidgets();\r\n","import { ThemeProps } from '@react-jsf/core';\r\nimport { generateTemplates } from '../Templates';\r\nimport { generateWidgets } from '../Widgets';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\nimport {Form } from '@patternfly/react-core';export function generateTheme<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(): ThemeProps<T, S, F> {\r\n  return {\r\n    templates: generateTemplates<T, S, F>(),\r\n    widgets: generateWidgets<T, S, F>(),\r\n    _internalFormWrapper: Form,\r\n  };\r\n}\r\n\r\nexport default generateTheme();\r\n","import { withTheme} from '@react-jsf/core';\r\nimport { generateTheme } from '../Theme';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\nexport function generateForm<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n//>(): ComponentType<FormProps<T, S, F>> {\r\n>() {  \r\n  return withTheme<T, S, F>(generateTheme<T, S, F>());\r\n}\r\n\r\nexport default generateForm();\r\n","import { forwardRef } from 'react';\r\nimport Form, { FormProps } from './components/Form';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '@react-jsf/utils';\r\n\r\n/** The properties for the `withTheme` function, essentially a subset of properties from the `FormProps` that can be\r\n * overridden while creating a theme\r\n */\r\nexport type ThemeProps<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any> = Pick<\r\n  FormProps<T, S, F>,\r\n  'fields' | 'templates' | 'widgets' | '_internalFormWrapper'\r\n>;\r\n\r\n/** A Higher-Order component that creates a wrapper around a `Form` with the overrides from the `WithThemeProps` */\r\nexport default function withTheme<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  themeProps: ThemeProps<T, S, F>\r\n) {  \r\n// ): ComponentType<FormProps<T, S, F>> {\r\n  return forwardRef<HTMLFormElement, FormProps<T, S, F> >(\r\n   //  Warning: Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?\r\n   //({ fields, widgets, templates, ...directProps }: FormProps<T, S, F>, ref: ForwardedRef<Form<T, S, F>>) => {\r\n   ({ fields, widgets, templates, ...directProps }: FormProps<T, S, F>, ref) => {\r\n      fields = { ...themeProps?.fields, ...fields };\r\n      widgets = { ...themeProps?.widgets, ...widgets };\r\n      templates = {\r\n        ...themeProps?.templates,\r\n        ...templates,\r\n        ButtonTemplates: {\r\n          ...themeProps?.templates?.ButtonTemplates,\r\n          ...templates?.ButtonTemplates,\r\n        },\r\n      };\r\n      return (\r\n        <Form\r\n          {...themeProps}\r\n          {...directProps}\r\n          fields={fields}\r\n          widgets={widgets}\r\n          templates={templates}\r\n          formRef={ref}\r\n        />\r\n      );\r\n    }\r\n  );\r\n}","import Form from './Form/Form';\r\n\r\nexport { default as Form, generateForm } from './Form';\r\nexport { default as Templates, generateTemplates } from './Templates';\r\nexport { default as Theme, generateTheme } from './Theme';\r\nexport { default as Widgets, generateWidgets } from './Widgets';\r\n\r\nexport default Form;\r\n","import React from \"react\";\r\nimport { useCookies } from 'react-cookie';\r\nimport { Link, useLocation } from \"react-router-dom\";\r\nimport { RJSFSchema } from '@react-jsf/utils';\r\nimport { \r\n    Card,\r\n    CardBody,\r\n    CardFooter,\r\n    PageSection,\r\n    PageSectionVariants,\r\n    Text,\r\n    TextContent,\r\n  } from '@patternfly/react-core';\r\nimport validator from '@react-jsf/ajv';\r\nimport Form from \"@react-jsf/patternfly\";\r\n\r\nfunction ConfigurationDataEditForm() {\r\n    const [cookies] = useCookies(['XSRF-TOKEN']);\r\n    const schema: RJSFSchema = require(\"./json-files/config-data-schema.json\");\r\n    const uiSchema = require(\"./json-files/config-data-form-uischema-edit.json\");\r\n    const { state } = useLocation();\r\n    const formData = {...state};\r\n    const log = (type: any) => console.log.bind(console, type);\r\n    // const schema: RJSFSchema = schemaForm;\r\n    // const formData = require(\"./json-files/config-data-form-data.json\")\r\n    async function submitData(data: any) {\r\n        console.log('submitted data', data)\r\n        console.log('submitted for data', data.formData)\r\n        try {\r\n            const requestOptions = {\r\n                method: 'PUT',\r\n                headers: { 'Content-Type': 'application/json', 'accept': 'application/json', 'X-XSRF-TOKEN': cookies['XSRF-TOKEN']  },\r\n                body: JSON.stringify([data.formData]),\r\n            };\r\n            await fetch(\"/my-camel/admin/api/spring-config/configurations\", requestOptions);\r\n        } catch (err) {\r\n            console.log(err);\r\n        }\r\n    }\r\n    return (\r\n        <>\r\n          <PageSection variant={PageSectionVariants.light}>\r\n            <TextContent>\r\n              <Text component=\"h4\">Camel Integrator Configurations: {state.application}/{state.profile} </Text>\r\n              <Text component=\"p\">Edit configurations for an application profile</Text>\r\n            </TextContent>\r\n            <div className=\"small form-group d-flex align-items-center justify-content-between mt-4 mb-0\">\r\n              <Link to=\"/spring-config\">\r\n                Go to configurations page\r\n              </Link>\r\n            </div>\r\n          </PageSection>\r\n          <PageSection>\r\n            <Card>\r\n              <CardBody>\r\n                <Form schema={schema} uiSchema={uiSchema} formData={formData} validator={validator} onSubmit={data => submitData(data)} />\r\n              </CardBody>\r\n              <CardFooter>\r\n                <div className=\"small form-group d-flex align-items-center justify-content-between mt-4 mb-0\">\r\n                  <Link to=\"/spring-config\">\r\n                    Go to configurations page\r\n                  </Link>\r\n                </div>\r\n              </CardFooter>\r\n            </Card>\r\n          </PageSection>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default ConfigurationDataEditForm;\r\n","import React from \"react\";\r\nimport { useCookies } from 'react-cookie';\r\nimport { CookiesProvider } from 'react-cookie';\r\nimport { Link } from \"react-router-dom\";\r\nimport {\r\n    Card,\r\n    CardBody,\r\n    CardFooter,\r\n    PageSection,\r\n    PageSectionVariants,\r\n    Text,\r\n    TextContent,\r\n  } from '@patternfly/react-core';\r\nimport { RJSFSchema } from '@react-jsf/utils';\r\nimport validator from '@react-jsf/ajv';\r\nimport Form from \"@react-jsf/patternfly\";\r\n\r\nfunction ConfigurationDataCreateForm() {\r\n    const [cookies] = useCookies(['XSRF-TOKEN']);\r\n    const schema: RJSFSchema = require(\"./json-files/config-data-schema.json\");\r\n    const uiSchema = require(\"./json-files/config-data-form-uischema-create.json\");\r\n    const log = (type: any) => console.log.bind(console, type);\r\n    // const schema: RJSFSchema = schemaForm;\r\n    const formData = require(\"./json-files/config-data-form-data.json\")\r\n    async function submitData(data: any) {\r\n        console.log('submitted data', data)\r\n        console.log('submitted for data', data.formData)\r\n        try {\r\n            const requestOptions = {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json', 'accept': 'application/json', 'X-XSRF-TOKEN': cookies['XSRF-TOKEN'] },\r\n                body: JSON.stringify([data.formData]),\r\n            };\r\n            await fetch(\"/my-camel/admin/api/spring-config/configurations\", requestOptions);\r\n        } catch (err) {\r\n            console.log(err);\r\n        }\r\n    }\r\n    return (\r\n        <>\r\n          <PageSection variant={PageSectionVariants.light}>\r\n            <TextContent>\r\n              <Text component=\"h4\">Camel Integrator Configurations</Text>\r\n              <Text component=\"p\">Create configurations for an application profile</Text>\r\n            </TextContent>\r\n              <div className=\"small form-group d-flex align-items-center justify-content-between mt-4 mb-0\">\r\n                <Link to=\"/spring-config\">\r\n                  Go to configurations page\r\n                </Link>\r\n              </div>\r\n          </PageSection>\r\n          <PageSection>\r\n            <Card>\r\n              <CardBody>\r\n                <Form schema={schema} uiSchema={uiSchema} formData={formData} validator={validator} onSubmit={data => submitData(data)} />\r\n              </CardBody>\r\n              <CardFooter>\r\n                <div className=\"small form-group d-flex align-items-center justify-content-between mt-4 mb-0\">\r\n                  <Link to=\"/spring-config\">\r\n                    Go to configurations page\r\n                  </Link>\r\n                </div>\r\n              </CardFooter>\r\n            </Card>\r\n          </PageSection>\r\n          </>\r\n    )\r\n}\r\nexport default ConfigurationDataCreateForm;\r\n","import React from \"react\";\r\nimport { Link, useLocation, useNavigate } from \"react-router-dom\";\r\nimport {\r\n  Button,\r\n  Card,\r\n  CardBody,\r\n  CardFooter,\r\n  Pagination,\r\n  PaginationVariant,\r\n  PageSection,\r\n  PageSectionVariants,\r\n  Text,\r\n  TextContent\r\n} from '@patternfly/react-core';\r\n\r\nimport { Table, Thead, Tr, Th, Tbody, Td, ThProps } from '@patternfly/react-table';\r\nimport { ConfigurationProperty } from \"./ConfigurationModel\";\r\n\r\nfunction ConfigurationAppDetails() {\r\n  const { state } = useLocation();\r\n  const [page, setPage] = React.useState(1);\r\n  const [perPage, setPerPage] = React.useState(5);\r\n  const [paginatedRows, setPaginatedRows] = React.useState<ConfigurationProperty[]>(state.props.slice((page - 1) * perPage, page * perPage));\r\n  const [activeSortIndex, setActiveSortIndex] = React.useState<number | undefined>(undefined);\r\n  // Sort direction of the currently sorted column\r\n  const [activeSortDirection, setActiveSortDirection] = React.useState<'asc' | 'desc' | undefined>(undefined);\r\n  const navigate = useNavigate();\r\n  const editConfig = () => {\r\n    navigate(\"/spring-config/edit\", {state: {...state}})\r\n  }\r\n  const appConfigColumns = [\r\n    {\r\n      dataField: \"propKey\",\r\n      text: \"Property\",\r\n      sort: true,\r\n      editable: false\r\n    },\r\n    {\r\n      dataField: \"propValue\",\r\n      text: \"Profile\",\r\n      sort: false,\r\n      editable: false\r\n    }\r\n  ];\r\n\r\n  const handleSetPage = (\r\n    _evt: React.MouseEvent | React.KeyboardEvent | MouseEvent,\r\n    newPage: number,\r\n    _perPage: number | undefined,\r\n    startIdx: number | undefined,\r\n    endIdx: number | undefined\r\n  ) => {\r\n    setPaginatedRows(state.props.slice(startIdx, endIdx));\r\n    setPage(newPage);\r\n  };\r\n\r\n  const handlePerPageSelect = (\r\n    _evt: React.MouseEvent | React.KeyboardEvent | MouseEvent,\r\n    newPerPage: number,\r\n    _newPage: number,\r\n    startIdx: number | undefined,\r\n    endIdx: number | undefined\r\n  ) => {\r\n    setPaginatedRows(state.props.slice(startIdx, endIdx));\r\n    setPerPage(newPerPage);\r\n  };\r\n\r\n  const renderPagination = (variant: PaginationVariant) => {\r\n    return (\r\n      <Pagination\r\n        itemCount={state.props.length}\r\n        page={page}\r\n        perPage={perPage}\r\n        onSetPage={handleSetPage}\r\n        onPerPageSelect={handlePerPageSelect}\r\n        variant={variant}\r\n      />\r\n    );\r\n  };\r\n\r\n  const getSortParams = (columnIndex: number): ThProps['sort'] => ({\r\n    sortBy: {\r\n      index: activeSortIndex,\r\n      direction: activeSortDirection,\r\n      defaultDirection: 'asc' // starting sort direction when first sorting a column. Defaults to 'asc'\r\n    },\r\n    onSort: (_event, index, direction) => {\r\n      setActiveSortIndex(index);\r\n      setActiveSortDirection(direction);\r\n    },\r\n    columnIndex\r\n  });\r\n\r\n\r\n  const renderColum = (column: any, row: any) => {\r\n    return <>{row[column['dataField']]}</>\r\n  }\r\n\r\n  return (\r\n      <>\r\n      <PageSection variant={PageSectionVariants.light}>\r\n        <TextContent>\r\n          <Text component=\"h4\">Application Configuration: {state.application}/{state.profile} </Text><Button onClick={() => {editConfig();}}>Edit</Button>\r\n        </TextContent>\r\n      </PageSection>\r\n      <PageSection>\r\n        <Card>\r\n          <CardBody>\r\n\r\n            <Table variant=\"compact\" aria-label=\"Spring configurations\">\r\n              <Thead>\r\n                <Tr>\r\n                  {appConfigColumns.map((column, columnIndex) => (\r\n                  <Th key={columnIndex} sort={column.sort ? getSortParams(columnIndex) : undefined}>{column.text}</Th>\r\n                  ))}\r\n                </Tr>\r\n              </Thead>\r\n              <Tbody>\r\n                {paginatedRows.map((row: any, rowIndex: number) => (\r\n                <Tr key={rowIndex}>\r\n                  {appConfigColumns.map((column, columnIndex) => (\r\n                  <Td key={column.dataField}>\r\n                  {renderColum(column, row)}\r\n                  </Td>\r\n                  ))}\r\n                </Tr>\r\n                ))}\r\n              </Tbody>\r\n            </Table>\r\n            {renderPagination(PaginationVariant.bottom)}\r\n          </CardBody>\r\n          <CardFooter>\r\n            <div className=\"small form-group d-flex align-items-center justify-content-between mt-4 mb-0\">\r\n              <Link to=\"/spring-config\">\r\n                Go to configurations page\r\n              </Link>\r\n            </div>\r\n          </CardFooter>\r\n        </Card>\r\n      </PageSection>\r\n      </> \r\n  );\r\n}\r\n\r\nexport default ConfigurationAppDetails;\r\n","import { createContext } from \"react\";\r\n\r\nexport type ErrorBoundaryContextType = {\r\n  hasError: boolean;\r\n  error: any;\r\n  resetErrorBoundary: (...args: any[]) => void;\r\n  showBoundary: (error: any[]) => void;\r\n};\r\n\r\nexport const ErrorBoundaryContext =\r\n  createContext<ErrorBoundaryContextType | null>(null);","import React from \"react\";\r\nimport { useErrorBoundary  } from './useErrorBoundary';\r\nimport { ErrorBoundaryContext } from \"./ErrorBoundaryContext\";\r\ntype ErrorBoundaryState =\r\n  | {\r\n      hasError: true;\r\n      error: any;\r\n    }\r\n  | {\r\n      hasError: false;\r\n      error: null;\r\n    };\r\n\r\nconst initialState: ErrorBoundaryState = {\r\n  hasError: false,\r\n  error: null,\r\n};\r\n\r\nconst ErrorBoundaryContextProvider= ({ children }: {children: React.ReactNode}) => {\r\n  const [state, setState] = React.useState<ErrorBoundaryState>(initialState);\r\n  const resetErrorBoundary = () => {\r\n     setState(initialState);\r\n  }\r\n  const showBoundary = (error: any) => {\r\n    setState({\r\n        hasError: true,\r\n        error: error\r\n        \r\n    });\r\n }\r\n  return <ErrorBoundaryContext.Provider value={{\r\n    hasError: state.hasError,\r\n    error: state.error,\r\n    resetErrorBoundary: resetErrorBoundary,\r\n    showBoundary: showBoundary\r\n  }}>\r\n    {children}\r\n    </ErrorBoundaryContext.Provider>;\r\n};\r\nexport default ErrorBoundaryContextProvider;","import { useContext, useMemo } from \"react\";\r\nimport { assertErrorBoundaryContext } from \"./assertErrorBoundaryContext\";\r\nimport { ErrorBoundaryContext } from \"./ErrorBoundaryContext\";\r\n\r\n// type UseErrorBoundaryState<TError> =\r\n//   | { error: TError; hasError: true }\r\n//   | { error: null; hasError: false };\r\n\r\nexport type UseErrorBoundaryApi<TError> = {\r\n  hasError: boolean,\r\n  error: any,   \r\n  resetBoundary: () => void;\r\n  showBoundary: (error: TError) => void;\r\n};\r\n\r\nexport function useErrorBoundary<TError = any>(): UseErrorBoundaryApi<TError> {\r\n  const context = useContext(ErrorBoundaryContext);\r\n\r\n  assertErrorBoundaryContext(context);\r\n\r\n  const memoized = useMemo(\r\n    () => ({\r\n      hasError: context.hasError,\r\n      error: context.error,\r\n      resetBoundary: () => {\r\n        context.resetErrorBoundary();\r\n        // setState({ error: null, hasError: false });\r\n      },\r\n      showBoundary: (error: TError) => {\r\n        context.showBoundary(error as any);\r\n        // setState({\r\n        //    error,\r\n        //    hasError: true,\r\n        // })\r\n      }\r\n    }),\r\n    [context.resetErrorBoundary]\r\n  );\r\n\r\n//   if (state.hasError) {\r\n//     throw state.error;\r\n//   }\r\n\r\n  return memoized;\r\n}","import { ErrorBoundaryContextType } from \"./ErrorBoundaryContext\";\r\n\r\nexport function assertErrorBoundaryContext(\r\n  value: any\r\n): asserts value is ErrorBoundaryContextType {\r\n  if (\r\n    value == null ||\r\n    typeof value.hasError !== \"boolean\" ||\r\n    typeof value.resetErrorBoundary !== \"function\" ||\r\n    typeof value.showBoundary !== \"function\"\r\n  ) {\r\n    throw new Error(\"ErrorBoundaryContext not found\");\r\n  }\r\n}","import React from \"react\";\r\nimport { useErrorBoundary  } from './useErrorBoundary';\r\nconst ErrorBoundary = ({ children} : {children: React.ReactNode}) => {\r\n  const { hasError, error, resetBoundary } = useErrorBoundary();\r\n  return <>\r\n    {hasError && (\r\n       <div role=\"alert\">\r\n          <p>Place holder for error handling:</p>\r\n          <pre>{error[\"message\"]}</pre>\r\n          <button onClick={resetBoundary}>Try again</button>\r\n      </div>)}\r\n    {children}\r\n    </>;\r\n};\r\nexport default ErrorBoundary;","import React, { useEffect, useState } from 'react';\r\nimport { Route, Routes} from 'react-router-dom';\r\nimport { CookiesProvider } from 'react-cookie';\r\nimport {MyConfigProvider} from \"../../utils/config/context\";\r\n\r\n// import { useCookies } from 'react-cookie';\r\nimport {\r\n  Button,\r\n  Card,\r\n  Divider,\r\n  Pagination,\r\n  PaginationVariant,\r\n  PageSection,\r\n  PageSectionVariants,\r\n  Text,\r\n  TextContent,\r\n  PageGroup\r\n} from '@patternfly/react-core';\r\n\r\nimport { Table, Thead, Tr, Th, Tbody, Td, ThProps } from '@patternfly/react-table';\r\nimport { useNavigate } from \"react-router-dom\";\r\n// import { useErrorBoundary } from '../../utils/error-boundary/useErrorBoundary';\r\nimport axios from 'axios';\r\nimport { ConfigurationModel } from \"./ConfigurationModel\";\r\nimport DeleteConfirmation from \"./DeleteConfirmation\";\r\nimport ImportConfiguration from './ImportConfiguration';\r\nimport ConfigurationDataEditForm from './ConfigurationDataEditForm';\r\nimport ConfigurationDataCreateForm from './ConfigurationDataCreateForm';\r\nimport ConfigurationAppDetails from './ConfigurationAppDetails';\r\nimport ErrorBoundaryContextProvider from '../../utils/error-boundary/ErrorBoundaryContextProvider';\r\nimport ErrorBoundary from '../../utils/error-boundary/ErrorBoundary';\r\ninterface Translation {\r\n  [key: string]: any;\r\n}\r\n\r\nexport const SpringConfig: React.FunctionComponent = () => {\r\n    // const [cookies] = useCookies(['XSRF-TOKEN']);\r\n    // const { showBoundary } = useErrorBoundary();\r\n    const [displayDeleteConfirmationModal, setDisplayDeleteConfirmationModal] = useState(false);\r\n    const [displayImportConfirmationModal, setDisplayImportConfirmationModal] = useState(false);\r\n    const [displayImportSqlConfirmationModal, setDisplayImportSqlConfirmationModal] = useState(false);\r\n    const [deleteRow, setDeleteRow] = useState<ConfigurationModel|null>(null);\r\n    const [configurations, setconfigurations] = useState<ConfigurationModel[]>([]);\r\n    const [loading, setLoading] = useState(false);\r\n    const [page, setPage] = React.useState(1);\r\n    const [perPage, setPerPage] = React.useState(10);\r\n    const [paginatedRows, setPaginatedRows] = React.useState<ConfigurationModel[]>([]);\r\n    const [activeSortIndex, setActiveSortIndex] = React.useState<number | undefined>(undefined);\r\n    // Sort direction of the currently sorted column\r\n    const [activeSortDirection, setActiveSortDirection] = React.useState<'asc' | 'desc' | undefined>(undefined);\r\n    const navigate = useNavigate(); \r\n    console.log(\"1111111111111111111>>>\", paginatedRows)\r\n    const importConfigurations = (configIle: File) => {\r\n      // data: ConfigurationModel[]| null\r\n      console.log(\">>>>>>>> import configuration:\", configIle);\r\n      const formData = new FormData();\r\n      formData.append('file', configIle);\r\n      // try {\r\n      //     const requestOptions = {\r\n      //         method: 'POST',\r\n      //         headers: {\r\n      //             'content-type': 'multipart/form-data'\r\n      //         },\r\n      //         body: formData,\r\n      //     };\r\n      //     await fetch(\"/api/import\", requestOptions);\r\n      // } catch (err) {\r\n      //     console.log(err);\r\n      // }\r\n      const config = {\r\n          headers: {\r\n              'content-type': 'multipart/form-data',\r\n              // 'X-XSRF-TOKEN': cookies['XSRF-TOKEN']\r\n          },\r\n      };\r\n      axios.post(\"/my-camel/admin/api/spring-config/import\", formData, config).then((response) => {\r\n          console.log(\">>>>>>1>>>>>>>>\", response.data);\r\n          setconfigurations(() => response.data);\r\n          setPaginatedRows(() => configurations.slice((page - 1) * perPage, page * perPage));\r\n          setDisplayImportConfirmationModal(() => false);\r\n      }).catch((error) => {\r\n          console.error(\"Error uploading spring config: \", error);\r\n          // showBoundary(error);\r\n          setDisplayImportConfirmationModal(() =>false);\r\n      });\r\n    }\r\n\r\n    const importSqlConfigurations = (configIle: File) => {\r\n      // data: ConfigurationModel[]| null\r\n      console.log(\">>>>>>>> import configuration:\", configIle);\r\n      const formData = new FormData();\r\n      formData.append('file', configIle);\r\n      // try {\r\n      //     const requestOptions = {\r\n      //         method: 'POST',\r\n      //         headers: {\r\n      //             'content-type': 'multipart/form-data'\r\n      //         },\r\n      //         body: formData,\r\n      //     };\r\n      //     await fetch(\"/s2i-integrator/config/spring/admin/api/configurations/json\", requestOptions);\r\n      // } catch (err) {\r\n      //     console.log(err);\r\n      // }\r\n      const config = {\r\n          headers: {\r\n              'content-type': 'multipart/form-data',\r\n              'accept': '*/*',\r\n              // 'X-XSRF-TOKEN': cookies['XSRF-TOKEN']\r\n          },\r\n      };\r\n      axios.post(\"/my-camel/admin/api/spring-config/sql\", formData, config).then((response) => {\r\n          console.log(response.data);\r\n          setconfigurations(() => response.data);\r\n          setPaginatedRows(() => configurations.slice((page - 1) * perPage, page * perPage));\r\n          setDisplayImportSqlConfirmationModal(() => false);\r\n      }).catch((error) => {\r\n          console.error(\"Error uploading spring config: \", error);\r\n          // showBoundary(error);\r\n          setDisplayImportSqlConfirmationModal(false);\r\n      });\r\n    }\r\n    const hideImportConfigurationModal = () => {\r\n      setDisplayImportConfirmationModal(false);\r\n    };\r\n    const hideImportSqlConfigurationModal = () => {\r\n      setDisplayImportSqlConfirmationModal(false);\r\n    };\r\n    const hideDeleteConfirmationModal = () => {\r\n      setDisplayDeleteConfirmationModal(false);\r\n    };\r\n    const detailsLink = (row: any): JSX.Element => {\r\n      return (\r\n        <>\r\n        <Button\r\n          onClick={() => {\r\n            editAppConfiurationDetails(row);\r\n          }}\r\n        >\r\n          Edit\r\n        </Button>\r\n        <Button\r\n          onClick={() => {\r\n            showAppConfiurationDetails(row);\r\n          }}\r\n        >\r\n          Config\r\n        </Button>\r\n        <Button\r\n          onClick={() => {\r\n            showDeleteModal(row);\r\n          }}\r\n        >\r\n          Delete\r\n        </Button>\r\n        </>\r\n      );\r\n    };\r\n    const exportConfig = () => {\r\n      // const jsonURL = `data:text/json;chatset=utf-8,${encodeURIComponent(\r\n      //   JSON.stringify(configurations)\r\n      // )}`;\r\n      const data = new Blob([JSON.stringify(configurations, null, 2)], { type: \"text/json\" });\r\n      const jsonURL = window.URL.createObjectURL(data);\r\n      const link = document.createElement(\"a\");\r\n      document.body.appendChild(link);\r\n      link.href = jsonURL;\r\n      link.download = \"spring-config.json\";\r\n      link.click();\r\n      document.body.removeChild(link);\r\n    }\r\n    const addAppConfiurationDetails = () => {\r\n      navigate(\"/spring-config/create\")\r\n    }\r\n    const editAppConfiurationDetails = (row: ConfigurationModel) => {\r\n      navigate(\"/spring-config/edit\", {state: {...row}})\r\n    }\r\n    const showAppConfiurationDetails = (row: ConfigurationModel) => {\r\n      navigate(\"/spring-config/details\", {state: {...row}}) \r\n    }\r\n    const showImportConfigurationModal = () => {\r\n      setDisplayImportConfirmationModal(true);\r\n    }\r\n\r\n    const showImportSqlConfigurationModal = () => {\r\n      setDisplayImportSqlConfirmationModal(true);\r\n    }\r\n    const showDeleteModal = (row: ConfigurationModel) => {\r\n      setDeleteRow(() => row);\r\n      setDisplayDeleteConfirmationModal(() => true);\r\n    }\r\n\r\n    async function deleteAppConfiurationDetails(row: ConfigurationModel) {\r\n      console.log('delete app profile', row)\r\n      try {\r\n          const requestOptions = {\r\n              method: 'DELETE',\r\n              headers: { \r\n                'Content-Type': 'application/json', \r\n                'accept': '*/*', \r\n                // 'X-XSRF-TOKEN': cookies['XSRF-TOKEN'] \r\n              },\r\n              body: JSON.stringify([{application: row.application, profile: row.profile}]),\r\n          };\r\n          setLoading(() => true);\r\n          await fetch(\"/my-camel/admin/api/spring-config/configurations\", requestOptions)\r\n                    .then(response => response.json())\r\n                    .then((data: ConfigurationModel[]) => {\r\n                      setconfigurations(() => data);\r\n                      setPaginatedRows(() => configurations.slice((page - 1) * perPage, page * perPage));\r\n                      setLoading(() => false);\r\n                      setDisplayDeleteConfirmationModal(() => false);\r\n                    });\r\n          console.log(\"deleted\");\r\n      } catch (err) {\r\n          console.log(err);\r\n          // showBoundary(err);\r\n      }\r\n    }\r\n\r\n    const configurationTableColumns = [\r\n      {\r\n        dataField: \"application\",\r\n        text: \"Application\",\r\n        sort: true,\r\n        editable: false\r\n      },\r\n      {\r\n        dataField: \"profile\",\r\n        text: \"Profile\",\r\n        sort: false,\r\n        editable: false\r\n      },\r\n      {\r\n        dataField: \"label\",\r\n        text: \"Label\",\r\n        sort: false,\r\n        editable: false\r\n      },\r\n      {\r\n        dataField: \"actions\",\r\n        text: \"Details\",\r\n        sort: false,\r\n        isDummyField: true,\r\n        editable: false,\r\n        formatter: detailsLink,\r\n\r\n      }\r\n    ];\r\n\r\n    console.log(\"222222222222222>>>>>>\", paginatedRows)\r\n    const handleSetPage = (\r\n      _evt: React.MouseEvent | React.KeyboardEvent | MouseEvent,\r\n      newPage: number,\r\n      _perPage: number | undefined,\r\n      startIdx: number | undefined,\r\n      endIdx: number | undefined\r\n    ) => {\r\n      setPaginatedRows(configurations.slice(startIdx, endIdx));\r\n      setPage(newPage);\r\n    };\r\n    const handlePerPageSelect = (\r\n      _evt: React.MouseEvent | React.KeyboardEvent | MouseEvent,\r\n      newPerPage: number,\r\n      _newPage: number,\r\n      startIdx: number | undefined,\r\n      endIdx: number | undefined\r\n    ) => {\r\n      setPaginatedRows(configurations.slice(startIdx, endIdx));\r\n      setPerPage(newPerPage);\r\n    };\r\n    const renderPagination = (variant: PaginationVariant) => {\r\n      return (\r\n        <Pagination\r\n          itemCount={configurations.length}\r\n          page={page}\r\n          perPage={perPage}\r\n          onSetPage={handleSetPage}\r\n          onPerPageSelect={handlePerPageSelect}\r\n          variant={variant}\r\n        />\r\n      );\r\n    };\r\n    const renderColum = (column: any, row: any) => {\r\n      if (column.formatter) {\r\n        return <>{column['formatter'](row)}</>\r\n      } else {\r\n        return <>{row[column['dataField']]}</>\r\n      }\r\n    }\r\n    const getSortParams = (columnIndex: number): ThProps['sort'] => ({\r\n      sortBy: {\r\n        index: activeSortIndex,\r\n        direction: activeSortDirection,\r\n        defaultDirection: 'asc' // starting sort direction when first sorting a column. Defaults to 'asc'\r\n      },\r\n      onSort: (_event, index, direction) => {\r\n        setActiveSortIndex(index);\r\n        setActiveSortDirection(direction);\r\n      },\r\n      columnIndex\r\n    });\r\n\r\n    useEffect(() => {\r\n      setLoading(() => true);\r\n      fetch('/my-camel/admin/api/spring-config/configurations')\r\n        .then(response => response.json())\r\n        .then((data: ConfigurationModel[]) => {\r\n          setconfigurations(() => data);\r\n          console.log(\">>>>>>>>>>>>>>>33333\", page, perPage, data);\r\n          setPaginatedRows(() =>data.slice((page - 1) * perPage, page * perPage));\r\n          setLoading(() => false);\r\n        }).catch(error => {\r\n          // showBoundary(error);\r\n          console.log('... load config error', error);\r\n        });\r\n    }, []);\r\n    \r\n    const navItems = [\r\n      { id: 'create', title: 'Create', element: ConfigurationDataCreateForm },\r\n      { id: 'edit', title: 'Edit', element: ConfigurationDataEditForm },\r\n      { id: 'details', title: 'Details', element: ConfigurationAppDetails},\r\n    ]\r\n  \r\n    const routes = navItems.map(({ id, element }) => (\r\n      <Route key={id} path={id} element={React.createElement(element)} />\r\n    ))\r\n  \r\n    console.log(\">>>>>>>>paginatedRows>>>>>>>>\", paginatedRows);\r\n    console.log(\">>>>>>>>configurations>>>>>>>>\", configurations);\r\n    console.log(\">>>>>>>>perPage>>>>>>>>\", perPage);\r\n    console.log(\">>>>>>>>page>>>>>>>>\", page);\r\n\r\n    const springConfigContent = () => {\r\n      return <>\r\n         <PageGroup>\r\n           <PageSection variant={PageSectionVariants.light}>\r\n             <TextContent>\r\n               <Text component=\"h1\">Camel Integrator Configurations</Text>\r\n               <Text component=\"p\">Spring Application profiles</Text>\r\n             </TextContent>\r\n             <div className=\"small form-group d-flex align-items-center justify-content-start mt-4 mb-0\">\r\n                 <Button className=\"ml-1\" onClick={() => {\r\n                     addAppConfiurationDetails();\r\n                   }}>\r\n                   Add Application Profile\r\n                 </Button>\r\n                 <Button className=\"ml-1\" style={{ 'marginLeft': '12px' }} onClick={exportConfig}>Export All Configurations</Button>\r\n                 <Button className=\"ml-1\" style={{ 'marginLeft': '12px' }} onClick={() => { showImportConfigurationModal();}}>Import All Configurations</Button>\r\n                 <Button className=\"ml-1\" style={{ 'marginLeft': '12px' }} onClick={() => { showImportSqlConfigurationModal();}}>Import SQL</Button>\r\n               </div>\r\n           </PageSection>\r\n           <Divider />\r\n           <PageSection>\r\n             <Card>\r\n             <Table variant=\"compact\" aria-label=\"Spring configurations\">\r\n               <Thead>\r\n                 <Tr>\r\n                   {configurationTableColumns.map((column, columnIndex) => (\r\n                     <Th key={columnIndex} sort={column.sort ? getSortParams(columnIndex) : undefined}>{column.text}</Th>\r\n                   ))}\r\n                 </Tr>\r\n               </Thead>\r\n               <Tbody>\r\n               {paginatedRows.map((row: any, rowIndex: number) => (\r\n                 <Tr key={rowIndex}>\r\n                   {configurationTableColumns.map((column, columnIndex) => (\r\n                     <Td key={column.dataField}>\r\n                         {renderColum(column, row)}\r\n                     </Td>\r\n                   ))}\r\n                 </Tr>\r\n               ))}\r\n               </Tbody>\r\n             </Table>\r\n               {renderPagination(PaginationVariant.bottom)}\r\n             </Card>\r\n             </PageSection>\r\n             <Divider />\r\n             </PageGroup>\r\n             <DeleteConfirmation showModal={displayDeleteConfirmationModal} confirmModal={deleteAppConfiurationDetails} hideModal={hideDeleteConfirmationModal}\r\n               row={deleteRow} message={`Are you sure to delete configurations for application for ${deleteRow?.application}/${deleteRow?.profile}`}  />\r\n             <ImportConfiguration showModal={displayImportConfirmationModal} importConfiguration={importConfigurations} hideModal={hideImportConfigurationModal}  />\r\n             <ImportConfiguration showModal={displayImportSqlConfirmationModal} importConfiguration={importSqlConfigurations} hideModal={hideImportSqlConfigurationModal}  />\r\n         <PageSection id='connect-main' variant={PageSectionVariants.light}>\r\n              <Routes>\r\n                {routes}\r\n              </Routes>\r\n         </PageSection>\r\n      </>;\r\n    }\r\n    if (loading) {\r\n      return <p>Loading...</p>;\r\n    } else {\r\n      return (\r\n        <>\r\n          <CookiesProvider>\r\n            <MyConfigProvider>\r\n              <ErrorBoundaryContextProvider>\r\n                <ErrorBoundary>\r\n                  {springConfigContent()}\r\n                </ErrorBoundary>\r\n              </ErrorBoundaryContextProvider>\r\n            </MyConfigProvider>\r\n          </CookiesProvider>\r\n\r\n        </>\r\n      );\r\n    }\r\n}","import { useCookies } from 'react-cookie';\r\nimport {\r\n  PageSection, \r\n  PageSectionVariants, \r\n  Text, \r\n  TextContent,\r\n  Form,\r\n  FormGroup,\r\n  TextInput,\r\n  ActionGroup,\r\n  Button,\r\n  HelperText,\r\n  HelperTextItem,\r\n  FormHelperText\r\n} from '@patternfly/react-core';\r\nimport React from 'react'\r\nimport { RefreshConfigModel } from './model';\r\n\r\nexport const RefreshConfig: React.FunctionComponent = () => {\r\n  const [mpgPods, setMpgPods] = React.useState('');\r\n  const [ccpayPods, setCcpayPods] = React.useState('');\r\n  const [servicePods, setServicePods] = React.useState('');\r\n  const [isRefreshing, setIsRefreshing] = React.useState<boolean>(false);\r\n  const [refreshResult, setRefreshResult] = React.useState('');\r\n  interface RefreshingPropsType {\r\n    spinnerAriaValueText: string;\r\n    spinnerAriaLabelledBy?: string;\r\n    spinnerAriaLabel?: string;\r\n    isLoading: boolean;\r\n  }\r\n\r\n  const primaryRefreshingProps = {} as RefreshingPropsType;\r\n  primaryRefreshingProps.spinnerAriaValueText = 'Loading';\r\n  primaryRefreshingProps.spinnerAriaLabelledBy = 'primary-loading-button';\r\n  primaryRefreshingProps.isLoading = isRefreshing;\r\n\r\n  const refreshConfig = async () => {\r\n    // const [cookies] = useCookies(['XSRF-TOKEN']);\r\n    \r\n    let refreshConfigUrls: RefreshConfigModel[] = [];\r\n    mpgPods.length > 0 && mpgPods.split(\",\").forEach((pod) =>  refreshConfigUrls.push({\r\n        pod: pod,\r\n        refreshUrl: pod.startsWith('http://') || pod.startsWith('https://') ? pod : `http://${pod}:8080/actuator/refresh`\r\n        }));\r\n    ccpayPods.length > 0 && ccpayPods.split(\",\").forEach((pod) =>  refreshConfigUrls.push({\r\n        pod: pod,\r\n        refreshUrl: pod.startsWith('http://') || pod.startsWith('https://') ? pod : `http://${pod}:8080/actuator/refresh`\r\n        }));\r\n    servicePods.length > 0 && servicePods.split(\",\").forEach((pod) =>  refreshConfigUrls.push({\r\n        pod: pod,\r\n        refreshUrl: pod.startsWith('http://') || pod.startsWith('https://') ? pod : `http://${pod}:8080/actuator/refresh`\r\n        }));\r\n    console.log('Refresh config for ', refreshConfigUrls)\r\n    try {\r\n        const requestOptions = {\r\n            method: 'POST',\r\n            // headers: { 'Content-Type': 'application/json', 'accept': '*/*', 'X-XSRF-TOKEN': cookies['XSRF-TOKEN'] },\r\n            headers: { 'Content-Type': 'application/json', 'accept': '*/*' },\r\n            body: JSON.stringify({\r\n                requestHeader: {\r\n                    traceId: '123'\r\n                },\r\n                refreshConfigurations: refreshConfigUrls\r\n            }),\r\n        };\r\n        setIsRefreshing(() => true);\r\n        await fetch(\"/my-camel/admin/api/refreshConfig\", requestOptions)\r\n        // await fetch(\"/api/refreshConfig\", requestOptions)\r\n                    .then(response => response.json())\r\n                    .then((data: any) => {\r\n                      setRefreshResult(() => JSON.stringify(data));\r\n                      setIsRefreshing(() => false);\r\n                    });\r\n        console.log(\"done refreshing\");\r\n    } catch (err) {\r\n        console.log(err);\r\n        setIsRefreshing(() => false);\r\n        setRefreshResult(() => JSON.stringify(err));\r\n    }    \r\n    \r\n  }\r\n  return <>\r\n    <PageSection variant={PageSectionVariants.light}>\r\n      <TextContent>\r\n        <Text component='h1'>Refresh S2I integrator Configurations</Text>\r\n        <Text component='p'>Refresh Configurations of S2I MPG, CCPay and Services integrators</Text>\r\n        (refreshR)\r\n      </TextContent>\r\n      </PageSection>\r\n      <Form isHorizontal>\r\n      <FormGroup label=\"s2i-mpg-integrator Pods\" isRequired fieldId=\"horizontal-form-mpg-pods\">\r\n        <TextInput\r\n          value={mpgPods}\r\n          isRequired\r\n          type=\"text\"\r\n          id=\"horizontal-form-mpg-pods\"\r\n          aria-describedby=\"horizontal-form-mpg-pods-helper\"\r\n          name=\"horizontal-form-mpg-pods\"\r\n          onChange={(_event, value) => setMpgPods(value.trim())}\r\n        />\r\n        <FormHelperText>\r\n          <HelperText>\r\n            <HelperTextItem>Input s2i-mpg-integrator pod URLs</HelperTextItem>\r\n          </HelperText>\r\n        </FormHelperText>\r\n      </FormGroup>\r\n      <FormGroup label=\"s2i-ccpay-integrator Pods\" isRequired fieldId=\"horizontal-form-ccpay-pods\">\r\n        <TextInput\r\n          value={ccpayPods}\r\n          isRequired\r\n          type=\"text\"\r\n          id=\"horizontal-form-ccpay-pods\"\r\n          aria-describedby=\"horizontal-form-ccpay-pods-helper\"\r\n          name=\"horizontal-form-ccpay-pods\"\r\n          onChange={(_event, value) => setCcpayPods(value.trim())}\r\n        />\r\n        <FormHelperText>\r\n          <HelperText>\r\n            <HelperTextItem>Input s2i-ccpay-integrator pod URLs.</HelperTextItem>\r\n          </HelperText>\r\n        </FormHelperText>\r\n      </FormGroup>\r\n      <FormGroup label=\"s2i-service-integrator Pods\" isRequired fieldId=\"horizontal-form-service-pods\">\r\n        <TextInput\r\n          value={servicePods}\r\n          isRequired\r\n          type=\"text\"\r\n          id=\"horizontal-form-service-pods\"\r\n          aria-describedby=\"horizontal-form-service-pods-helper\"\r\n          name=\"horizontal-form-service-pods\"\r\n          onChange={(_event, value) => setServicePods(value.trim())}\r\n        />\r\n        <FormHelperText>\r\n          <HelperText>\r\n            <HelperTextItem>Input s2i-services-integrator pod URLs.</HelperTextItem>\r\n          </HelperText>\r\n        </FormHelperText>\r\n      </FormGroup>\r\n      <ActionGroup>\r\n        <Button \r\n          variant=\"primary\"\r\n          onClick={() => refreshConfig()}\r\n          isDisabled={isRefreshing}\r\n          {...primaryRefreshingProps}\r\n          >\r\n           {isRefreshing ? 'Refreshing' : 'Refresh Config'}\r\n        </Button>\r\n      </ActionGroup>\r\n    </Form>\r\n   \r\n  </>\r\n}\r\n","import { configManager, hawtio, Hawtio, Logger, registerPlugins } from '@hawtio/react'\r\nimport React from 'react'\r\nimport ReactDOM from 'react-dom/client'\r\nimport { registerMyPlugins } from './plugins'\r\nconst hawtioVersion = '4.1.0'\r\n\r\nconst log = Logger.get('hawtio-console');\r\nlog.info('Hawtio console:', hawtioVersion);\r\n\r\n// Register builtin plugins\r\nregisterPlugins();\r\nregisterMyPlugins();\r\n\r\nhawtio\r\n  // Set up plugin location\r\n  .addUrl('plugin')\r\n  // Bootstrap Hawtio\r\n  .bootstrap();\r\n\r\n// Configure the console version\r\nconfigManager.addProductInfo('Hawtio', hawtioVersion);\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)\r\nroot.render(\r\n  <React.StrictMode>\r\n    <Hawtio />\r\n  </React.StrictMode>,\r\n)\r\n","import { hawtio, HawtioPlugin } from '@hawtio/react'\r\nimport { SpringConfig } from './spring-config'\r\n\r\nexport const registerSpringConfig: HawtioPlugin = () => {\r\n  hawtio.addPlugin({\r\n    id: 'spring-configurations',\r\n    title: 'Spring Configurations',\r\n    path: '/spring-config',\r\n    component: SpringConfig,\r\n    isActive: async () => true,\r\n  })\r\n}\r\n","import { hawtio, HawtioPlugin } from '@hawtio/react'\r\nimport { RefreshConfig } from './refresh-config'\r\n\r\nexport const registerRefreshConfig: HawtioPlugin = () => {\r\n  hawtio.addPlugin({\r\n    id: 'refresh-configurations',\r\n    title: 'Refresh Configurations',\r\n    path: '/refresh',\r\n    component: RefreshConfig,\r\n    isActive: async () => true,\r\n  })\r\n}\r\n"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","id","module","exports","MyConfigContext","createContext","config","MyConfigProvider","_ref","children","setConfig","useState","useEffect","async","data","fetch","json","console","log","dataFetch","value","useMemo","_jsx","Provider","showModal","hideModal","confirmModal","row","message","Modal","bodyAriaLabel","tabIndex","variant","ModalVariant","medium","title","isOpen","onClose","actions","Button","onClick","className","importConfiguration","uploadedFile","setUploadedFile","inputRef","useRef","_jsxs","isDisabled","event","preventDefault","importConfigurationData","htmlFor","ref","onChange","handleDisplayFileDetails","_inputRef$current2","current","files","type","handleUpload","_inputRef$current","click","concat","name","isObject","thing","File","Date","Array","isArray","asNumber","test","n","Number","isNaN","ADDITIONAL_PROPERTY_FLAG","ADDITIONAL_PROPERTIES_KEY","ALL_OF_KEY","ANY_OF_KEY","CONST_KEY","DEFAULT_KEY","DEPENDENCIES_KEY","ENUM_KEY","ERRORS_KEY","ID_KEY","IF_KEY","ITEMS_KEY","NAME_KEY","ONE_OF_KEY","PROPERTIES_KEY","REQUIRED_KEY","SUBMIT_BTN_OPTIONS_KEY","REF_KEY","RJSF_ADDITIONAL_PROPERTIES_FLAG","ROOT_SCHEMA_PREFIX","UI_WIDGET_KEY","UI_OPTIONS_KEY","getUiOptions","uiSchema","arguments","length","undefined","globalOptions","Object","filter","key","indexOf","reduce","options","error","substring","canExpand","schema","formData","additionalProperties","expandable","maxProperties","createErrorHandler","handler","addError","this","push","acc","isPlainObject","formObject","deepEquals","a","b","isEqualWith","obj","other","splitKeyElementFromObject","object","omit","findSchemaDefinitionRecursive","$ref","rootSchema","recurseList","decodedRef","startsWith","decodeURIComponent","jsonpointer","get","nextRef","includes","firstRef","restRefs","circularPath","join","remaining","theRef","subSchema","findSchemaDefinition","getOptionMatchingSimpleDiscriminator","discriminatorField","i","_discriminator$enum","option","discriminator","getMatchingOption","validator","simpleDiscriminatorMatch","isNumber","has","isValid","requiresAnyOf","anyOf","map","required","augmentedSchema","shallowClone","allOf","slice","assign","getFirstMatchingOption","getDiscriminatorFieldFromSchema","maybeString","isString","warn","guessType","getSchemaType","const","enum","properties","find","mergeSchemas","obj1","obj2","left","right","union","retrieveSchema","retrieveSchemaInternal","getAllPermutationsOfXxxOf","listOfLists","permutations","list","flatMap","element","times","forEach","permutation","resolveReference","expandAllBranches","updatedSchema","resolveAllReferences","resolvedSchema","localSchema","childrenLists","updatedProps","transform","result","childList","merge","uniq","flattenDeep","items","isEqual","rawFormData","resolvedSchemas","updatedSchemas","resolveDependencies","s","allOfSubschema","resolveSchema","if","expression","then","else","otherwise","resolvedSchemaLessConditional","conditionValue","schemas","conditionalSchema","resolveCondition","restOfSchema","mergeAllOf","deep","resolvedSchemaWithoutAllOf","theSchema","aFormData","set","stubExistingAdditionalProperties","dependencies","remainingSchema","anyOrOneOf","oneOf","item","resolveAnyOrOneOfSchemas","processDependencies","dependencyKey","remainingDependencies","dependencyValue","withDependentProperties","withDependentSchema","additionallyRequired","from","Set","dependent","dependentSchema","subschema","resolvedOneOf","validSubschemas","conditionPropertySchema","conditionSchema","dependentSubschema","withExactlyOneSubschema","JUNK_OPTION","$id","__not_really_there__","calculateIndexScore","totalScore","score","formValue","newSchema","getClosestMatchingOption","newScore","default","selectedOption","resolvedOptions","allValidIndexes","validList","index","scoreCount","bestIndex","scoreData","bestScore","add","size","isFixedItems","every","mergeDefaultsWithFormData","defaults","mergeExtraArrayDefaults","defaultsArray","mapped","idx","mergeObjects","concatArrays","toMerge","isSelect","altSchemas","isConstant","isMultiSelect","uniqueItems","AdditionalItemsHandling","getInnerSchemaForArrayItem","additionalItems","Ignore","maybeAddDefaultToObject","computedDefault","includeUndefinedValues","isParentRequired","requiredFields","experimental_defaultFormStateBehavior","emptyObjectFields","isSelfOrParentRequired","isEmpty","computeDefaults","rawSchema","parentDefaults","_recurseList","schemaToCompute","updatedRecurseList","refName","itemSchema","retrievedSchema","objectDefaults","_retrievedSchema$requ","field","additionalPropertiesSchema","formDataRequired","_retrievedSchema$requ2","_experimental_default","_experimental_default2","_experimental_default3","_experimental_default4","neverPopulate","arrayMinItems","populate","ignoreMinItemsFlagSet","isSkipEmptyDefaults","computeSkipPopulate","emptyDefault","schemaItem","Fallback","_defaults","defaultsLength","minItems","defaultEntries","fillerSchema","Invert","fillerDefault","fillerEntries","fill","getDefaultFormState","mergeExtraDefaults","isCustomWidget","isFilesArray","itemsSchema","format","NO_VALUE","Symbol","sanitizeDataForNewSchema","oldSchema","newFormData","removeOldSchemaData","nestedData","oldKeyedSchema","newKeyedSchema","oldSchemaTypeForKey","newSchemaTypeForKey","itemData","newOptionDefault","oldOptionDefault","newOptionConst","oldOptionConst","oldSchemaItems","newSchemaItems","oldSchemaType","newSchemaType","maxItems","newValue","aValue","itemValue","toIdSchemaInternal","idPrefix","idSeparator","_schema","findIndex","idSchema","fieldId","toIdSchema","toPathSchemaInternal","pathSchema","replace","xxxOf","schemaItems","schemaAdditionalItems","property","toPathSchema","SchemaUtils","constructor","getValidator","doesSchemaUtilsDiffer","getDisplayLabel","uiOptions","label","displayLabel","schemaType","mergeValidationData","validationData","additionalErrorSchema","errors","oldErrors","errorSchema","oldErrorSchema","toErrorList","pad","num","width","String","dateRangeOptions","start","stop","getFullYear","reverse","englishStringTranslator","stringToTranslate","params","inputString","output","parts","split","param","partIndex","part","replaceStringParameters","enumOptionsValueForIndex","valueIndex","allEnumOptions","emptyValue","val","enumOptionsDeselectValue","selected","v","enumOptionsIsSelected","some","sel","enumOptionsIndexForValue","multiple","selectedIndexes","opt","enumOptionsSelectValue","isNil","all","sort","getDateElementProps","date","time","yearRange","day","month","year","hour","minute","second","dayObj","range","monthObj","yearObj","dateElementProp","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","getInputProps","defaultType","autoDefaultStepAny","inputProps","inputType","autocomplete","autoComplete","DEFAULT_OPTIONS","props","disabled","submitText","norender","getSubmitButtonOptions","getTemplate","registry","templates","widgetMap","boolean","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","datetime","color","file","number","updown","integer","array","checkboxes","getWidget","widget","registeredWidgets","ReactIs","createElement","AWidget","MergedWidget","defaultOptions","defaultProps","mergeWidgetOptions","idGenerator","suffix","theId","descriptionId","errorId","examplesId","helpId","titleId","ariaDescribedByIds","examples","optionId","optionIndex","labelValue","hideLabel","fallback","optionsList","schemaWithEnumNames","enumNames","uiEnumNames","_enumNames","altUiSchemas","aSchemaDef","_altUiSchemas","aSchema","toConstant","parseDateString","dateString","includeTime","getTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","schemaRequiresTrueValue","schemaSome","toDateString","dateObject","utcTime","UTC","toJSON","fieldPath","errorList","stack","childSchema","ErrorSchemaBuilder","initialSchema","resetAllErrors","ErrorSchema","getOrCreateErrorBlock","pathOfError","errorBlock","cloneDeep","addErrors","errorOrList","errorsList","setErrors","listToAdd","clearErrors","unwrapErrorHandler","errorHandler","utcToLocal","jsonDate","yyyy","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","validationDataMerge","withIdRefPrefix","schemaNode","node","withIdRefPrefixArray","realObj","withIdRefPrefixObject","TranslatableString","AJV_CONFIG","allErrors","multipleOfPrecision","strict","verbose","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","processRawValidationErrors","rawErrors","customValidate","transformErrors","validationError","invalidSchemaError","instancePath","keyword","schemaPath","parentSchema","rest","trim","missingProperty","currentProperty","uiSchemaTitle","parentSchemaTitle","transformRJSFValidationErrors","builder","path","toPath","splice","toErrorSchema","$schema","__errors","AJV8Validator","localizer","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajvFormatOptions","AjvClass","Ajv","addFormats","addFormat","addKeyword","addMetaSchema","formatName","createAjvInstance","reset","removeSchema","rawValidation","compilationError","compiledValidator","getSchema","compile","err","validateFormData","handleSchemaUpdate","_rootSchema$ID_KEY","_this$ajv$getSchema","rootSchemaId","addSchema","_schemaWithIdRefPrefi","schemaWithIdRefPrefix","schemaId","allKeys","JSON","stringify","hash","charCodeAt","toString","hashString","hashForSchema","generateRowId","nanoid","generateKeyedFormData","keyedToPlainFormData","keyedFormData","keyedItem","hideError","readonly","formContext","schemaUtils","translateString","state","setState","updatedKeyedFormData","newIndex","operation","isItemRequired","canAddItem","formItems","addable","globalUiOptions","newErrorSchema","parseInt","resetErrorSchema","_getNewFormDataRow","allowAdditionalItems","_handleAddClick","newKeyedFormDataRow","newKeyedFormData","onAddClick","onAddIndexClick","onCopyIndexClick","onDropIndexClick","_","onReorderClick","currentTarget","blur","_newKeyedFormData","reOrderArray","onChangeForIndex","onSelectChange","renderArrayFieldItem","canAdd","canRemove","canMoveUp","canMoveDown","itemUiSchema","itemIdSchema","itemErrorSchema","autofocus","onBlur","onFocus","totalItems","fields","ArraySchemaField","SchemaField","ItemSchemaField","orderable","removable","copyable","moveUp","moveDown","copy","remove","toolbar","hasCopy","hasToolbar","hasMoveUp","hasMoveDown","hasRemove","UnsupportedFieldTemplate","reason","MissingItems","_ref2","placeholder","widgets","enumOptions","uiTitle","Widget","renderMultiSelect","renderCustomWidget","fieldTitle","itemSchemas","additionalSchema","arrayProps","itemCast","additional","itemIdPrefix","Template","renderFixedArray","_ref3","renderFiles","_schemaItems","renderNormalArray","schemaTitle","yes","YesLabel","no","NoLabel","o","_schema$enum","enums","_SchemaField","retrievedOptions","getInitialState","getFieldId","fieldErrorSchema","optionSchema","optionsUiSchema","optionUiSchema","translateEnum","TitleOptionPrefix","OptionPrefix","translateParams","intOption","newOption","oldOption","trailingCharMatcherWithPrefix","trailingCharMatcher","initialValue","lastValue","setLastValue","StringField","handleChange","useCallback","charAt","processed","match","re","RegExp","_uiOptions$title","_uiOptions$descriptio","wasPropertyKeyModified","isRequired","onPropertyChange","addedByAdditionalProperties","onDropPropertyClick","copiedFormData","unset","getAvailableKey","preferredKey","duplicateKeySuffixSeparator","newKey","schemaProperties","templateTitle","description","orderedProperties","order","arrayToHash","arr","prev","curr","propertyHash","orderFiltered","prop","orderHash","restIndex","lastIndexOf","complete","orderProperties","style","Markdown","disableParsingRawHTML","InvalidObjectField","templateProps","fieldUiSchema","fieldIdSchema","Field","fieldSchema","content","onKeyChange","oldValue","newKeys","keyValues","renamedObj","_defaultValue","defaultValue","apSchema","NewStringDefault","getDefaultValue","COMPONENT_TYPES","null","SchemaFieldRender","_uiOptions$disabled","_uiOptions$readonly","_uiOptions$autofocus","_idSchema","FieldTemplate","DescriptionFieldTemplate","FieldHelpTemplate","FieldErrorTemplate","handleFieldComponentChange","FieldComponent","componentName","UnknownFieldType","getFieldComponent","Boolean","readOnly","uiSchemaHideError","TheFieldComponent","richDescription","enableMarkdownInDescription","help","classNames","helpComponent","hasErrors","errorsComponent","fieldProps","rawDescription","rawHelp","_AnyOfField","AnyOfField","_OneOfField","OneOfField","isReplacingAnyOrOneOf","_Fragment","defaultWidget","hasWidget","MultiSchemaField","ArrayField","BooleanField","NumberField","ObjectField","NullField","ArrayFieldDescriptionTemplate","ArrayFieldItemTemplate","CopyButton","MoveDownButton","MoveUpButton","RemoveButton","ButtonTemplates","btnStyle","flex","paddingLeft","paddingRight","fontWeight","display","justifyContent","ArrayFieldTemplate","ArrayFieldTitleTemplate","AddButton","itemProps","TitleFieldTemplate","BaseInputTemplate","onChangeOverride","inputValue","_onChange","target","_onBlur","_onFocus","autoFocus","example","SubmitButton","submitButtonProps","IconButton","iconType","icon","otherProps","DescriptionField","ErrorList","ErrorsLabel","REQUIRED_FIELD_SYMBOL","Label","WrapIfAdditionalTemplate","elem","ObjectFieldTemplate","TitleField","UnsupportedField","UnsupportedFieldWithId","UnsupportedFieldWithReason","UnsupportedFieldWithIdAndReason","keyLabel","KeyLabel","border","ErrorListTemplate","DateElement","rootId","SelectWidget","useReducer","action","stateValue","values","readyForChange","handleSetNow","nextState","handleClear","yearsRange","elemProps","hideNowButton","href","NowLabel","hideClearButton","ClearLabel","AltDateWidget","_options$description","checked","handleBlur","handleFocus","inline","enumDisabled","checkboxesValues","itemDisabled","disabledCls","ColorWidget","DateWidget","DateTimeWidget","EmailWidget","addNameToDataURL","dataURL","encodeURIComponent","processFile","Promise","reject","reader","window","FileReader","onerror","onload","_event$target","readAsDataURL","FileInfoPreview","fileInfo","src","maxWidth","download","PreviewLabel","FilesInfo","filesInfo","preview","onRemove","handleRemove","extractFileInfo","dataURLs","blob","dataURILike","_mediaparams$map$find","splitted","media","base64","mime","mediaparams","decodeURI","binary","atob","Blob","Uint8Array","dataURItoBlob","filesInfoEvent","rmFile","accept","filePreview","PasswordWidget","RangeWidget","getValue","optEmptyVal","showPlaceholderOption","TextareaWidget","_ref4","rows","TextWidget","TimeWidget","URLWidget","UpDownWidget","AltDateTimeWidget","CheckboxWidget","CheckboxesWidget","FileWidget","HiddenWidget","RadioWidget","tagName","method","enctype","acceptcharset","acceptCharset","noHtml5Validate","showErrorList","_internalFormWrapper","formRef","getStateFromProps","_props$templates","customTranslateString","getRegistry","currentState","localProps","inputFormData","isSchemaChanged","localState","edit","liveValidate","mustValidate","noValidate","createSchemaUtils","_retrievedSchema","schemaValidationErrors","schemaValidationErrorSchema","schemaValidation","validate","currentErrors","extraErrors","merged","altSchemaUtils","renderErrors","getFieldNames","getAllPaths","_obj","paths","newPaths","_get","_isEmpty","doOmitExtraData","getUsedFormData","_pick","validateFormWithFormData","extraErrorsBlockSubmit","focusOnFirstError","onError","prevErrors","hasError","_formRef$current","_toPath","unshift","elementId","querySelector","focus","focusOnError","as","FormTag","submitOptions","submitUiSchema","encType","onSubmit","persist","omitExtraData","status","doOnChange","liveOmit","filteredErrors","schemaErrors","fieldNames","filterUndefinedErrors","_forEach","errorAtKey","errorKey","filterErrorsBasedOnSchema","doOnBlur","doOnFocus","AddItemButton","BsPlus","Grid","GridItem","sm","lg","Panel","PanelMain","PanelMainBody","Card","ouiaId","span","extraProps","TextInput","CardHeader","CardBody","FormHelperText","List","isPlain","ListItem","HelperText","HelperTextItem","isBlock","IoIosCopy","AiOutlineArrowDown","AiOutlineArrowUp","IoIosRemove","FormGroup","validated","marginBottom","smOffset","height","keyId","generateTemplates","Checkbox","role","isInline","isStack","Radio","optEmptyValue","call","FormSelect","FormSelectOption","TextArea","generateWidgets","generateTheme","Form","themeProps","forwardRef","_themeProps$templates","_templates","directProps","cookies","useCookies","require","useLocation","PageSection","PageSectionVariants","light","TextContent","Text","component","application","profile","Link","to","requestOptions","headers","body","submitData","CardFooter","page","setPage","React","perPage","setPerPage","paginatedRows","setPaginatedRows","activeSortIndex","setActiveSortIndex","activeSortDirection","setActiveSortDirection","navigate","useNavigate","appConfigColumns","dataField","editable","handleSetPage","_evt","newPage","_perPage","startIdx","endIdx","handlePerPageSelect","newPerPage","_newPage","getSortParams","columnIndex","sortBy","direction","defaultDirection","onSort","_event","renderColum","column","Table","Thead","Tr","Th","Tbody","rowIndex","Td","PaginationVariant","bottom","Pagination","itemCount","onSetPage","onPerPageSelect","ErrorBoundaryContext","initialState","resetErrorBoundary","showBoundary","useErrorBoundary","context","useContext","assertErrorBoundaryContext","resetBoundary","SpringConfig","displayDeleteConfirmationModal","setDisplayDeleteConfirmationModal","displayImportConfirmationModal","setDisplayImportConfirmationModal","displayImportSqlConfirmationModal","setDisplayImportSqlConfirmationModal","deleteRow","setDeleteRow","configurations","setconfigurations","loading","setLoading","importConfigurations","configIle","FormData","append","axios","post","response","catch","importSqlConfigurations","hideImportConfigurationModal","hideImportSqlConfigurationModal","hideDeleteConfirmationModal","exportConfig","jsonURL","URL","createObjectURL","link","document","appendChild","removeChild","editAppConfiurationDetails","showAppConfiurationDetails","showDeleteModal","deleteAppConfiurationDetails","configurationTableColumns","isDummyField","formatter","routes","ConfigurationDataCreateForm","ConfigurationDataEditForm","ConfigurationAppDetails","Route","springConfigContent","PageGroup","Divider","DeleteConfirmation","ImportConfiguration","Routes","CookiesProvider","ErrorBoundaryContextProvider","ErrorBoundary","RefreshConfig","mpgPods","setMpgPods","ccpayPods","setCcpayPods","servicePods","setServicePods","isRefreshing","setIsRefreshing","refreshResult","setRefreshResult","primaryRefreshingProps","isLoading","isHorizontal","ActionGroup","refreshConfigUrls","pod","refreshUrl","requestHeader","traceId","refreshConfigurations","refreshConfig","hawtioVersion","Logger","info","registerPlugins","hawtio","addPlugin","isActive","addUrl","bootstrap","configManager","addProductInfo","ReactDOM","getElementById","render","Hawtio"],"sourceRoot":""}